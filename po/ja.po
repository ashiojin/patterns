msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: 2024-04-22T15:58:43+09:00\n"
"PO-Revision-Date: 2024-04-29 13:05+0900\n"
"Last-Translator: MORI, Yuji <ashiojin@gmail.com>\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr "概要"

#: src/SUMMARY.md:3 src/intro.md:1
msgid "Introduction"
msgstr "はじめに"

#: src/SUMMARY.md:4 src/translations.md:1
msgid "Translations"
msgstr "翻訳"

#: src/SUMMARY.md:5 src/idioms/index.md:1
msgid "Idioms"
msgstr "イディオム"

#: src/SUMMARY.md:6 src/idioms/coercion-arguments.md:1
msgid "Use borrowed types for arguments"
msgstr "引数には借用型（borrowed types）を使用する"

#: src/SUMMARY.md:7
msgid "Concatenating Strings with format!"
msgstr "format!による文字列の連結"

#: src/SUMMARY.md:8
msgid "Constructor"
msgstr "コンストラクタ"

#: src/SUMMARY.md:9
msgid "The Default Trait"
msgstr "Default トレイト"

#: src/SUMMARY.md:10
msgid "Collections Are Smart Pointers"
msgstr "コレクションはスマートポインタ"

#: src/SUMMARY.md:11
msgid "Finalisation in Destructors"
msgstr "デストラクタでのファイナライズ"

#: src/SUMMARY.md:12
msgid "`mem::{take(_), replace(_)}`"
msgstr "`mem::{take(_), replace(_)}`"

#: src/SUMMARY.md:13 src/idioms/on-stack-dyn-dispatch.md:1
msgid "On-Stack Dynamic Dispatch"
msgstr "オンスタックの動的ディスパッチ"

#: src/SUMMARY.md:14 src/SUMMARY.md:40
msgid "Foreign function interface (FFI)"
msgstr "Foreign function interface (FFI)"

#: src/SUMMARY.md:15
msgid "Idiomatic Errors"
msgstr "慣習的なエラー"

#: src/SUMMARY.md:16 src/idioms/ffi/accepting-strings.md:1
msgid "Accepting Strings"
msgstr "文字列の受け入れ"

#: src/SUMMARY.md:17 src/idioms/ffi/passing-strings.md:1
msgid "Passing Strings"
msgstr "文字列の受け渡し"

#: src/SUMMARY.md:18
msgid "Iterating over an Option"
msgstr "Option に対する反復処理"

#: src/SUMMARY.md:19
msgid "Pass Variables to Closure"
msgstr "変数をクロージャに渡す"

#: src/SUMMARY.md:20
msgid "Privacy For Extensibility"
msgstr "拡張性のための隠蔽"

#: src/SUMMARY.md:21 src/idioms/rustdoc-init.md:1
msgid "Easy doc initialization"
msgstr "docコメント内の簡易な初期化"

#: src/SUMMARY.md:22 src/idioms/temporary-mutability.md:1
msgid "Temporary mutability"
msgstr "一時的なミュータビリティ"

#: src/SUMMARY.md:23
msgid "Return consumed arg on error"
msgstr "エラー時に消費された引数を返す"

#: src/SUMMARY.md:25 src/patterns/index.md:1
msgid "Design Patterns"
msgstr "デザインパターン"

#: src/SUMMARY.md:26
msgid "Behavioural"
msgstr "振る舞いに関するパターン"

#: src/SUMMARY.md:27 src/patterns/behavioural/command.md:1
msgid "Command"
msgstr "Command"

#: src/SUMMARY.md:28 src/patterns/behavioural/interpreter.md:1
msgid "Interpreter"
msgstr "Interpreter"

#: src/SUMMARY.md:29 src/patterns/behavioural/newtype.md:1
msgid "Newtype"
msgstr "NewType"

#: src/SUMMARY.md:30
msgid "RAII Guards"
msgstr "RAIIガード"

#: src/SUMMARY.md:31
msgid "Strategy"
msgstr "Strategy"

#: src/SUMMARY.md:32 src/patterns/behavioural/visitor.md:1
msgid "Visitor"
msgstr "Visitor"

#: src/SUMMARY.md:33
msgid "Creational"
msgstr "生成に関するパターン"

#: src/SUMMARY.md:34 src/patterns/creational/builder.md:1
msgid "Builder"
msgstr "Builder"

#: src/SUMMARY.md:35 src/patterns/creational/fold.md:1
msgid "Fold"
msgstr "Fold"

#: src/SUMMARY.md:36
msgid "Structural"
msgstr "構造に関するパターン"

# 英題おかしくない？
#: src/SUMMARY.md:37
msgid "Compose Structs"
msgstr "構造体の構成"

#: src/SUMMARY.md:38
msgid "Prefer Small Crates"
msgstr "小さなクレートを好む"

#: src/SUMMARY.md:39 src/patterns/structural/unsafe-mods.md:1
msgid "Contain unsafety in small modules"
msgstr "安全でないものを小さなモジュールに閉じ込める"

#: src/SUMMARY.md:41 src/patterns/ffi/export.md:1
msgid "Object-Based APIs"
msgstr "オブジェクトベースのAPI"

#: src/SUMMARY.md:42 src/patterns/ffi/wrappers.md:1
msgid "Type Consolidation into Wrappers"
msgstr "ラッパーへの型の統合"

#: src/SUMMARY.md:44 src/anti_patterns/index.md:1
msgid "Anti-patterns"
msgstr "アンチパターン"

#: src/SUMMARY.md:45 src/anti_patterns/borrow_clone.md:1
msgid "Clone to satisfy the borrow checker"
msgstr "借用チェッカーを満足させるためのクローン"

#: src/SUMMARY.md:46
msgid "`#[deny(warnings)]`"
msgstr "`#[deny(warnings)]`"

#: src/SUMMARY.md:47
msgid "Deref Polymorphism"
msgstr "Deref ポリモーフィズム"

#: src/SUMMARY.md:49
msgid "Functional Programming"
msgstr "関数型プログラミング"

#: src/SUMMARY.md:50 src/functional/paradigms.md:1
msgid "Programming paradigms"
msgstr "プログラミングパラダイム"

#: src/SUMMARY.md:51 src/functional/generics-type-classes.md:1
msgid "Generics as Type Classes"
msgstr "型クラスとしてのジェネリック"

#: src/SUMMARY.md:52
msgid "Functional Optics"
msgstr "関数型オプティクス"

#: src/SUMMARY.md:54
msgid "Additional Resources"
msgstr "追加リソース"

#: src/SUMMARY.md:55 src/additional_resources/design-principles.md:1
msgid "Design principles"
msgstr "設計原則"

#: src/intro.md:3
msgid "Participation"
msgstr "参加"

#: src/intro.md:5
msgid ""
"If you are interested in contributing to this book, check out the "
"[contribution guidelines](https://github.com/rust-unofficial/patterns/blob/"
"master/CONTRIBUTING.md)."
msgstr ""
"本書への寄稿にご興味のある方は、[contribution guidelines](https://github.com/"
"rust-unofficial/patterns/blob/master/CONTRIBUTING.md)をご覧ください。"

#: src/intro.md:8
msgid "News"
msgstr "ニュース"

# pdf出力するなら、URL周りどうにかするべし。
#: src/intro.md:10
msgid ""
"**2024-03-17**: You can now download the book in PDF format from [this link]"
"(https://rust-unofficial.github.io/patterns/rust-design-patterns.pdf)."
msgstr ""
"**2024-03-17**:このリンク](https://rust-unofficial.github.io/patterns/rust-"
"design-patterns.pdf)からPDF形式でダウンロードできるようになりました。"

#: src/intro.md:13
msgid "Design patterns"
msgstr "デザインパターン"

#: src/intro.md:15
msgid ""
"In software development, we often come across problems that share "
"similarities regardless of the environment they appear in. Although the "
"implementation details are crucial to solve the task at hand, we may "
"abstract from these particularities to find the common practices that are "
"generically applicable."
msgstr ""
"ソフトウェア開発では、それがどのような環境で発生したかに関係なく、共通点を持"
"つ問題に出くわすことがよくあります。目の前の課題を解決するためには実装上の詳"
"細が重要ですが、私たちはこのような詳細から抽出することで、一般的に適用可能な"
"共通プラクティスを見出すことが可能です。"

#: src/intro.md:20
msgid ""
"Design patterns are a collection of reusable and tested solutions to "
"recurring problems in engineering. They make our software more modular, "
"maintainable, and extensible. Moreover, these patterns provide a common "
"language for developers, making them an excellent tool for effective "
"communication when problem-solving in teams."
msgstr ""
"デザインパターンとは、エンジニアリングで繰り返し発生する問題に対する、再利用"
"可能でテスト済みの解決策を集めたものです。デザインパターンは、ソフトウェアを"
"よりモジュール化し、保守しやすく、拡張しやすいものにします。さらに、これらの"
"パターンは開発者に共通言語を提供するため、チームが問題解決する際の効果的なコ"
"ミュニケーションツールとなります。"

#: src/intro.md:26 src/patterns/index.md:14
msgid "Design patterns in Rust"
msgstr "Rustのデザインパターン"

#: src/intro.md:28
msgid ""
"Rust is not object-oriented, and the combination of all its characteristics, "
"such as functional elements, a strong type system, and the borrow checker, "
"makes it unique. Because of this, Rust design patterns vary with respect to "
"other traditional object-oriented programming languages. That's why we "
"decided to write this book. We hope you enjoy reading it! The book is "
"divided in three main chapters:"
msgstr ""
"Rustはオブジェクト指向ではありません。また、関数型プログラミングの要素、強力"
"な型システム、借用チェッカーなど、Rustのすべての特徴の組み合わせがRustをユ"
"ニークなものにしています。このため、Rust のデザインパターンは他の伝統的なオブ"
"ジェクト指向プログラミング言語とは異なります。これが私たちがこの本を書くこと"
"にした理由です。ご愛読いただければ幸いです！本書は大きく3つの章に分かれていま"
"す："

#: src/intro.md:35
msgid ""
"[Idioms](./idioms/index.md): guidelines to follow when coding. They are the "
"social norms of the community. You should break them only if you have a good "
"reason for it."
msgstr ""
"[イディオム](./idioms/index.md)：コーディングの際に従うべきガイドライン。コ"
"ミュニティの社会的規範です。正当な理由がある場合のみ破るべきです。"

#: src/intro.md:38
msgid ""
"[Design patterns](./patterns/index.md): methods to solve common problems "
"when coding."
msgstr ""
"[デザインパターン](./patterns/index.md)：コーディング時によくある問題を解決す"
"るための手法。"

#: src/intro.md:40
msgid ""
"[Anti-patterns](./anti_patterns/index.md): methods to solve common problems "
"when coding. However, while design patterns give us benefits, anti-patterns "
"create more problems."
msgstr ""
"[アンチパターン](./anti_patterns/index.md)：コーディング時によくある問題を解"
"決するための手法。しかし、デザイン・パターンには利点がある一方で、アンチ・パ"
"ターンはより多くの問題を引き起こします。"

#: src/translations.md:3
msgid ""
"We are utilizing [mdbook-i18n-helper](https://github.com/google/mdbook-i18n-"
"helpers). Please read up on how to _add_ and _update_ translations in [their "
"repository](https://github.com/google/mdbook-i18n-helpers#creating-and-"
"updating-translations)"
msgstr ""
"私たちは[mdbook-i18n-helper](https://github.com/google/mdbook-i18n-helpers)を"
"利用しています。翻訳の追加と更新の方法は[そのリポジトリ](https://github.com/"
"google/mdbook-i18n-helpers#creating-and-updating-translations)を参照してくだ"
"さい。"

#: src/translations.md:8
msgid "External translations"
msgstr "外部の翻訳"

#: src/translations.md:10
msgid "[简体中文](https://fomalhauthmj.github.io/patterns/)"
msgstr "- [简体中文](https://fomalhauthmj.github.io/patterns/)"

#: src/translations.md:12
msgid ""
"If you want to add a translation, please open an issue in the [main "
"repository](https://github.com/rust-unofficial/patterns)."
msgstr ""
"翻訳を追加したい場合は、[メインリポジトリ](https://github.com/rust-"
"unofficial/patterns) にissueを開いてください。"

#: src/idioms/index.md:3
msgid ""
"[Idioms](https://en.wikipedia.org/wiki/Programming_idiom) are commonly used "
"styles, guidelines and patterns largely agreed upon by a community. Writing "
"idiomatic code allows other developers to understand better what is "
"happening."
msgstr ""
"[イディオム](https://en.wikipedia.org/wiki/Programming_idiom)は、一般的に使わ"
"れているスタイル、ガイドライン、パターンです。慣用的なコードを書くことで、他"
"の開発者は何が起こっているのかをよりよく理解することができます。"

#: src/idioms/index.md:7
msgid ""
"After all, the computer only cares about the machine code that is generated "
"by the compiler. Instead, the source code is mainly beneficial to the "
"developer. So, since we have this abstraction layer, why not make it more "
"readable?"
msgstr ""
"結局のところ、コンピュータにとって重要なものは、コンパイラが生成したマシン"
"コードのみです。むしろ、ソースコードは主に開発者にとって有益なものです。せっ"
"かく、私たちには抽象化レイヤーがあるのですから、もっと読みやすくしたらどうで"
"しょう？"

#: src/idioms/index.md:11
msgid ""
"Remember the [KISS principle](https://en.wikipedia.org/wiki/KISS_principle): "
"\"Keep It Simple, Stupid\". It claims that \"most systems work best if they "
"are kept simple rather than made complicated; therefore, simplicity should "
"be a key goal in design, and unnecessary complexity should be avoided\"."
msgstr ""
"[KISSの原則](https://en.wikipedia.org/wiki/KISS_principle) ：「シンプルにして"
"おけ！この間抜け」を思い出してください。この原則は、「ほとんどのシステムは、"
"複雑にするよりもシンプルにしたほうが最もうまく機能する。したがって、シンプル"
"であることが設計における重要な目標であるべきであり、不必要な複雑さは避けるべ"
"きである」と主張しています。"

#: src/idioms/index.md:16
msgid "Code is there for humans, not computers, to understand."
msgstr ""
"コードは人間が理解するものであって、コンピューターが理解するものではありませ"
"ん。"

#: src/idioms/coercion-arguments.md:3 src/idioms/concat-format.md:3
#: src/idioms/ctor.md:3 src/idioms/default.md:3 src/idioms/deref.md:3
#: src/idioms/dtor-finally.md:3 src/idioms/mem-replace.md:3
#: src/idioms/on-stack-dyn-dispatch.md:3 src/idioms/ffi/errors.md:3
#: src/idioms/ffi/accepting-strings.md:3 src/idioms/ffi/passing-strings.md:3
#: src/idioms/option-iter.md:3 src/idioms/pass-var-to-closure.md:3
#: src/idioms/priv-extend.md:3 src/idioms/rustdoc-init.md:3
#: src/idioms/temporary-mutability.md:3
#: src/idioms/return-consumed-arg-on-error.md:3
#: src/patterns/behavioural/command.md:3
#: src/patterns/behavioural/interpreter.md:3
#: src/patterns/behavioural/newtype.md:13 src/patterns/behavioural/RAII.md:3
#: src/patterns/behavioural/strategy.md:3 src/patterns/behavioural/visitor.md:3
#: src/patterns/creational/builder.md:3 src/patterns/creational/fold.md:3
#: src/patterns/structural/compose-structs.md:3
#: src/patterns/structural/small-crates.md:3
#: src/patterns/structural/unsafe-mods.md:3 src/patterns/ffi/export.md:3
#: src/patterns/ffi/wrappers.md:3 src/anti_patterns/borrow_clone.md:3
#: src/anti_patterns/deny-warnings.md:3 src/anti_patterns/deref.md:3
#: src/functional/generics-type-classes.md:3
msgid "Description"
msgstr "説明"

#: src/idioms/coercion-arguments.md:5
msgid ""
"Using a target of a deref coercion can increase the flexibility of your code "
"when you are deciding which argument type to use for a function argument. In "
"this way, the function will accept more input types."
msgstr ""
"関数の引数にどの型を使うかを決めるときに、参照外し型強制(deref coercion)の対"
"象を使うことで、コードの柔軟性を高めることができます。この方法により、関数は"
"より多くの型を入力として受け入れられるようになります。"

#: src/idioms/coercion-arguments.md:9
msgid ""
"This is not limited to slice-able or fat pointer types. In fact, you should "
"always prefer using the **borrowed type** over **borrowing the owned type**. "
"Such as `&str` over `&String`, `&[T]` over `&Vec<T>`, or `&T` over `&Box<T>`."
msgstr ""
"これはスライス可能な型やファットポインタ型に限ったことではありません。実際、"
"**所有型の借用**よりも **借用型** を常に使用することをお勧めします。例えば、 "
"`&String` よりも `&str` の方が、 `&Vec<T>` よりも `&[T]` の方が、 `&Box<T>` "
"よりも `&T` の方が優れています。"

#: src/idioms/coercion-arguments.md:13
msgid ""
"Using borrowed types you can avoid layers of indirection for those instances "
"where the owned type already provides a layer of indirection. For instance, "
"a `String` has a layer of indirection, so a `&String` will have two layers "
"of indirection. We can avoid this by using `&str` instead, and letting "
"`&String` coerce to a `&str` whenever the function is invoked."
msgstr ""
"借用型を使えば、所有型がすでに間接的なレイヤーを提供しているような場合に、そ"
"のインスタンスに対する多重の間接的なレイヤーを避けることができます。例えば "
"`String` には間接的なレイヤーがあるので、 `&String` は2つの間接的なレイヤーを"
"持つことになってしまいます。\n"
"代わりに `&str` を使用し、関数呼び出し毎に `&String` を `&str` に型強制するこ"
"とでこれを避けることができます。"

#: src/idioms/coercion-arguments.md:19 src/idioms/concat-format.md:10
#: src/idioms/default.md:20 src/idioms/deref.md:9 src/idioms/dtor-finally.md:9
#: src/idioms/mem-replace.md:11 src/idioms/on-stack-dyn-dispatch.md:10
#: src/idioms/pass-var-to-closure.md:12 src/idioms/priv-extend.md:19
#: src/idioms/rustdoc-init.md:45 src/idioms/temporary-mutability.md:12
#: src/idioms/return-consumed-arg-on-error.md:8
#: src/patterns/behavioural/command.md:18
#: src/patterns/behavioural/newtype.md:18 src/patterns/behavioural/RAII.md:12
#: src/patterns/behavioural/strategy.md:30
#: src/patterns/behavioural/visitor.md:13 src/patterns/creational/builder.md:7
#: src/patterns/creational/fold.md:12
#: src/patterns/structural/compose-structs.md:15
#: src/anti_patterns/borrow_clone.md:11 src/anti_patterns/deny-warnings.md:8
#: src/anti_patterns/deref.md:8 src/functional/generics-type-classes.md:38
msgid "Example"
msgstr "例"

#: src/idioms/coercion-arguments.md:21
msgid ""
"For this example, we will illustrate some differences for using `&String` as "
"a function argument versus using a `&str`, but the ideas apply as well to "
"using `&Vec<T>` versus using a `&[T]` or using a `&Box<T>` versus a `&T`."
msgstr ""
"この例では、関数の引数に `&String` を使用した場合に対して、 `&str` を使用した"
"場合との違いを説明します。なお、ここで示すものは `Vec<T>` に対しての `&[T]` "
"や、 `&Box<T>` に対しての `&T` 、などあっても同様のことが言えます。"

#: src/idioms/coercion-arguments.md:25
msgid ""
"Consider an example where we wish to determine if a word contains three "
"consecutive vowels. We don't need to own the string to determine this, so we "
"will take a reference."
msgstr ""
"例として、ある単語が連続した3つの母音を含むかどうかを調べたい場合を考えてみま"
"しょう。調べるにあたって、対象の文字列を所有する必要はありません。私たちは参"
"照を使うでしょう。"

#: src/idioms/coercion-arguments.md:29
msgid "The code might look something like this:"
msgstr "コードは次のようになります："

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'a'"
msgstr "'a'"

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'e'"
msgstr "'e'"

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'i'"
msgstr "'i'"

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'o'"
msgstr "'o'"

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'u'"
msgstr "'u'"

#: src/idioms/coercion-arguments.md:49
msgid "\"Ferris\""
msgstr "\"Ferris\""

#: src/idioms/coercion-arguments.md:50
msgid "\"Curious\""
msgstr "\"Curious\""

#: src/idioms/coercion-arguments.md:51 src/idioms/coercion-arguments.md:52
msgid "\"{}: {}\""
msgstr "\"{}: {}\""

#: src/idioms/coercion-arguments.md:54
msgid ""
"// This works fine, but the following two lines would fail:\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
msgstr ""
"// これはうまくいくが、次の2行は失敗する：\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"))；\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"))；\n"

#: src/idioms/coercion-arguments.md:60
msgid ""
"This works fine because we are passing a `&String` type as a parameter. If "
"we remove the comments on the last two lines, the example will fail. This is "
"because a `&str` type will not coerce to a `&String` type. We can fix this "
"by simply modifying the type for our argument."
msgstr ""
"これは `&String` 型をパラメータとして渡しているため、問題なく動作します。最後"
"の2行のコメントを削除すると、この例は失敗します。これは `&str` 型が "
"`&String` 型に型強制されないからです。この問題を、単に引数の型を変更すること"
"で修正できます。"

#: src/idioms/coercion-arguments.md:65
msgid "For instance, if we change our function declaration to:"
msgstr "例えば、関数宣言を次のように変更します："

#: src/idioms/coercion-arguments.md:71
msgid "then both versions will compile and print the same output."
msgstr ""
"すると、上述の例のどちらのバージョンもコンパイルされ、同じ出力が表示されま"
"す。"

#: src/idioms/coercion-arguments.md:78
msgid ""
"But wait, that's not all! There is more to this story. It's likely that you "
"may say to yourself: that doesn't matter, I will never be using a `&'static "
"str` as an input anyways (as we did when we used `\"Ferris\"`). Even "
"ignoring this special example, you may still find that using `&str` will "
"give you more flexibility than using a `&String`."
msgstr ""
"でも待ってください！この話にはまだ続きがあります。もしかしたら、あなたは"
"「 `&'static str` を（上述の例での `\"Ferris\"` で行ったように）入力に使うこ"
"とは絶対ない・・・どうでもいいかな」と思っているかもしれません。または、この"
"特別な例を無視しても、`&str`を使用する方が`&'static str`を使用するよりも柔軟"
"性があることに気づくかもしれません。"

#: src/idioms/coercion-arguments.md:84
msgid ""
"Let's now take an example where someone gives us a sentence, and we want to "
"determine if any of the words in the sentence contain three consecutive "
"vowels. We probably should make use of the function we have already defined "
"and simply feed in each word from the sentence."
msgstr ""
"では、誰かが私たちに文章を与えたとして、その中に3つの母音が連続する単語がある"
"かどうかを調べる例を考えてみましょう。この場合、すでに定義した関数を利用すべ"
"きで、単に文中の単語をこの関数に与えるべきでしょう。"

#: src/idioms/coercion-arguments.md:89
msgid "An example of this could look like this:"
msgstr "この例は次のようなものです："

#: src/idioms/coercion-arguments.md:110
msgid "\"Once upon a time, there was a friendly curious crab named Ferris\""
msgstr "\"Once upon a time, there was a friendly curious crab named Ferris\""

#: src/idioms/coercion-arguments.md:111
msgid "' '"
msgstr "' '"

#: src/idioms/coercion-arguments.md:113
msgid "\"{word} has three consecutive vowels!\""
msgstr "\"{word} has three consecutive vowels!\""

#: src/idioms/coercion-arguments.md:119
msgid ""
"Running this example using our function declared with an argument type "
"`&str` will yield"
msgstr ""
"引数を `&str` として宣言した関数を使用してこの例を実行すると、次のようになる"
"でしょう"

#: src/idioms/coercion-arguments.md:126
msgid ""
"However, this example will not run when our function is declared with an "
"argument type `&String`. This is because string slices are a `&str` and not "
"a `&String` which would require an allocation to be converted to `&String` "
"which is not implicit, whereas converting from `String` to `&str` is cheap "
"and implicit."
msgstr ""
"しかし私たちが関数の引数型を `&String` として宣言していた場合には、この例は実"
"行できません。これは、文字列スライスが `&str` であり、`&String` ではないため"
"です。 `&str` は `&String` に変換するためにはアロケーションを必要とし、暗黙期"
"には変換されません。対して `String` は `&str` に安価かつ暗黙的に変換されま"
"す。"

#: src/idioms/coercion-arguments.md:132 src/idioms/ctor.md:101
#: src/idioms/default.md:58 src/idioms/deref.md:76
#: src/idioms/dtor-finally.md:89 src/idioms/mem-replace.md:116
#: src/idioms/on-stack-dyn-dispatch.md:84 src/idioms/option-iter.md:47
#: src/idioms/priv-extend.md:118 src/patterns/behavioural/command.md:218
#: src/patterns/behavioural/interpreter.md:144
#: src/patterns/behavioural/newtype.md:94 src/patterns/behavioural/RAII.md:112
#: src/patterns/behavioural/strategy.md:178
#: src/patterns/behavioural/visitor.md:108
#: src/patterns/creational/builder.md:109 src/patterns/creational/fold.md:109
#: src/patterns/structural/small-crates.md:45
#: src/patterns/structural/unsafe-mods.md:33
#: src/anti_patterns/borrow_clone.md:72 src/anti_patterns/deny-warnings.md:101
#: src/anti_patterns/deref.md:124 src/functional/generics-type-classes.md:236
msgid "See also"
msgstr "See also"

#: src/idioms/coercion-arguments.md:134
msgid ""
"[Rust Language Reference on Type Coercions](https://doc.rust-lang.org/"
"reference/type-coercions.html)"
msgstr ""
"[型強制(Type coercions)に関するRust言語リファレンス](https://doc.rust-lang."
"org/reference/type-coercions.html)"

#: src/idioms/coercion-arguments.md:135
msgid ""
"For more discussion on how to handle `String` and `&str` see [this blog "
"series (2015)](https://web.archive.org/web/20201112023149/https://"
"hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html) by Herman "
"J. Radtke III"
msgstr ""
"`String`と`&str`の扱い方に関する議論は、Herman J. Radtke III の [このブログの"
"シリーズ(2015)](https://web.archive.org/web/20201112023149/https://"
"hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html) を見てくだ"
"さい"

#: src/idioms/concat-format.md:1
msgid "Concatenating strings with `format!`"
msgstr "`format! による文字列の連結"

#: src/idioms/concat-format.md:5
msgid ""
"It is possible to build up strings using the `push` and `push_str` methods "
"on a mutable `String`, or using its `+` operator. However, it is often more "
"convenient to use `format!`, especially where there is a mix of literal and "
"non-literal strings."
msgstr ""
"`String` の `push` メソッドや `push_str` メソッドを使用したり、 `+` 演算子を"
"使用したりすることで、文字列を構築することは可能です。\n"
"しかし`format!` を使用した方がより便利なことがあります。特にリテラル文字列と"
"非リテラル文字列が混在している場合がそうです。"

#: src/idioms/concat-format.md:14
msgid ""
"// We could construct the result string manually.\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
msgstr ""
"// 以下のように result 文字列を構築することができます。\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"

#: src/idioms/concat-format.md:20
msgid "// But using format! is better.\n"
msgstr "// しかし format! を使うほうがよいでしょう。\n"

#: src/idioms/concat-format.md:21
msgid "\"Hello {name}!\""
msgstr "\"Hello {name}!\""

#: src/idioms/concat-format.md:25 src/idioms/deref.md:43
#: src/idioms/dtor-finally.md:42 src/idioms/mem-replace.md:91
#: src/idioms/on-stack-dyn-dispatch.md:48 src/idioms/ffi/errors.md:130
#: src/idioms/ffi/accepting-strings.md:65 src/idioms/ffi/passing-strings.md:66
#: src/idioms/pass-var-to-closure.md:48 src/idioms/rustdoc-init.md:77
#: src/idioms/temporary-mutability.md:38
#: src/idioms/return-consumed-arg-on-error.md:55
#: src/patterns/behavioural/newtype.md:55 src/patterns/behavioural/RAII.md:79
#: src/patterns/behavioural/strategy.md:98
#: src/patterns/creational/builder.md:68
#: src/patterns/structural/compose-structs.md:96
#: src/patterns/structural/small-crates.md:13
#: src/patterns/structural/unsafe-mods.md:12 src/patterns/ffi/export.md:113
#: src/patterns/ffi/wrappers.md:64 src/anti_patterns/deny-warnings.md:16
#: src/anti_patterns/deref.md:69 src/functional/generics-type-classes.md:209
msgid "Advantages"
msgstr "長所"

#: src/idioms/concat-format.md:27
msgid ""
"Using `format!` is usually the most succinct and readable way to combine "
"strings."
msgstr ""
"`format!` を使う方法が、通常、文字列を組み合わせる最も簡潔で読みやすい方法で"
"す。"

#: src/idioms/concat-format.md:30 src/idioms/deref.md:50
#: src/idioms/dtor-finally.md:47 src/idioms/mem-replace.md:95
#: src/idioms/on-stack-dyn-dispatch.md:54 src/idioms/ffi/errors.md:135
#: src/idioms/ffi/accepting-strings.md:136
#: src/idioms/ffi/passing-strings.md:101 src/idioms/pass-var-to-closure.md:57
#: src/idioms/priv-extend.md:104 src/idioms/rustdoc-init.md:81
#: src/idioms/temporary-mutability.md:42
#: src/idioms/return-consumed-arg-on-error.md:59
#: src/patterns/behavioural/newtype.md:66
#: src/patterns/behavioural/strategy.md:107
#: src/patterns/creational/builder.md:76
#: src/patterns/structural/compose-structs.md:101
#: src/patterns/structural/small-crates.md:22
#: src/patterns/structural/unsafe-mods.md:18 src/patterns/ffi/export.md:236
#: src/patterns/ffi/wrappers.md:70 src/anti_patterns/deref.md:81
#: src/functional/generics-type-classes.md:220
msgid "Disadvantages"
msgstr "短所"

#: src/idioms/concat-format.md:32
msgid ""
"It is usually not the most efficient way to combine strings - a series of "
"`push` operations on a mutable string is usually the most efficient "
"(especially if the string has been pre-allocated to the expected size)."
msgstr ""
"通常、文字列を結合する最も効率的な方法とは言えません。通常、ミュータブルな文"
"字列への `push` の繰り返しが最も効率的です（特に、その文字列があらかじめ期待"
"されるサイズに割り当てられている場合）。"

#: src/idioms/ctor.md:1
msgid "Constructors"
msgstr "コンストラクタ"

#: src/idioms/ctor.md:5
msgid ""
"Rust does not have constructors as a language construct. Instead, the "
"convention is to use an [associated function](https://doc.rust-lang.org/"
"stable/book/ch05-03-method-syntax.html#associated-functions) `new` to create "
"an object:"
msgstr ""
"Rustには、言語の構成要素としてコンストラクタというものを持っていません。代わ"
"りに [関連関数](https://doc.rust-lang.org/stable/book/ch05-03-method-syntax."
"html#associated-functions) の `new` を使ってオブジェクトを生成するのが一般的"
"です："

#: src/idioms/ctor.md:10
msgid ""
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"
msgstr ""
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"

#: src/idioms/ctor.md:23
msgid ""
"// Constructs a new instance of [`Second`].\n"
"    // Note this is an associated function - no self.\n"
msgstr ""
"// Constructs a new instance of [`Second`].\n"
"    // Note this is an associated function - no self.\n"

#: src/idioms/ctor.md:29 src/idioms/ctor.md:54 src/idioms/ctor.md:85
msgid "/// Returns the value in seconds.\n"
msgstr "/// Returns the value in seconds.\n"

#: src/idioms/ctor.md:36
msgid "Default Constructors"
msgstr "デフォルトコンストラクタ"

#: src/idioms/ctor.md:38
msgid ""
"Rust supports default constructors with the [`Default`](https://doc.rust-"
"lang.org/stable/std/default/trait.Default.html) trait:"
msgstr ""
"Rust は [`Default`][std-default] トレイトとして、デフォルトコンストラクタをサ"
"ポートしています："

#: src/idioms/ctor.md:41 src/idioms/ctor.md:71
msgid ""
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
msgstr ""
"/// 秒単位の時間。\n"
"///\n"
"/// # 例\n"
"///\n"
"/// ```\n"
"/// let s = Second::default()；\n"
"/// assert_eq!(0, s.value())；\n"
"/// ```\n"

#: src/idioms/ctor.md:67
msgid ""
"`Default` can also be derived if all types of all fields implement "
"`Default`, like they do with `Second`:"
msgstr ""
"すべてのフィールドのすべての型が `Default` を実装していれば、 `Default` も派"
"生させることができます。下記の `Second` で行っているように："

#: src/idioms/ctor.md:92
msgid ""
"**Note:** It is common and expected for types to implement both `Default` "
"and an empty `new` constructor. `new` is the constructor convention in Rust, "
"and users expect it to exist, so if it is reasonable for the basic "
"constructor to take no arguments, then it should, even if it is functionally "
"identical to default."
msgstr ""
"**注意:** 型が `Default` と 空の `new` コンストラクタの両方を実装することは一"
"般的であり、期待されています。`new` は Rust におけるコンストラクタの慣習であ"
"り、ユーザはその存在を期待しています。基本的なコンストラクタが引数を取らない"
"ことが合理的であれば、たとえ機能的には default と同じであるとしても、そのよう"
"に実装すべきです。"

#: src/idioms/ctor.md:97
msgid ""
"**Hint:** The advantage of implementing or deriving `Default` is that your "
"type can now be used where a `Default` implementation is required, most "
"prominently, any of the [`*or_default` functions in the standard library]"
"(https://doc.rust-lang.org/stable/std/?search=or_default)."
msgstr ""
"**ヒント:** `Default` を実装または派生させることの利点は、あなたの型が "
"`Default` の実装が必要な場所で使用できるようになることです。特に顕著なのは、 "
"[標準ライブラリの `*or_default` 関数][std-or-default] です。"

#: src/idioms/ctor.md:103
msgid ""
"The [default idiom](default.md) for a more in-depth description of the "
"`Default` trait."
msgstr "`Default` トレイトのより詳細な記述として [default idiom](default.md)。"

#: src/idioms/ctor.md:106
msgid ""
"The [builder pattern](../patterns/creational/builder.md) for constructing "
"objects where there are multiple configurations."
msgstr ""
"構成が多岐に渡るオブジェクトの構築のための [builder pattern](../patterns/"
"creational/builder.md)。"

#: src/idioms/ctor.md:109
msgid ""
"[API Guidelines/C-COMMON-TRAITS](https://rust-lang.github.io/api-guidelines/"
"interoperability.html#types-eagerly-implement-common-traits-c-common-traits) "
"for implementing both, `Default` and `new`."
msgstr ""
"`Default` と `new` の両方を実装することについて [APIガイドライン/C-COMMON-"
"TRAITS](https://rust-lang.github.io/api-guidelines/interoperability."
"html#types-eagerly-implement-common-traits-c-common-traits)。"

#: src/idioms/default.md:1
msgid "The `Default` Trait"
msgstr "`Default` トレイト"

#: src/idioms/default.md:5
msgid ""
"Many types in Rust have a [constructor](ctor.md). However, this is "
"_specific_ to the type; Rust cannot abstract over \"everything that has a "
"`new()` method\". To allow this, the [`Default`](https://doc.rust-lang.org/"
"stable/std/default/trait.Default.html) trait was conceived, which can be "
"used with containers and other generic types (e.g. see [`Option::"
"unwrap_or_default()`](https://doc.rust-lang.org/stable/std/option/enum."
"Option.html#method.unwrap_or_default)). Notably, some containers already "
"implement it where applicable."
msgstr ""
"Rustの多くの型には [コンストラクタ](ctor.md) があります。しかし、これはその"
"型 _固有_ のものです。Rustは「 `new()` メソッドを持つものすべて」を抽象化する"
"ことはできません。これを可能にするために、[`Default`](https://doc.rust-lang."
"org/stable/std/default/trait.Default.html) 特性が考案され、コンテナや他のジェ"
"ネリック型と一緒に使用できます(例えば、[`Option::unwrap_or_default()`]"
"(https://doc.rust-lang.org/stable/std/option/enum.Option.html#method."
"unwrap_or_default) を参照してください)。注目すべきは、いくつかのコンテナは、"
"適用可能な場合、すでにこれを実装していることです。"

#: src/idioms/default.md:11
msgid ""
"Not only do one-element containers like `Cow`, `Box` or `Arc` implement "
"`Default` for contained `Default` types, one can automatically "
"`#[derive(Default)]` for structs whose fields all implement it, so the more "
"types implement `Default`, the more useful it becomes."
msgstr ""
"`Cow`、`Box`、`Arc` のような1要素のコンテナが、その内包する型が `Default` で"
"あるなら、 `Default` を実装する、というだけではありません。すべてのフィールド"
"が `Default` を実装している構造体に対して `#[derive(Default)]` が自動導出可能"
"です。より多くの型が `Default` を実装すればするほどより便利になります。"

#: src/idioms/default.md:16
msgid ""
"On the other hand, constructors can take multiple arguments, while the "
"`default()` method does not. There can even be multiple constructors with "
"different names, but there can only be one `Default` implementation per type."
msgstr ""
"コンストラクタは複数の引数を取ることができる一方、 `default()` メソッドではで"
"きません。またコンストラクタは異なる名称のものを複数定義することもできます"
"が、 `Default` の実装は1つの型につき1つだけです。"

#: src/idioms/default.md:24
msgid "// note that we can simply auto-derive Default here.\n"
msgstr "// ここでは単に Default を自動導出できることに注意。\n"

#: src/idioms/default.md:28
msgid "// Option defaults to None\n"
msgstr "// Option のデフォルトは None\n"

#: src/idioms/default.md:30
msgid "// Vecs default to empty vector\n"
msgstr "// Vec のデフォルトは空のベクトル\n"

#: src/idioms/default.md:32
msgid "// Duration defaults to zero time\n"
msgstr "// Duration のデフォルトはゼロ時間\n"

#: src/idioms/default.md:34
msgid "// bool defaults to false\n"
msgstr "// bool のデフォルトは false\n"

#: src/idioms/default.md:39
msgid "// add setters here\n"
msgstr "// ここにセッターを追加する\n"

#: src/idioms/default.md:43
msgid "// construct a new instance with default values\n"
msgstr "// デフォルト値で新しいインスタンスを作成する\n"

#: src/idioms/default.md:45
msgid "// do something with conf here\n"
msgstr "// ここでconfを使って何かをする\n"

#: src/idioms/default.md:47
msgid "\"conf = {conf:#?}\""
msgstr "\"conf = {conf:#?}\""

#: src/idioms/default.md:49
msgid ""
"// partial initialization with default values, creates the same instance\n"
msgstr "// デフォルト値の上に部分的な初期化、同値のインスタンスを作成\n"

#: src/idioms/default.md:60
msgid ""
"The [constructor](ctor.md) idiom is another way to generate instances that "
"may or may not be \"default\""
msgstr ""
"[constructor](ctor.md) イディオムは、インスタンスを生成する別の方法だが、その"
"インスタンスは「デフォルト」かそうでないかを問わない。"

#: src/idioms/default.md:62
msgid ""
"The [`Default`](https://doc.rust-lang.org/stable/std/default/trait.Default."
"html) documentation (scroll down for the list of implementors)"
msgstr ""
"[`Default`](https://doc.rust-lang.org/stable/std/default/trait.Default.html) "
"のドキュメント(実装しているもののリストは下にスクロールしてください)。"

#: src/idioms/default.md:63
msgid ""
"[`Option::unwrap_or_default()`](https://doc.rust-lang.org/stable/std/option/"
"enum.Option.html#method.unwrap_or_default)"
msgstr ""
"[`Option::unwrap_or_default()`](https://doc.rust-lang.org/stable/std/option/"
"enum.Option.html#method.unwrap_or_default)"

#: src/idioms/default.md:64
msgid "[`derive(new)`](https://crates.io/crates/derive-new/)"
msgstr "[`derive(new)`](https://crates.io/crates/derive-new/)"

#: src/idioms/deref.md:1
msgid "Collections are smart pointers"
msgstr "コレクションはスマートポインタ"

#: src/idioms/deref.md:5
msgid ""
"Use the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) trait "
"to treat collections like smart pointers, offering owning and borrowed views "
"of data."
msgstr ""
"コレクションに [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) "
"トレイトを使うことで、そのデータに対し所有や借用のビューを提供するスマートポ"
"インタのようにコレクションを扱えます。"

#: src/idioms/deref.md:16 src/idioms/deref.md:23
#: src/patterns/behavioural/RAII.md:29 src/patterns/behavioural/RAII.md:41
#: src/patterns/behavioural/RAII.md:100 src/anti_patterns/deref.md:35
msgid "//..\n"
msgstr "//..\n"

#: src/idioms/deref.md:28
msgid ""
"A `Vec<T>` is an owning collection of `T`s, while a slice (`&[T]`) is a "
"borrowed collection of `T`s. Implementing `Deref` for `Vec` allows implicit "
"dereferencing from `&Vec<T>` to `&[T]` and includes the relationship in auto-"
"dereferencing searches. Most methods you might expect to be implemented for "
"`Vec`s are instead implemented for slices."
msgstr ""
"`Vec<T>` は`T` の所有のコレクションであり、対して、スライス(`&[T]`)は `T` の"
"借用のコレクションです。`Vec` に `Deref` を実装することで、 `&Vec<T>` から "
"`&[T]` への暗黙的な参照外しが可能になるとともに、自動参照外しの検索対象に組み"
"込まれます。`Vec` に実装されることが期待されるほとんどのメソッドは、代わりに"
"スライスのそれとして実装されます。"

#: src/idioms/deref.md:34
msgid "Also `String` and `&str` have a similar relation."
msgstr "`String` と `&str` もまた同様の関係にあります。"

#: src/idioms/deref.md:36 src/idioms/dtor-finally.md:32
#: src/idioms/mem-replace.md:63 src/idioms/on-stack-dyn-dispatch.md:37
#: src/idioms/ffi/accepting-strings.md:12 src/idioms/ffi/passing-strings.md:14
#: src/idioms/rustdoc-init.md:9 src/idioms/return-consumed-arg-on-error.md:45
#: src/patterns/behavioural/command.md:8
#: src/patterns/behavioural/interpreter.md:17
#: src/patterns/behavioural/newtype.md:45 src/patterns/behavioural/RAII.md:73
#: src/patterns/behavioural/strategy.md:21
#: src/patterns/behavioural/visitor.md:74 src/patterns/creational/builder.md:63
#: src/patterns/creational/fold.md:73
#: src/patterns/structural/compose-structs.md:90 src/patterns/ffi/export.md:16
#: src/anti_patterns/borrow_clone.md:30
msgid "Motivation"
msgstr "動機形成"

#: src/idioms/deref.md:38
msgid ""
"Ownership and borrowing are key aspects of the Rust language. Data "
"structures must account for these semantics properly to give a good user "
"experience. When implementing a data structure that owns its data, offering "
"a borrowed view of that data allows for more flexible APIs."
msgstr ""
"所有権と借用はRust言語の重要な側面です。データ構造は、よりよいユーザエクスペ"
"リエンスのため、これらのセマンティクスに則る必要があります。データを所有する"
"データ構造を実装する場合、そのデータへの借用のビューを提供することで、よりフ"
"レキシブルなAPIを提供することが可能になります。"

#: src/idioms/deref.md:45
msgid ""
"Most methods can be implemented only for the borrowed view, they are then "
"implicitly available for the owning view."
msgstr ""
"ほとんどのメソッドが借用の型に対して実装可能です。それらメソッドが参照外しに"
"より、所有の型に対しても暗黙的に利用可能になります。"

#: src/idioms/deref.md:48
msgid "Gives clients a choice between borrowing or taking ownership of data."
msgstr ""
"データの借用を行うか、所有権を取るか、利用者が選択できるようにしましょう。"

#: src/idioms/deref.md:52
msgid ""
"Methods and traits only available via dereferencing are not taken into "
"account when bounds checking, so generic programming with data structures "
"using this pattern can get complex (see the `Borrow` and `AsRef` traits, "
"etc.)."
msgstr ""
"参照外しを通してのみ利用可能なメソッドとトレイトは、境界チェックの際に考慮さ"
"れません。そのため、このパターンを使用したデータ構造でのジェネリックプログラ"
"ミングは複雑になる可能性があります (トレイト `Borrow` や `AsRef` など参照)。"

#: src/idioms/deref.md:56 src/idioms/dtor-finally.md:62
#: src/idioms/mem-replace.md:105 src/idioms/on-stack-dyn-dispatch.md:68
#: src/idioms/priv-extend.md:87 src/idioms/rustdoc-init.md:88
#: src/patterns/behavioural/command.md:203
#: src/patterns/behavioural/interpreter.md:105
#: src/patterns/behavioural/newtype.md:74 src/patterns/behavioural/RAII.md:84
#: src/patterns/behavioural/strategy.md:113
#: src/patterns/behavioural/visitor.md:81 src/patterns/creational/builder.md:81
#: src/patterns/creational/fold.md:85
#: src/patterns/structural/compose-structs.md:107
#: src/anti_patterns/deref.md:102
msgid "Discussion"
msgstr "議論"

# 第3文がちょっと解釈しがたいが、第1+2文の流れからすると、コレクションとスマートポインタとの相似的な部分に言及していると思われる。
# つまり、コレクションもスマートポインタ同様、その中身について「所有」しているのだ！といいたいと判断する。
# 第4文の、「（スマートポインタ同様）データを所有しているなら、データの借用ビューを提供するといいよ！」という結論につなぐものだと思う。
# 括弧内は、例外的なこと（データが共有されていた場合）について触れていて、
# その場合でも、部分的に同じことが言えるはずだと主張しようとしていると思われる。
# ただ、この段落での「借用のビュー」への言及は第４文が初なので、話が前後してしまっているため、わかりにくい部分が出ていると思われる。
#: src/idioms/deref.md:58
msgid ""
"Smart pointers and collections are analogous: a smart pointer points to a "
"single object, whereas a collection points to many objects. From the point "
"of view of the type system, there is little difference between the two. A "
"collection owns its data if the only way to access each datum is via the "
"collection and the collection is responsible for deleting the data (even in "
"cases of shared ownership, some kind of borrowed view may be appropriate). "
"If a collection owns its data, it is usually useful to provide a view of the "
"data as borrowed so that it can be referenced multiple times."
msgstr ""
"スマート・ポインタとコレクションは相似です。スマートポインタは単一のオブジェ"
"クトを指すのに対し、コレクションは多数のオブジェクトを指します。型システムの"
"観点からは、両者にほとんど違いはありません。各データへアクセスする唯一の方法"
"がコレクション経由であるなら、コレクションはそれらデータを所有しており、また"
"そのコレクションはデータを削除する責任を持ちます(共有された所有権の場合でも、"
"何らかの借用のビューは適切な場合があります)。コレクションがそのデータを所有す"
"る場合に、そのデータへの借用のビューを提供し複数回参照可能にすることは、一般"
"に有用です。"

#: src/idioms/deref.md:67
msgid ""
"Most smart pointers (e.g., `Foo<T>`) implement `Deref<Target=T>`. However, "
"collections will usually dereference to a custom type. `[T]` and `str` have "
"some language support, but in the general case, this is not necessary. "
"`Foo<T>` can implement `Deref<Target=Bar<T>>` where `Bar` is a dynamically "
"sized type and `&Bar<T>` is a borrowed view of the data in `Foo<T>`."
msgstr ""
"ほとんどのスマートポインタ(例えば `Foo<T>`)は `Deref<Target=T>` を実装しま"
"す。しかしコレクションは通常、カスタム型に参照外しされます。 `[T]`と `str` に"
"はいくつかの言語サポートがありますが、一般的なケースでは、その必要はありませ"
"ん。`Foo<T>` が `Deref<Target=Bar<T>>` を実装してかまいません。ここで `Bar` "
"は動的なサイズの型であり、`&Bar<T>` は `Foo<T>` のデータの借用のビューです。"

#: src/idioms/deref.md:73
msgid ""
"Commonly, ordered collections will implement `Index` for `Range`s to provide "
"slicing syntax. The target will be the borrowed view."
msgstr ""
"一般的に、順序付きコレクションは `Range` に対して `Index` を実装し、スライス"
"構文を提供します。その対象は借用のビューになります。"

#: src/idioms/deref.md:78
msgid "[Deref polymorphism anti-pattern](../anti_patterns/deref.md)."
msgstr "[Deref ポリモーフィズムのアンチパターン](../anti_patterns/deref.md)。"

#: src/idioms/deref.md:79 src/anti_patterns/deref.md:130
msgid ""
"[Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."
msgstr ""
"[`Deref` トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."

#: src/idioms/dtor-finally.md:1
msgid "Finalisation in destructors"
msgstr "デストラクタでのファイナライズ"

#: src/idioms/dtor-finally.md:5
msgid ""
"Rust does not provide the equivalent to `finally` blocks - code that will be "
"executed no matter how a function is exited. Instead, an object's destructor "
"can be used to run code that must be run before exit."
msgstr ""
"Rust には `finally` ブロック (関数の終了の仕方を問わずに実行されるコード) に"
"相当するものがありません。その代わりに、オブジェクトのデストラクタを使用し"
"て、終了前に実行しなければならないコードを実行させることができます。"

#: src/idioms/dtor-finally.md:13
msgid "// These don't need to be defined inside the function.\n"
msgstr "// これらは関数内部で定義する必要はない。\n"

#: src/idioms/dtor-finally.md:16
msgid "// Implement a destructor for Foo.\n"
msgstr "// Foo のデストラクタを実装する。\n"

#: src/idioms/dtor-finally.md:19
msgid "\"exit\""
msgstr "\"exit\""

#: src/idioms/dtor-finally.md:23
msgid "// The dtor of _exit will run however the function `bar` is exited.\n"
msgstr "// _exit のデストラクタは、関数`bar`が終了しても実行される。\n"

#: src/idioms/dtor-finally.md:25
msgid "// Implicit return with `?` operator.\n"
msgstr "// 演算子 `?` による暗黙的なリターン 。\n"

#: src/idioms/dtor-finally.md:27
msgid "// Normal return.\n"
msgstr "// 通常のリターン。\n"

#: src/idioms/dtor-finally.md:34
msgid ""
"If a function has multiple return points, then executing code on exit "
"becomes difficult and repetitive (and thus bug-prone). This is especially "
"the case where return is implicit due to a macro. A common case is the `?` "
"operator which returns if the result is an `Err`, but continues if it is "
"`Ok`. `?` is used as an exception handling mechanism, but unlike Java (which "
"has `finally`), there is no way to schedule code to run in both the normal "
"and exceptional cases. Panicking will also exit a function early."
msgstr ""
"関数に複数のリターン・ポイントがある場合、関数終了時にコードを実行するのは難"
"しく、繰り返し的になります(またそれゆえにバグの原因になります)。リターンがマ"
"クロによって暗黙的に行われる場合、特にそうなります。よくあるケースが `?` 演算"
"子で、これは結果が `Err` なら戻り、`Ok` なら続行するものです。 `?` は例外処理"
"のメカニズムとして使用されますが、(`finally`を持つ) Javaとは異なり、通常と例"
"外の両方のケースで実行されるコードを実装する方法はありません。また、パニック"
"が起きると関数は早期に終了します。"

#: src/idioms/dtor-finally.md:44
msgid ""
"Code in destructors will (nearly) always be run - copes with panics, early "
"returns, etc."
msgstr ""
"デストラクタ内のコードは (ほぼ) 常に実行されます。パニックや早期リターンなど"
"にも対処できます。"

#: src/idioms/dtor-finally.md:49
msgid ""
"It is not guaranteed that destructors will run. For example, if there is an "
"infinite loop in a function or if running a function crashes before exit. "
"Destructors are also not run in the case of a panic in an already panicking "
"thread. Therefore, destructors cannot be relied on as finalizers where it is "
"absolutely essential that finalisation happens."
msgstr ""
"デストラクタの実行は保証されていません。例えば関数の無限ループがある場合や、"
"関数の実行が終了前にクラッシュした場合などです。また、すでにパニックになって"
"いるスレッドでパニックが発生した場合にも、デストラクタは実行されません。した"
"がって、絶対的かつ本質的にファイナライズを行うファイナライザとしては、デスト"
"ラクタを頼ることはできません。"

#: src/idioms/dtor-finally.md:55
msgid ""
"This pattern introduces some hard to notice, implicit code. Reading a "
"function gives no clear indication of destructors to be run on exit. This "
"can make debugging tricky."
msgstr ""
"このパターンは、気づきにくい暗黙のコードを導入することになります。関数を読ん"
"でも、 終了時にデストラクタが実行されることについて、明確な兆候は得られませ"
"ん。これはデバッグを厄介なものにする可能性があります。"

#: src/idioms/dtor-finally.md:59
msgid ""
"Requiring an object and `Drop` impl just for finalisation is heavy on "
"boilerplate."
msgstr ""
"ファイナライズのためだけにオブジェクトと `Drop` の実装が必要となり、ボイラー"
"テンプレートが多くなります。"

#: src/idioms/dtor-finally.md:64
msgid ""
"There is some subtlety about how exactly to store the object used as a "
"finalizer. It must be kept alive until the end of the function and must then "
"be destroyed. The object must always be a value or uniquely owned pointer (e."
"g., `Box<Foo>`). If a shared pointer (such as `Rc`) is used, then the "
"finalizer can be kept alive beyond the lifetime of the function. For similar "
"reasons, the finalizer should not be moved or returned."
msgstr ""
"ファイナライザとして使用されるオブジェクトの正確な格納方法については、繊細な"
"点があります。このオブジェクトは関数が終了するまで存続しなければならず、また"
"終了時に破棄されなければなりません。このオブジェクトは常に値かユニークに所有"
"されるポインタでなければなりません (例 `Box<Foo>` など) 。もし共有ポインタ"
"(`Rc`など)を使用した場合、ファイナライザが関数のライフタイムを超えて存続して"
"しまう可能性があります。同様の理由でファイナライザの所有権を移動したり、ファ"
"イナライザを戻り値としてはいけません。"

#: src/idioms/dtor-finally.md:71
msgid ""
"The finalizer must be assigned into a variable, otherwise it will be "
"destroyed immediately, rather than when it goes out of scope. The variable "
"name must start with `_` if the variable is only used as a finalizer, "
"otherwise the compiler will warn that the finalizer is never used. However, "
"do not call the variable `_` with no suffix - in that case it will be "
"destroyed immediately."
msgstr ""
"ファイナライザは変数に代入しなければなりません。そうでないとスコープを外れる"
"前に即座に破棄されます。変数名は `_` で始まらなければなりません。そうでないと"
"コンパイラは変数が利用されていない旨の警告を出します。しかし変数をサフィック"
"スなしの `_` としてはいけません。そうすると、即座に破棄されてしまいます。"

#: src/idioms/dtor-finally.md:77
msgid ""
"In Rust, destructors are run when an object goes out of scope. This happens "
"whether we reach the end of block, there is an early return, or the program "
"panics. When panicking, Rust unwinds the stack running destructors for each "
"object in each stack frame. So, destructors get called even if the panic "
"happens in a function being called."
msgstr ""
"Rustでは、デストラクタはオブジェクトがスコープ外に出たときに実行されます。こ"
"れが起こるのは、ブロックの終了に到達したとき、早期リターンのとき、パニックが"
"発生したときです。パニックが起きると、Rustはスタックフレームの各オブジェクト"
"のデストラクタを実行しつつスタックを巻き戻します。そのため、呼び出し中の関数"
"内にてパニックが発生した場合でも、デストラクタが呼び出されます。"

#: src/idioms/dtor-finally.md:83
msgid ""
"If a destructor panics while unwinding, there is no good action to take, so "
"Rust aborts the thread immediately, without running further destructors. "
"This means that destructors are not absolutely guaranteed to run. It also "
"means that you must take extra care in your destructors not to panic, since "
"it could leave resources in an unexpected state."
msgstr ""
"デストラクタが巻き戻し中にパニックを起こした場合、取るべき良いアクションはな"
"いため、Rustはそれ以上デストラクタを実行せずにスレッドを即座に終了させます。"
"これは、デストラクタの実行が絶対に保証されているわけではないということです。"
"また、デストラクタがパニックに陥らないように細心の注意を払う必要があるという"
"ことでもあります。リソースを想定されない状態にする可能性があるからです。"

#: src/idioms/dtor-finally.md:91
msgid "[RAII guards](../patterns/behavioural/RAII.md)."
msgstr "[RAIIガード](../patterns/behavioural/RAII.md)。"

#: src/idioms/mem-replace.md:1
msgid "`mem::{take(_), replace(_)}` to keep owned values in changed enums"
msgstr "`mem::{take(_), replace(_)}` による値を所有したままの列挙値の変換"

#: src/idioms/mem-replace.md:5
msgid ""
"Say we have a `&mut MyEnum` which has (at least) two variants, `A { name: "
"String, x: u8 }` and `B { name: String }`. Now we want to change `MyEnum::A` "
"to a `B` if `x` is zero, while keeping `MyEnum::B` intact."
msgstr ""
"`A { name: String, x: u8 }` と `B { name: String }` という(少なくとも) 2つの"
"バリアントを持つ `&mut MyEnum` があるとします。`MyEnum::A` をその `x` が 0 の"
"場合に `B` に変更したいとします。このとき `MyEnum::B` に手を入れたくないとし"
"ます。"

#: src/idioms/mem-replace.md:9
msgid "We can do this without cloning the `name`."
msgstr "`name` をクローンすることなく、これを実行できます。"

#: src/idioms/mem-replace.md:23
msgid ""
"// This takes out our `name` and puts in an empty String instead\n"
"        // (note that empty strings don't allocate).\n"
"        // Then, construct the new enum variant (which will\n"
"        // be assigned to `*e`).\n"
msgstr ""
"// これは `name` を取り出し、その代わりに空文字列を置きます。\n"
"        // (空文字列はメモリが割り当てが発生しないことに注意)\n"
"        // そして、新しい列挙型のバリアントを作成します( `*e` に代入しま"
"す)。\n"

#: src/idioms/mem-replace.md:34
msgid "This also works with more variants:"
msgstr "より多くのバリアントでも同様です："

#: src/idioms/mem-replace.md:49
msgid ""
"// Ownership rules do not allow taking `name` by value, but we cannot\n"
"        // take the value out of a mutable reference, unless we replace it:\n"
msgstr ""
"// 所有権ルールでは `name` を値として取り出すことはできず、        // 値を置"
"き換えない限り、可変参照から値を取り出すことはできない：\n"

#: src/idioms/mem-replace.md:65
msgid ""
"When working with enums, we may want to change an enum value in place, "
"perhaps to another variant. This is usually done in two phases to keep the "
"borrow checker happy. In the first phase, we observe the existing value and "
"look at its parts to decide what to do next. In the second phase we may "
"conditionally change the value (as in the example above)."
msgstr ""
"列挙型を扱うとき、ある列挙型の値を別のバリアントに置き換えたいことがありま"
"す。通常これは、借用チェッカーを満足させるために、二段階に分けて行われます。"
"第一段階では、既存の値を参照し、その一部を見て次の処理を決めます。第二段階で"
"は、(上の例のように) 条件付きで値を変更することができます。"

#: src/idioms/mem-replace.md:71
msgid ""
"The borrow checker won't allow us to take out `name` of the enum (because "
"_something_ must be there.) We could of course `.clone()` name and put the "
"clone into our `MyEnum::B`, but that would be an instance of the [Clone to "
"satisfy the borrow checker](../anti_patterns/borrow_clone.md) anti-pattern. "
"Anyway, we can avoid the extra allocation by changing `e` with only a "
"mutable borrow."
msgstr ""
"借用チェッカーは列挙型の `name` を取り出すことを許可しません (そこに _何か_ "
"がなければならないため)。もちろん、 `name` を `.clone()` して、そのクローン"
"を `MyEnum::B` に入れることはできますが、それは [借用チェッカーを満足させるた"
"めのClone](../anti_patterns/borrow_clone.md) アンチパターンの実例になってしま"
"います。いずれにせよ、 可変借用のみで ‘e‘ を変更することで余分なアロケーショ"
"ンを避けることができます。"

#: src/idioms/mem-replace.md:78
msgid ""
"`mem::take` lets us swap out the value, replacing it with its default value, "
"and returning the previous value. For `String`, the default value is an "
"empty `String`, which does not need to allocate. As a result, we get the "
"original `name` _as an owned value_. We can then wrap this in another enum."
msgstr ""
"`mem::take` は、値をそのデフォルト値に置き換えるとともに、元の値を返します。"
"これにより値を入れ替える形で取り出せます。`String`の場合、デフォルト値は空の "
"`String` であり、アロケートの必要がありません。結果として、元の `name` を _所"
"有した値として_ 取得できます。そしてこれを別の列挙型にラップすることができま"
"す。"

#: src/idioms/mem-replace.md:83
msgid ""
"**NOTE:** `mem::replace` is very similar, but allows us to specify what to "
"replace the value with. An equivalent to our `mem::take` line would be `mem::"
"replace(name, String::new())`."
msgstr ""
"**NOTE:** `mem::replace` は非常に似ていますが、値を何に置き換えるかを指定でき"
"ます。例示の `mem::take` は `mem::replace(name, String::new())` に相当しま"
"す。"

#: src/idioms/mem-replace.md:87
msgid ""
"Note, however, that if we are using an `Option` and want to replace its "
"value with a `None`, `Option`’s `take()` method provides a shorter and more "
"idiomatic alternative."
msgstr ""
"ただし `Option` を使用していてその値を `None` に置き換えたい状況では、 "
"`Option` の `take()` メソッドを使用することがより短くイディオム的な代替手段で"
"あること注意してください。"

# インディージョーンズが何かトラップを回避するために宝物的なモノを置き換えることをイメージしている？
#: src/idioms/mem-replace.md:93
msgid ""
"Look ma, no allocation! Also you may feel like Indiana Jones while doing it."
msgstr ""
"見て！アロケーション無し！インディ・ジョーンズのような気分も味わえるかも。"

#: src/idioms/mem-replace.md:97
msgid ""
"This gets a bit wordy. Getting it wrong repeatedly will make you hate the "
"borrow checker. The compiler may fail to optimize away the double store, "
"resulting in reduced performance as opposed to what you'd do in unsafe "
"languages."
msgstr ""
"少しくどい表現になります。何度も間違えると借用チェッカーが憎くなるかもしれま"
"せん。コンパイラはダブルストアの最適化に失敗するかもしれず、そうすると "
"unsafe な言語で行うのと比べてパフォーマンスが低下する結果となります。"

#: src/idioms/mem-replace.md:101
msgid ""
"Furthermore, the type you are taking needs to implement the [`Default` trait]"
"(./default.md). However, if the type you're working with doesn't implement "
"this, you can instead use `mem::replace`."
msgstr ""
"さらに、扱う型は [`Default` trait](./default.md) を実装している必要がありま"
"す。しかしながら、もし実装していない場合は、代わりに `mem::replace` を使用す"
"ることができます。"

#: src/idioms/mem-replace.md:107
msgid ""
"This pattern is only of interest in Rust. In GC'd languages, you'd take the "
"reference to the value by default (and the GC would keep track of refs), and "
"in other low-level languages like C you'd simply alias the pointer and fix "
"things later."
msgstr ""
"このパターンが注目されるのはRustだけです。GCのある言語では、デフォルトで値へ"
"の参照を取ります（そしてGCは参照を追跡します）。Cのような低レベル言語では、単"
"にポインタをエイリアスして後から修正します。"

#: src/idioms/mem-replace.md:112
msgid ""
"However, in Rust, we have to do a little more work to do this. An owned "
"value may only have one owner, so to take it out, we need to put something "
"back in – like Indiana Jones, replacing the artifact with a bag of sand."
msgstr ""
"しかしRustでは、これを行うにはもう少し工夫が必要です。所有された値には所有者"
"が1人しかいないので、それを取り出すには、何かを戻す必要があります。インディ・"
"ジョーンズのように、アーティファクトを砂袋に置き換えるのです。"

#: src/idioms/mem-replace.md:118
msgid ""
"This gets rid of the [Clone to satisfy the borrow checker](../anti_patterns/"
"borrow_clone.md) anti-pattern in a specific case."
msgstr ""
"これは [借用チェッカーを満足させるためのClone](../anti_patterns/borrow_clone."
"md) アンチパターンを特定のケースで取り除くものです。"

#: src/idioms/on-stack-dyn-dispatch.md:5
msgid ""
"We can dynamically dispatch over multiple values, however, to do so, we need "
"to declare multiple variables to bind differently-typed objects. To extend "
"the lifetime as necessary, we can use deferred conditional initialization, "
"as seen below:"
msgstr ""
"複数の値を動的にディスパッチすることは可能ですが、そうするためには、異なる型"
"のオブジェクトに束縛するため複数の変数を宣言する必要があります。ライフタイム"
"を必要に応じて延長するために、遅延条件付き初期化を使うことができます："

#: src/idioms/on-stack-dyn-dispatch.md:17
#: src/idioms/on-stack-dyn-dispatch.md:23
#: src/idioms/on-stack-dyn-dispatch.md:60
msgid "\"-\""
msgstr "\"-\""

#: src/idioms/on-stack-dyn-dispatch.md:18
msgid ""
"// These must live longer than `readable`, and thus are declared first:\n"
msgstr ""
"// これらは `readable` よりも長く生きなければならないため、最初に宣言する：\n"

#: src/idioms/on-stack-dyn-dispatch.md:21
msgid "// We need to describe the type to get dynamic dispatch.\n"
msgstr "// 動的ディスパッチを得るためには、型を記述する必要がある。\n"

#: src/idioms/on-stack-dyn-dispatch.md:30
#: src/idioms/on-stack-dyn-dispatch.md:64
msgid "// Read from `readable` here.\n"
msgstr "// ここで `readable` から読み込む。\n"

#: src/idioms/on-stack-dyn-dispatch.md:39
msgid ""
"Rust monomorphises code by default. This means a copy of the code will be "
"generated for each type it is used with and optimized independently. While "
"this allows for very fast code on the hot path, it also bloats the code in "
"places where performance is not of the essence, thus costing compile time "
"and cache usage."
msgstr ""
"Rustはデフォルトでコードを単相化します。これは、使用する型毎にコードのコピー"
"が生成され、別個に最適化されることを意味します。これはホットパスにおける非常"
"に高速なコードを実現しますが、パフォーマンスが重要でない場所においてコードが"
"肥大化することにもなります。その結果コンパイル時間やキャッシュの使用量が犠牲"
"になります。"

#: src/idioms/on-stack-dyn-dispatch.md:45
msgid ""
"Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly "
"ask for it."
msgstr ""
"幸いなことに、Rustでは動的ディスパッチが使えますが、明示的に要求する必要があ"
"ります。"

#: src/idioms/on-stack-dyn-dispatch.md:50
msgid ""
"We do not need to allocate anything on the heap. Neither do we need to "
"initialize something we won't use later, nor do we need to monomorphize the "
"whole code that follows to work with both `File` or `Stdin`."
msgstr ""
"ヒープ上に何もアロケートする必要がありません。後で使わないものを初期化する必"
"要もなく、 `File` と `Stdin` の両方で動作するように、続くコード全体を単相化す"
"る必要もありません。"

#: src/idioms/on-stack-dyn-dispatch.md:56
msgid "The code needs more moving parts than the `Box`\\-based version:"
msgstr "このコードは、 `Box` ベースのバージョンよりも多くの変動部があります:"

#: src/idioms/on-stack-dyn-dispatch.md:59
msgid "// We still need to ascribe the type for dynamic dispatch.\n"
msgstr "// 動的なディスパッチには、型を指定する必要がある。\n"

#: src/idioms/on-stack-dyn-dispatch.md:70
msgid ""
"Rust newcomers will usually learn that Rust requires all variables to be "
"initialized _before use_, so it's easy to overlook the fact that _unused_ "
"variables may well be uninitialized. Rust works quite hard to ensure that "
"this works out fine and only the initialized values are dropped at the end "
"of their scope."
msgstr ""
"Rustの初心者は通常、Rustはすべての変数を _使用前に_ 初期化する必要があること"
"を学びます。そのため、 _未使用_ 変数が初期化されていなくともよいという事実を"
"見落としがちです。Rust は、これが問題なく動作するよう相当な努力を払って保証し"
"ており、スコープの最後には初期化済みの値のみがdropされます。"

#: src/idioms/on-stack-dyn-dispatch.md:76
msgid "The example meets all the constraints Rust places on us:"
msgstr "この例は、Rust が私たちに課しているすべての制約を満たしています:"

#: src/idioms/on-stack-dyn-dispatch.md:78
msgid ""
"All variables are initialized before using (in this case borrowing) them"
msgstr "すべての変数は、使用する（この場合は借用される）前に初期化されます"

#: src/idioms/on-stack-dyn-dispatch.md:79
msgid ""
"Each variable only holds values of a single type. In our example, `stdin` is "
"of type `Stdin`, `file` is of type `File` and `readable` is of type `&mut "
"dyn Read`"
msgstr ""
"各変数は単一の型の値のみを保持します。この例では、 `stdin_read` は `Stdin` "
"型、`file_read` は `File` 型、`readable` は `&mut dyn Read` 型です"

#: src/idioms/on-stack-dyn-dispatch.md:82
msgid "Each borrowed value outlives all the references borrowed from it"
msgstr "借用された各値は、それから借用されたすべての参照よりも長生きします"

#: src/idioms/on-stack-dyn-dispatch.md:86
msgid ""
"[Finalisation in destructors](dtor-finally.md) and [RAII guards](../patterns/"
"behavioural/RAII.md) can benefit from tight control over lifetimes."
msgstr ""
"[デストラクタでのファイナライズ](dtor-finally.md) と[RAIIガード](../patterns/"
"behavioural/RAII.md)は、ライフタイムの厳密な制御から恩恵を得ます。"

#: src/idioms/on-stack-dyn-dispatch.md:89
msgid ""
"For conditionally filled `Option<&T>`s of (mutable) references, one can "
"initialize an `Option<T>` directly and use its [`.as_ref()`](https://doc."
"rust-lang.org/std/option/enum.Option.html#method.as_ref) method to get an "
"optional reference."
msgstr ""
"条件により中身が決まる参照 (可変のもの含む) の `Option<&T>` などに対しては、"
"次のようにします。 `Option<T>` を直接初期化し、その [`.as_ref()`] メソッドを"
"使用することでOptionにくるまれた参照を取得できます。"

#: src/idioms/ffi/intro.md:1
msgid "FFI Idioms"
msgstr "FFIのイディオム"

#: src/idioms/ffi/intro.md:3
msgid ""
"Writing FFI code is an entire course in itself. However, there are several "
"idioms here that can act as pointers, and avoid traps for inexperienced "
"users of `unsafe` Rust."
msgstr ""
"FFIコードを書くことは、それ自体が1つの課程です。しかしながら、ポインタの役割"
"を担い、`unsafe` Rustの経験の浅いユーザーが陥る罠を回避する、いくつかのイディ"
"オムがあります。"

#: src/idioms/ffi/intro.md:7
msgid "This section contains idioms that may be useful when doing FFI."
msgstr "このセクションでは、FFIを行う際に役立つイディオムを紹介します。"

# タイトル名は要見直し。目次見直しの時でもいいが・・・
#: src/idioms/ffi/intro.md:9
msgid ""
"[Idiomatic Errors](./errors.md) - Error handling with integer codes and "
"sentinel return values (such as `NULL` pointers)"
msgstr ""
"[慣習的なエラー](./errors.md) - 整数コードと番人戻り値（`NULL`ポインタなど）"
"によるエラー処理"

#: src/idioms/ffi/intro.md:12
msgid "[Accepting Strings](./accepting-strings.md) with minimal unsafe code"
msgstr "最小の `unsafe` コードでの [文字列の受け入れ](./accepting-strings.md)"

#: src/idioms/ffi/intro.md:14
msgid "[Passing Strings](./passing-strings.md) to FFI functions"
msgstr "FFI関数への[文字列の受け渡し](./passing-strings.md)"

#: src/idioms/ffi/errors.md:1
msgid "Error Handling in FFI"
msgstr "FFI のエラー処理"

#: src/idioms/ffi/errors.md:5
msgid ""
"In foreign languages like C, errors are represented by return codes. "
"However, Rust's type system allows much more rich error information to be "
"captured and propagated through a full type."
msgstr ""
"C言語のような言語では、エラーはリターンコードで表されます。しかしRustの型シス"
"テムは、よりリッチなエラー情報を完全な型を通して捕捉、伝播することが可能で"
"す。"

#: src/idioms/ffi/errors.md:9
msgid ""
"This best practice shows different kinds of error codes, and how to expose "
"them in a usable way:"
msgstr ""
"このベストプラクティスでは、さまざまな種類のエラーコードを示し、どのようにそ"
"れらを扱いやすい方法で公開するかを示します:"

#: src/idioms/ffi/errors.md:12
msgid "Flat Enums should be converted to integers and returned as codes."
msgstr "フラットな列挙型は整数に変換してコードとして返します。"

#: src/idioms/ffi/errors.md:13
msgid ""
"Structured Enums should be converted to an integer code with a string error "
"message for detail."
msgstr ""
"構造化された列挙型は、詳細についての文字列のエラーメッセージとともに、整数"
"コードに変換されるべきです。"

#: src/idioms/ffi/errors.md:15
msgid ""
"Custom Error Types should become \"transparent\", with a C representation."
msgstr ""
"カスタムエラー型は、C言語で表現された、\"透過的 \"なものになるべきです。"

#: src/idioms/ffi/errors.md:17 src/idioms/ffi/accepting-strings.md:29
#: src/idioms/ffi/passing-strings.md:26 src/patterns/ffi/export.md:44
#: src/patterns/ffi/wrappers.md:24
msgid "Code Example"
msgstr "コードの例"

#: src/idioms/ffi/errors.md:19
msgid "Flat Enums"
msgstr "フラットな列挙型"

#: src/idioms/ffi/errors.md:23
msgid "// user attempted a write operation\n"
msgstr "// ユーザーが書き込み操作を試みた\n"

#: src/idioms/ffi/errors.md:24
msgid "// user should read the C errno() for what it was\n"
msgstr "// ユーザーは C の errno() が何であったかを確認すべきである\n"

#: src/idioms/ffi/errors.md:25
msgid "// user should run a repair tool to recover it\n"
msgstr "// ユーザーは修復ツールを実行して回復する必要がある\n"

#: src/idioms/ffi/errors.md:35
msgid "Structured Enums"
msgstr "構造化された列挙型"

#: src/idioms/ffi/errors.md:42
msgid "// message describing the issue\n"
msgstr "// 問題を説明するメッセージ\n"

#: src/idioms/ffi/errors.md:60 src/idioms/ffi/accepting-strings.md:47
#: src/idioms/ffi/accepting-strings.md:79 src/idioms/ffi/passing-strings.md:33
#: src/patterns/ffi/export.md:154 src/patterns/ffi/export.md:158
#: src/patterns/ffi/export.md:165
msgid "\"C\""
msgstr "\"C\""

#: src/idioms/ffi/errors.md:62
msgid "// SAFETY: pointer lifetime is greater than the current stack frame\n"
msgstr "// SAFETY: ポインタの寿命が現在のスタックフレームより大きい\n"

#: src/idioms/ffi/errors.md:68
msgid "\"cannot write to read-only database\""
msgstr "\"cannot write to read-only database\""

#: src/idioms/ffi/errors.md:71
msgid "\"I/O Error: {e}\""
msgstr "\"I/O Error: {e}\""

#: src/idioms/ffi/errors.md:74
msgid "\"File corrupted, run repair: {}\""
msgstr "\"File corrupted, run repair: {}\""

#: src/idioms/ffi/errors.md:79
msgid ""
"// SAFETY: copying error_str to an allocated buffer with a NUL\n"
"            // character at the end\n"
msgstr ""
"// SAFETY: error_strを、アローケートしたバッファに\n"
"            // NUL文字終端を付けてコピーする\n"

#: src/idioms/ffi/errors.md:101
msgid "Custom Error Types"
msgstr "カスタムエラー型"

#: src/idioms/ffi/errors.md:111 src/idioms/ffi/accepting-strings.md:48
#: src/idioms/ffi/accepting-strings.md:83 src/patterns/creational/builder.md:30
#: src/patterns/ffi/export.md:137 src/patterns/ffi/export.md:139
msgid "/* ... */"
msgstr "/* ... */"

#: src/idioms/ffi/errors.md:113
msgid "/* Create a second version which is exposed as a C structure */"
msgstr "/* C構造体として公開される2つめのバージョンを作成する */"

#: src/idioms/ffi/errors.md:132
msgid ""
"This ensures that the foreign language has clear access to error information "
"while not compromising the Rust code's API at all."
msgstr ""
"これにより、RustコードのAPIをまったく損なうことなく、他言語でもエラー情報にア"
"クセスできるようになります。"

#: src/idioms/ffi/errors.md:137
msgid ""
"It's a lot of typing, and some types may not be able to be converted easily "
"to C."
msgstr "タイピングが多くなります。またC言語に簡単に変換できない型もあります。"

#: src/idioms/ffi/accepting-strings.md:5
msgid ""
"When accepting strings via FFI through pointers, there are two principles "
"that should be followed:"
msgstr ""
"FFIから文字列をポインタを通して受け取る場合、次の2つの原則に従う必要がありま"
"す:"

#: src/idioms/ffi/accepting-strings.md:8
msgid "Keep foreign strings \"borrowed\", rather than copying them directly."
msgstr ""
"外部からの文字列を直接コピーするのではなく、「借用」しておいてください。"

#: src/idioms/ffi/accepting-strings.md:9
msgid ""
"Minimize the amount of complexity and `unsafe` code involved in converting "
"from a C-style string to native Rust strings."
msgstr ""
"Cスタイルの文字列から Rust ネイティブの文字列への変換に伴う複雑さと`unsafe` "
"コードの量を最小限にしてください。"

#: src/idioms/ffi/accepting-strings.md:14
msgid ""
"The strings used in C have different behaviours to those used in Rust, "
"namely:"
msgstr ""
"C言語で使用される文字列は、Rustで使用される文字列とは振る舞いが異なります。即"
"ち："

#: src/idioms/ffi/accepting-strings.md:16
msgid "C strings are null-terminated while Rust strings store their length"
msgstr "C言語の文字列はヌル終端であるのに対し、Rustの文字列は長さを保存します"

#: src/idioms/ffi/accepting-strings.md:17
msgid ""
"C strings can contain any arbitrary non-zero byte while Rust strings must be "
"UTF-8"
msgstr ""
"C言語の文字列は0以外の任意のバイトを含むことができますが、Rust の文字列は "
"UTF-8 でなければなりません"

#: src/idioms/ffi/accepting-strings.md:19
msgid ""
"C strings are accessed and manipulated using `unsafe` pointer operations "
"while interactions with Rust strings go through safe methods"
msgstr ""
"C の文字列は `unsafe` ポインタ操作を使ってアクセスおよび操作されます。一方、"
"Rust の文字列とのやり取りは安全なメソッドを使用します"

#: src/idioms/ffi/accepting-strings.md:22
msgid ""
"The Rust standard library comes with C equivalents of Rust's `String` and "
"`&str` called `CString` and `&CStr`, that allow us to avoid a lot of the "
"complexity and `unsafe` code involved in converting between C strings and "
"Rust strings."
msgstr ""
"Rustの標準ライブラリには、Rustの `String` と `&str` に相当するC言語の文字列版"
"が用意されており、 `CString` と `&CStr` と呼びます。これらにより C言語の文字"
"列と Rust の文字列の変換にかかわる複雑さの大部分と `unsafe` なコードを避ける"
"ことができます。"

#: src/idioms/ffi/accepting-strings.md:26
msgid ""
"The `&CStr` type also allows us to work with borrowed data, meaning passing "
"strings between Rust and C is a zero-cost operation."
msgstr ""
"また、 `&CStr` 型は、借用データを扱うことを可能とします。これは Rust とC言語"
"の間での文字列の受け渡しがゼロコストで行えるということです。"

#: src/idioms/ffi/accepting-strings.md:34
#: src/idioms/ffi/accepting-strings.md:77 src/idioms/ffi/passing-strings.md:31
#: src/idioms/ffi/passing-strings.md:80 src/patterns/ffi/wrappers.md:114
msgid "// other module content\n"
msgstr "// モジュールの他のコンテンツ\n"

#: src/idioms/ffi/accepting-strings.md:36
msgid ""
"/// Log a message at the specified level.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// It is the caller's guarantee to ensure `msg`:\n"
"    ///\n"
"    /// - is not a null pointer\n"
"    /// - points to valid, initialized data\n"
"    /// - points to memory ending in a null byte\n"
"    /// - won't be mutated for the duration of this function call\n"
msgstr ""
"/// 指定されたレベルでメッセージをログに記録する。\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// 呼び出し側は `msg` について以下を保証する:\n"
"    ///\n"
"    /// - null ポインタではない\n"
"    /// - 有効で初期化されたデータを指す\n"
"    /// - null バイトで終わるメモリを指す\n"
"    /// - この関数呼び出しの間、変更されない\n"

#: src/idioms/ffi/accepting-strings.md:50
msgid ""
"// SAFETY: The caller has already guaranteed this is okay (see the\n"
"        // `# Safety` section of the doc-comment).\n"
msgstr ""
"// SAFETY: 呼び出し側は、これが問題ないことを既に保証している\n"
"        // (この doc-comment の `# Safety` セクションを参照)。\n"

#: src/idioms/ffi/accepting-strings.md:55
#: src/idioms/ffi/accepting-strings.md:105
msgid "\"FFI string conversion failed\""
msgstr "\"FFI string conversion failed\""

#: src/idioms/ffi/accepting-strings.md:67
msgid "The example is is written to ensure that:"
msgstr "この例は、以下のことを担保するように記述されています:"

#: src/idioms/ffi/accepting-strings.md:69 src/idioms/ffi/passing-strings.md:70
msgid "The `unsafe` block is as small as possible."
msgstr "`unsafe` ブロックは可能な限り小さくします。"

#: src/idioms/ffi/accepting-strings.md:70
msgid ""
"The pointer with an \"untracked\" lifetime becomes a \"tracked\" shared "
"reference"
msgstr "「追跡されない」ライフタイムのポインタを「追跡される」共有参照にします"

#: src/idioms/ffi/accepting-strings.md:72
msgid "Consider an alternative, where the string is actually copied:"
msgstr "別の方法として、文字列を実際にコピーする方法を考えてみましょう:"

#: src/idioms/ffi/accepting-strings.md:80
msgid ""
"// DO NOT USE THIS CODE.\n"
"        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.\n"
msgstr ""
"// このコードは使わないでください。\n"
"        // このコードは醜く、冗長で、微妙なバグを含んでいます。\n"

#: src/idioms/ffi/accepting-strings.md:85
msgid "/* SAFETY: strlen is what it is, I guess? */"
msgstr "/* SAFETY: strlenはその通りのものだ、と思った？ */"

#: src/idioms/ffi/accepting-strings.md:92
msgid ""
"// SAFETY: copying from a foreign pointer expected to live\n"
"            // for the entire stack frame into owned memory\n"
msgstr ""
"// SAFETY: スタックフレーム全体が生きていると\n"
"           // 期待される外部ポインタから、所有メモリへのコピー\n"
"\n"

#: src/idioms/ffi/accepting-strings.md:116
msgid "This code in inferior to the original in two respects:"
msgstr "このコードは2つの点で元のものより劣っています:"

#: src/idioms/ffi/accepting-strings.md:118
msgid ""
"There is much more `unsafe` code, and more importantly, more invariants it "
"must uphold."
msgstr ""
"`unsafe` コードがより多くあり、さらに重要なこととして、維持する必要のある不変"
"性がより多くあります。"

#: src/idioms/ffi/accepting-strings.md:120
msgid ""
"Due to the extensive arithmetic required, there is a bug in this version "
"that cases Rust `undefined behaviour`."
msgstr ""
"追加の計算が必要となったことにより、このバージョンには Rust の `undefined "
"behavior` を引き起こすバグがあります。"

#: src/idioms/ffi/accepting-strings.md:123
msgid ""
"The bug here is a simple mistake in pointer arithmetic: the string was "
"copied, all `msg_len` bytes of it. However, the `NUL` terminator at the end "
"was not."
msgstr ""
"このバグはポインタ演算の単純なミスです: 文字列は `msg_len` バイトすべてをコ"
"ピーされましたが、末尾の `NUL` 終端がコピーされませんでした。"

#: src/idioms/ffi/accepting-strings.md:126
msgid ""
"The Vector then had its size _set_ to the length of the _zero padded string_ "
"-- rather than _resized_ to it, which could have added a zero at the end. As "
"a result, the last byte in the Vector is uninitialized memory. When the "
"`CString` is created at the bottom of the block, its read of the Vector will "
"cause `undefined behaviour`!"
msgstr ""
"ベクタのサイズは、 _ゼロパディングされた文字列_ の長さに _設定_ されています "
"-- 終端に 0 を追加できるよう、 _リサイズ_ されるのではなく。その結果、ベクタ"
"の最後のバイトは未初期化のメモリになります。ブロックの最後にて `CString` を作"
"成する際、このベクタの読み出しが `undefined behaviour` を引き起こします!"

#: src/idioms/ffi/accepting-strings.md:132
msgid ""
"Like many such issues, this would be difficult issue to track down. "
"Sometimes it would panic because the string was not `UTF-8`, sometimes it "
"would put a weird character at the end of the string, sometimes it would "
"just completely crash."
msgstr ""
"このような問題の多くがそうであるように、これは突き止めることが難しい問題とな"
"るでしょう。ときには文字列が `UTF-8` でなかったためにパニックが発生したり、ま"
"たときには文字列の末尾に変な文字が置かれたり、または完全にクラッシュしたりす"
"ることでしょう。"

#: src/idioms/ffi/accepting-strings.md:138
#: src/idioms/ffi/passing-strings.md:103
msgid "None?"
msgstr "なし？"

#: src/idioms/ffi/passing-strings.md:5
msgid ""
"When passing strings to FFI functions, there are four principles that should "
"be followed:"
msgstr "FFI関数に文字列を渡す場合、次の4つの原則に従う必要があります:"

#: src/idioms/ffi/passing-strings.md:8
msgid "Make the lifetime of owned strings as long as possible."
msgstr "所有している文字列のライフタイムを可能な限り長くします。"

#: src/idioms/ffi/passing-strings.md:9
msgid "Minimize `unsafe` code during the conversion."
msgstr "変換の間の `unsafe` コードを最小限に抑えます。"

#: src/idioms/ffi/passing-strings.md:10
msgid ""
"If the C code can modify the string data, use `Vec` instead of `CString`."
msgstr ""
"Cのコードが文字列データを変更し得る場合は、`CString` の代わりに `Vec` を使用"
"します。"

#: src/idioms/ffi/passing-strings.md:11
msgid ""
"Unless the Foreign Function API requires it, the ownership of the string "
"should not transfer to the callee."
msgstr ""
"外部関数APIがそれを要求しない限り、文字列の所有権は呼び出し側に移してはいけま"
"せん。"

#: src/idioms/ffi/passing-strings.md:16
msgid ""
"Rust has built-in support for C-style strings with its `CString` and `CStr` "
"types. However, there are different approaches one can take with strings "
"that are being sent to a foreign function call from a Rust function."
msgstr ""
"Rust は `CString` 型と `CStr` 型により C スタイルの文字列をビルトインでサポー"
"トしています。しかしながら、Rust 関数から外部関数を呼び出す際に受け渡す文字列"
"に関しては、さまざまなアプローチがありえます。"

#: src/idioms/ffi/passing-strings.md:20
msgid ""
"The best practice is simple: use `CString` in such a way as to minimize "
"`unsafe` code. However, a secondary caveat is that _the object must live "
"long enough_, meaning the lifetime should be maximized. In addition, the "
"documentation explains that \"round-tripping\" a `CString` after "
"modification is UB, so additional work is necessary in that case."
msgstr ""
"ベストプラクティスは単純です: `unsafe` コードを最小限にするように `CString` "
"を使うことです。ただし、次いでの注意点があり、それは _オブジェクトは十分に長"
"く生存する必要がある_ ことです。これはライフタイムを最大化すべきという意味で"
"す。加えてドキュメントでは、変更後の `CString` を 「ラウンドトリップ」 するこ"
"とは未定義動作であると説明されており、このようなケースでは追加の対応が必要で"
"す。"

#: src/idioms/ffi/passing-strings.md:42
msgid ""
"// SAFETY: calling an FFI whose documentation says the pointer is\n"
"            // const, so no modification should occur\n"
msgstr ""
"// SAFETY: ポインタがconstであるとドキュメントに記述されているFFIの呼び出"
"し、\n"
"            // すなわち変更されることはない\n"

#: src/idioms/ffi/passing-strings.md:48
msgid "// The lifetime of c_err continues until here\n"
msgstr "// c_err のライフタイムはここまで続く\n"

#: src/idioms/ffi/passing-strings.md:54
msgid ""
"// SAFETY: calling an FFI whose documentation implies\n"
"            // that the input need only live as long as the call\n"
msgstr ""
"// SAFETY: 入力値が呼び出しよりも長く生きる必要があることを\n"
"            // ドキュメントが示唆するFFIの呼び出し\n"

#: src/idioms/ffi/passing-strings.md:68
msgid "The example is written in a way to ensure that:"
msgstr "この例は、以下のことを担保するように記述されています:"

#: src/idioms/ffi/passing-strings.md:71
msgid "The `CString` lives long enough."
msgstr "`CString`は十分に長生きします。"

#: src/idioms/ffi/passing-strings.md:72
msgid "Errors with typecasts are always propagated when possible."
msgstr "型キャストによるエラーは、可能な限り常に伝播されます。"

#: src/idioms/ffi/passing-strings.md:74
msgid ""
"A common mistake (so common it's in the documentation) is to not use the "
"variable in the first block:"
msgstr ""
"よくある間違い（ドキュメントにも載っているほど）は、最初のブロックで変数を使"
"わないことです:"

#: src/idioms/ffi/passing-strings.md:84
msgid "// SAFETY: whoops, this contains a dangling pointer!\n"
msgstr "// SAFETY: おっと、これはダングリングポインタを含んでいる！\n"

#: src/idioms/ffi/passing-strings.md:92
msgid ""
"This code will result in a dangling pointer, because the lifetime of the "
"`CString` is not extended by the pointer creation, unlike if a reference "
"were created."
msgstr ""
"このコードではダングリングポインタが発生します。参照の作成とは異なり、ポイン"
"タの作成によって `CString` の寿命が延長されることはないからです。"

#: src/idioms/ffi/passing-strings.md:96
msgid ""
"Another issue frequently raised is that the initialization of a 1k vector of "
"zeroes is \"slow\". However, recent versions of Rust actually optimize that "
"particular macro to a call to `zmalloc`, meaning it is as fast as the "
"operating system's ability to return zeroed memory (which is quite fast)."
msgstr ""
"もうひとつよく挙げられる問題は、1kのゼロ埋めベクトルの初期化が「遅い」という"
"ことです。しかし、Rustの最近のバージョンでは、この特定のマクロはなんと "
"`zmalloc` の呼び出しに最適化されています。これは、オペレーティングシステムの"
"ゼロ埋めしたメモリを返す機能 (これはかなり高速です) と同じ速さであることを意"
"味します。"

#: src/idioms/option-iter.md:1
msgid "Iterating over an `Option`"
msgstr "`Option` に対する反復処理"

#: src/idioms/option-iter.md:5
msgid ""
"`Option` can be viewed as a container that contains either zero or one "
"element. In particular, it implements the `IntoIterator` trait, and as such "
"can be used with generic code that needs such a type."
msgstr ""
"`Option` は、0個または1個の要素を含むコンテナとみなすことができます。特にこれ"
"は `IntoIterator` トレイトを実装しています。よってそのような型を必要とする"
"ジェネリックなコードにて利用できます。"

#: src/idioms/option-iter.md:9 src/patterns/structural/small-crates.md:34
#: src/patterns/structural/unsafe-mods.md:23
msgid "Examples"
msgstr "例"

#: src/idioms/option-iter.md:11
msgid ""
"Since `Option` implements `IntoIterator`, it can be used as an argument to "
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod."
"extend):"
msgstr ""
"`Option` は `IntoIterator` を実装しているので、[`.extend()`](https://doc."
"rust-lang.org/std/iter/trait.Extend.html#tymethod.extend)の引数として使用でき"
"ます:"

#: src/idioms/option-iter.md:15 src/idioms/option-iter.md:31
msgid "\"Turing\""
msgstr "\"Turing\""

#: src/idioms/option-iter.md:16 src/idioms/option-iter.md:32
msgid "\"Curry\""
msgstr "\"Curry\""

#: src/idioms/option-iter.md:16 src/idioms/option-iter.md:32
msgid "\"Kleene\""
msgstr "\"Kleene\""

#: src/idioms/option-iter.md:16 src/idioms/option-iter.md:32
msgid "\"Markov\""
msgstr "\"Markov\""

#: src/idioms/option-iter.md:19
msgid "// equivalent to\n"
msgstr "// 以下と等しい\n"

#: src/idioms/option-iter.md:26
msgid ""
"If you need to tack an `Option` to the end of an existing iterator, you can "
"pass it to [`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.chain):"
msgstr ""
"既存のイテレータの末尾に `Option` を追加する必要がある場合、 [`.chain()`]"
"(https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain) に渡せ"
"ます:"

#: src/idioms/option-iter.md:35
msgid "\"{logician} is a logician\""
msgstr "\"{logician} is a logician\""

#: src/idioms/option-iter.md:39
msgid ""
"Note that if the `Option` is always `Some`, then it is more idiomatic to use "
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) on the "
"element instead."
msgstr ""
"もし `Option` が常に `Some` である場合は、その要素に対して [`std::iter::"
"once`](https://doc.rust-lang.org/std/iter/fn.once.html) を使用する方がより慣"
"習的であることに注意してください。"

#: src/idioms/option-iter.md:43
msgid ""
"Also, since `Option` implements `IntoIterator`, it's possible to iterate "
"over it using a `for` loop. This is equivalent to matching it with `if let "
"Some(..)`, and in most cases you should prefer the latter."
msgstr ""
"また、`Option` は `IntoIterator` を実装しているので、`for` ループを使って繰り"
"返し処理を行うことができます。これは `if let Some(...)` とマッチさせるのと同"
"じです。ほとんどの場合、後者の方がよいでしょう。"

#: src/idioms/option-iter.md:49
msgid ""
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) is an "
"iterator which yields exactly one element. It's a more readable alternative "
"to `Some(foo).into_iter()`."
msgstr ""
"[std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html)は、厳密に"
"1つの要素を返すイテレータです。Some(foo).into_iter()`に代わる、よりわかりやす"
"いイテレータです。"

#: src/idioms/option-iter.md:53
msgid ""
"[`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.filter_map) is a version of [`Iterator::map`](https://doc.rust-"
"lang.org/std/iter/trait.Iterator.html#method.map), specialized to mapping "
"functions which return `Option`."
msgstr ""
"[`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.filter_map)は[`Iterator::map`](https://doc.rust-lang.org/std/"
"iter/trait.Iterator.html#method.map)のバージョンで、`Option`を返すマッピング"
"関数に特化したものです。"

#: src/idioms/option-iter.md:58
msgid ""
"The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions for converting an `Option` to a zero- or one-element slice."
msgstr ""
"[`ref_slice`](https://crates.io/crates/ref_slice) は `Option` を 0 要素また"
"は 1 要素のスライスに変換する関数を提供します。"

#: src/idioms/option-iter.md:61
msgid ""
"[Documentation for `Option<T>`](https://doc.rust-lang.org/std/option/enum."
"Option.html)"
msgstr ""
"[`Option<T>` に関する文書](https://doc.rust-lang.org/std/option/enum.Option."
"html)"

#: src/idioms/pass-var-to-closure.md:1
#, fuzzy
msgid "Pass variables to closure"
msgstr "変数をクロージャに渡す"

#: src/idioms/pass-var-to-closure.md:5
#, fuzzy
msgid ""
"By default, closures capture their environment by borrowing. Or you can use "
"a `move`\\-closure to move the whole environment. However, often you want to "
"move just some variables to the closure, give it a copy of some data, pass "
"by reference, or perform some other transformation."
msgstr ""
"デフォルトでは、クロージャは借用する形で環境をキャプチャします。\n"
"あるいは環境全体をムーブする `move` クロージャを使うこともできます。\n"
"しかしながら、クロージャへ一部の変数のみを対象に、ムーブさせる／データのコ"
"ピーを与える／参照渡しをする／その他の変換を行う、といったことをしたいことが"
"よくあります。"

#: src/idioms/pass-var-to-closure.md:10
#, fuzzy
msgid "Use variable rebinding in a separate scope for that."
msgstr "そのためには、別のスコープで変数の再バインディングを使用します。"

#: src/idioms/pass-var-to-closure.md:14
msgid "Use"
msgstr "次の例のようにしましょう"

#: src/idioms/pass-var-to-closure.md:23
#, fuzzy
msgid "// `num1` is moved\n"
msgstr "// num1` が移動する\n"

#: src/idioms/pass-var-to-closure.md:24
#, fuzzy
msgid "// `num2` is cloned\n"
msgstr "// num2` がクローンされる\n"

#: src/idioms/pass-var-to-closure.md:25
#, fuzzy
msgid "// `num3` is borrowed\n"
msgstr "// num3` は借り物である。\n"

#: src/idioms/pass-var-to-closure.md:32
msgid "instead of"
msgstr "上の例は下の例と同等の意味となります"

#: src/idioms/pass-var-to-closure.md:50
#, fuzzy
msgid ""
"Copied data are grouped together with the closure definition, so their "
"purpose is more clear, and they will be dropped immediately even if they are "
"not consumed by the closure."
msgstr ""
"コピーされたデータは、クロージャの定義と一緒にグループ化されるため、その目的"
"がより明確になります。\n"
"また、もしそれらがクロージャによって消費されない場合でも、即座に削除されるこ"
"とになります。"

#: src/idioms/pass-var-to-closure.md:54
#, fuzzy
msgid ""
"The closure uses the same variable names as the surrounding code, whether "
"data are copied or moved."
msgstr ""
"クロージャは、データがコピーされようがムーブされようが、周辺のコードと同じ変"
"数名を使用します。"

#: src/idioms/pass-var-to-closure.md:59
#, fuzzy
msgid "Additional indentation of the closure body."
msgstr "クロージャの本体のインデントが増えます。"

#: src/idioms/priv-extend.md:1
#, fuzzy
msgid "`#[non_exhaustive]` and private fields for extensibility"
msgstr "# 拡張性のための `#[non_exhaustive]` と private なフィールド"

#: src/idioms/priv-extend.md:5
#, fuzzy
msgid ""
"A small set of scenarios exist where a library author may want to add public "
"fields to a public struct or new variants to an enum without breaking "
"backwards compatibility."
msgstr ""
"ライブラリの作者が後方互換性を破壊することなく、publicな構造体へpublicな"
"フィールドを追加したり、\n"
"enumへ新しいバリアントを追加したりしたい、といったいくつかのシナリオがありま"
"す。"

#: src/idioms/priv-extend.md:9
msgid "Rust offers two solutions to this problem:"
msgstr "Rust はこの問題に対して2つの解決策を提供します："

#: src/idioms/priv-extend.md:11
#, fuzzy
msgid ""
"Use `#[non_exhaustive]` on `struct`s, `enum`s, and `enum` variants. For "
"extensive documentation on all the places where `#[non_exhaustive]` can be "
"used, see [the docs](https://doc.rust-lang.org/reference/attributes/"
"type_system.html#the-non_exhaustive-attribute)."
msgstr ""
"-  `struct` や `enum` 、 `enum` バリアントに対して `#[non_exhaustive]` を使用"
"する。\n"
"  [`non_exhaustive]`が使用できるすべての場所に関する詳細なドキュメントは "
"[the docs](https://doc.rust-lang.org/reference/attributes/type_system."
"html#the-non_exhaustive-attribute). を参照してください。\n"
"\n"
"- 構造体が直接インスタンス化されたり、マッチングされたりしないようにするため"
"に、\n"
"  構造体に private なフィールドを追加することができます（Alternative 参照）。"

#: src/idioms/priv-extend.md:16
#, fuzzy
msgid ""
"You may add a private field to a struct to prevent it from being directly "
"instantiated or matched against (see Alternative)"
msgstr ""
"構造体に private フィールドを追加して、直接インスタンス化されたりマッチングさ"
"れたりしないようにすることもできます (代替手段を参照)。"

#: src/idioms/priv-extend.md:23
#, fuzzy
msgid "// Public struct.\n"
msgstr "// 公開構造体。\n"

#: src/idioms/priv-extend.md:41
#, fuzzy
msgid ""
"// Because S is `#[non_exhaustive]`, it cannot be named here and\n"
"    // we must use `..` in the pattern.\n"
msgstr ""
"// S は `#[non_exhaustive]` なので、ここで名前を付けることはできない。\n"
"    // パターンの中で `..` を使わなければならない。\n"

#: src/idioms/priv-extend.md:47
#, fuzzy
msgid "\"it's an A\""
msgstr "Aだ"

#: src/idioms/priv-extend.md:48
#, fuzzy
msgid "\"it's a b\""
msgstr "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"

#: src/idioms/priv-extend.md:50
#, fuzzy
msgid "// .. required because this variant is non-exhaustive as well\n"
msgstr "// ... このバリアントも非網羅的であるため必須\n"

#: src/idioms/priv-extend.md:51
#, fuzzy
msgid "\"it's a c\""
msgstr ""
"```rust,ignore\n"
"macro_rules! multiply_add {\n"
"    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) };\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:53
#, fuzzy
msgid ""
"// The wildcard match is required because more variants may be\n"
"        // added in the future\n"
msgstr ""
"// ワイルドカードによるマッチは必須である。\n"
"        // 将来的に追加される可能性があるからです。\n"

#: src/idioms/priv-extend.md:55
#, fuzzy
msgid "\"it's a new variant\""
msgstr "\"新しいバリエーション\""

#: src/idioms/priv-extend.md:60
#, fuzzy
msgid "Alternative: `Private fields` for structs"
msgstr "## Alternative： 構造体の private なフィールド"

#: src/idioms/priv-extend.md:62
#, fuzzy
msgid ""
"`#[non_exhaustive]` only works across crate boundaries. Within a crate, the "
"private field method may be used."
msgstr ""
"`[non_exhaustive]` が機能するのは、crate の境界を越えるときのみです。\n"
"クレート内部では、private なフィールドによる手法を使用できます。"

#: src/idioms/priv-extend.md:65
#, fuzzy
msgid ""
"Adding a field to a struct is a mostly backwards compatible change. However, "
"if a client uses a pattern to deconstruct a struct instance, they might name "
"all the fields in the struct and adding a new one would break that pattern. "
"The client could name some fields and use `..` in the pattern, in which case "
"adding another field is backwards compatible. Making at least one of the "
"struct's fields private forces clients to use the latter form of patterns, "
"ensuring that the struct is future-proof."
msgstr ""
"構造体にフィールドを追加することはだいたいの場合、後方互換性のある変更で"
"す。\n"
"ただし、構造体のクライアントが、パターンを使用して構造体のインスタンスをデコ"
"ンストラクトする際に、構造体内のすべてのフィールドに名前を付けている可能性が"
"あります。この状況で構造体に新しいフィールドを追加することは、そのパターンを"
"壊すことになります。\n"
"クライアントは、パターンの中でいくつかのフィールドに名前を付けるとともに `.."
"` を使うことが可能であり、この場合はフィールドの追加に対して後方互換性があり"
"ます。\n"
"構造体のフィールドの1つ以上を private なものにすることで、クライアントに後者"
"のパターンを使用することを強制することが可能であり、構造体の将来性を確保でき"
"ます。"

#: src/idioms/priv-extend.md:73
#, fuzzy
msgid ""
"The downside of this approach is that you might need to add an otherwise "
"unneeded field to the struct. You can use the `()` type so that there is no "
"runtime overhead and prepend `_` to the field name to avoid the unused field "
"warning."
msgstr ""
"この方法の欠点は、構造体に本来不要なフィールドを追加する必要がある可能性があ"
"ることです。\n"
"`()` 型を使うことでランタイムのオーバーヘッドを回避できます。\n"
"またフィールド名の頭に `_` を付けることで未使用フィールドの警告を回避できま"
"す。"

#: src/idioms/priv-extend.md:81
#, fuzzy
msgid ""
"// Because `b` is private, you cannot match on `S` without using `..` and "
"`S`\n"
"    //  cannot be directly instantiated or matched against\n"
msgstr ""
"```rust\n"
"pub struct S {\n"
"    pub a: i32,\n"
"    // `b` は private です。 `S` に対して `..` を使用せずにパターンマッチする"
"ことは不可能であり、 \n"
"    // `S` を直接インスタンス化したり、マッチ対象としたりすること不可能で"
"す。\n"
"    _b: ()\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:89
#, fuzzy
msgid ""
"On `struct`s, `#[non_exhaustive]` allows adding additional fields in a "
"backwards compatible way. It will also prevent clients from using the struct "
"constructor, even if all the fields are public. This may be helpful, but "
"it's worth considering if you _want_ an additional field to be found by "
"clients as a compiler error rather than something that may be silently "
"undiscovered."
msgstr ""
"`struct` に対しては `#[non_exhaustive]` は、後方互換性のある形でフィールドを"
"追加可能にします。\n"
"また、すべてのフィールドがpublicであっても、クライアントは構造体のコンストラ"
"クタを使用できなくなります。\n"
"これは便利ではあります。しかしながら、フィールドの追加がコンパイルエラーを起"
"こすようにすることで、エラーを見たクライアントがフィールドが追加されたことに"
"気づけるようにする形が (フィールドの追加をクライアントに隠す形よりも) _期待_ "
"されることもあります。"

#: src/idioms/priv-extend.md:95
#, fuzzy
msgid ""
"`#[non_exhaustive]` can be applied to enum variants as well. A "
"`#[non_exhaustive]` variant behaves in the same way as a `#[non_exhaustive]` "
"struct."
msgstr ""
"`#[non_exhaustive]` は列挙型のバリアントにも適用できます。\n"
"`#[non_exhaustive]` なバリアントは、`#[non_exhaustive]` な構造体と同様に振舞"
"います。"

#: src/idioms/priv-extend.md:99
#, fuzzy
msgid ""
"Use this deliberately and with caution: incrementing the major version when "
"adding fields or variants is often a better option. `#[non_exhaustive]` may "
"be appropriate in scenarios where you're modeling an external resource that "
"may change out-of-sync with your library, but is not a general purpose tool."
msgstr ""
"この方法は計画的かつ注意深く使用してください：フィールドやバリアントを追加す"
"るときは、 メジャーバージョンをインクリメントした方が良いことが多いのです。\n"
"`#[non_exhaustive]`は、あなたのライブラリが、ライブラリに同期させることができ"
"ない外部のリソースをモデリングする場合に適切かもしれませんが、汎用目的のツー"
"ルではありません。"

#: src/idioms/priv-extend.md:106
#, fuzzy
msgid ""
"`#[non_exhaustive]` can make your code much less ergonomic to use, "
"especially when forced to handle unknown enum variants. It should only be "
"used when these sorts of evolutions are required **without** incrementing "
"the major version."
msgstr ""
"`#[non_exhaustive]`はコードを人間工学的に使いにくくします。\n"
"特に未知の列挙型の変種を扱わなければならない場合は顕著です。\n"
"この種の開発を、メジャーバージョンをインクリメント **せずに** 行う必要な場合"
"にのみ使うべきです。"

#: src/idioms/priv-extend.md:110
#, fuzzy
msgid ""
"When `#[non_exhaustive]` is applied to `enum`s, it forces clients to handle "
"a wildcard variant. If there is no sensible action to take in this case, "
"this may lead to awkward code and code paths that are only executed in "
"extremely rare circumstances. If a client decides to `panic!()` in this "
"scenario, it may have been better to expose this error at compile time. In "
"fact, `#[non_exhaustive]` forces clients to handle the \"Something else\" "
"case; there is rarely a sensible action to take in this scenario."
msgstr ""
"`enum` に `#[non_exhaustive]` を適用することは、クライアントにワイルドカード"
"の使用を強制します。\n"
"この場合に取るべき賢明なアクションがなければ、厄介なコードや、極めて稀な状況"
"でのみ実行されるコードパスを生み出しかねません。\n"
"クライアントがこのシナリオで `panic!()` を選択するようなら、コンパイル時エ"
"ラーとして公開された方がよかったかもしれません。\n"
"実際、`#[non_exhaustive]`はクライアントに 「その他の何か」 に対するケースを処"
"理するように強制します。そして、このシナリオで取るべき賢明なアクションはまず"
"ありません。"

#: src/idioms/priv-extend.md:120
#, fuzzy
msgid ""
"[RFC introducing #\\[non_exhaustive\\] attribute for enums and structs]"
"(https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"
msgstr ""
"- [`enum` と `struct` に `#[non_exhaustive]` 属性を導入するRFC](https://"
"github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"

#: src/idioms/rustdoc-init.md:5
#, fuzzy
msgid ""
"If a struct takes significant effort to initialize when writing docs, it can "
"be quicker to wrap your example with a helper function which takes the "
"struct as an argument."
msgstr ""
"docコメントを書く際に、構造体を初期化するのに多大な労力がかかる場合は、\n"
"構造体を引数に取るヘルパー関数でコード例をラップした方が手っ取り早いかもしれ"
"ません。"

#: src/idioms/rustdoc-init.md:11
#, fuzzy
msgid ""
"Sometimes there is a struct with multiple or complicated parameters and "
"several methods. Each of these methods should have examples."
msgstr ""
"多数の、または複雑なパラメータや複数のメソッドが、構造体に存在するとしましょ"
"う。\n"
"これらのメソッドにはそれぞれコード例があるはずです。"

#: src/idioms/rustdoc-init.md:14
msgid "For example:"
msgstr "例:"

#: src/idioms/rustdoc-init.md:23
#, fuzzy
msgid ""
"/// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```no_run\n"
"    /// # // Boilerplate are required to get an example working.\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream };\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// ```\n"
msgstr ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信\n"
"    ///\n"
"    /// # Example\n"
"    /// ```no_run\n"
"    /// # // コード例を機能させるにはボイラーテンプレートが必要になります。\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream };\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> {\n"
"        // ...\n"
"    }\n"
"\n"
"    /// なんと、ここでも同じボイラーテンプレートが必要です！\n"
"    fn check_status(&self) -> Status {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:35 src/idioms/rustdoc-init.md:40
#: src/idioms/rustdoc-init.md:68
#, fuzzy
msgid "// ...\n"
msgstr "// ...\n"

#: src/idioms/rustdoc-init.md:38
#, fuzzy
msgid "/// Oh no, all that boilerplate needs to be repeated here!\n"
msgstr "/// いやあ、この定型文はすべてここで繰り返す必要がある！\n"

#: src/idioms/rustdoc-init.md:47
#, fuzzy
msgid ""
"Instead of typing all of this boilerplate to create a `Connection` and "
"`Request`, it is easier to just create a wrapping helper function which "
"takes them as arguments:"
msgstr ""
"このような `Connection` や `Request` を生成するボイラーテンプレートすべてをタ"
"イピングする代わりに、\n"
"それらを引数として受け取るヘルパー関数をラッパーとして作成する方が簡単です："

#: src/idioms/rustdoc-init.md:58
#, fuzzy
msgid ""
"/// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// # }\n"
"    /// ```\n"
msgstr ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信\n"
"    ///\n"
"    /// # Example\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// # }\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:73
#, fuzzy
msgid ""
"**Note** in the above example the line `assert!(response.is_ok());` will not "
"actually run while testing because it is inside a function which is never "
"invoked."
msgstr ""
"**注意** 上記の例における、 `assert!(response.is_ok());` という行は、\n"
"呼び出されない関数内にあるため、実際にはテスト中に実行されません。"

#: src/idioms/rustdoc-init.md:79
msgid "This is much more concise and avoids repetitive code in examples."
msgstr ""
"この方がはるかに簡潔で、コード例中のコードの繰り返しを避けることができます。"

#: src/idioms/rustdoc-init.md:83
#, fuzzy
msgid ""
"As example is in a function, the code will not be tested. Though it will "
"still be checked to make sure it compiles when running a `cargo test`. So "
"this pattern is most useful when you need `no_run`. With this, you do not "
"need to add `no_run`."
msgstr ""
"コード例が関数定義の中にあるので、コードはテストされません。\n"
"しかし `cargo test` を実行することで、コンパイルできたかどうかはチェックされ"
"ます。\n"
"ですから、このパターンは `no_run` が必要なときに便利です。このパターンを使う"
"場合、（実行されないため） `no_run` を追加する必要はありません。"

#: src/idioms/rustdoc-init.md:90
msgid "If assertions are not required this pattern works well."
msgstr "アサーションが必要ない場合は、このパターンがうまく機能します。"

#: src/idioms/rustdoc-init.md:92
#, fuzzy
msgid ""
"If they are, an alternative can be to create a public method to create a "
"helper instance which is annotated with `#[doc(hidden)]` (so that users "
"won't see it). Then this method can be called inside of rustdoc because it "
"is part of the crate's public API."
msgstr ""
"もしアサーションが必要であるなら、別の方法として、ヘルパーインスタンスを作成"
"するpublicメソッドを `#[doc(hidden)]` でアノテーションして作成する方法があり"
"ます。\n"
"これにより、このメソッドはcrateのパブリックAPIの一部として、 rustdoc の内部で"
"呼び出すことが可能になります。"

#: src/idioms/temporary-mutability.md:5
#, fuzzy
msgid ""
"Often it is necessary to prepare and process some data, but after that data "
"are only inspected and never modified. The intention can be made explicit by "
"redefining the mutable variable as immutable."
msgstr ""
"あるデータを準備・処理する必要があり、いったんそれが済めば、データは参照され"
"るだけであり、変更されることはない、という状況がよくあります。\n"
"このような状況では、可変変数を不変変数として再定義することで、その意図を明示"
"することができます。"

#: src/idioms/temporary-mutability.md:9
#, fuzzy
msgid ""
"It can be done either by processing data within a nested block or by "
"redefining the variable."
msgstr ""
"これは、ネストされたブロック内でデータを処理することか、変数を再束縛すること"
"で実現できます。"

#: src/idioms/temporary-mutability.md:14
msgid "Say, vector must be sorted before usage."
msgstr "ベクタが使用される前にソートする必要がある、という状況を考えましょう。"

#: src/idioms/temporary-mutability.md:16
msgid "Using nested block:"
msgstr "ネストされたブロックを使う場合："

#: src/idioms/temporary-mutability.md:24 src/idioms/temporary-mutability.md:34
#, fuzzy
msgid "// Here `data` is immutable.\n"
msgstr "// ここで `data` は不変である。\n"

#: src/idioms/temporary-mutability.md:28
msgid "Using variable rebinding:"
msgstr "変数の再束縛を使う場合："

#: src/idioms/temporary-mutability.md:40
msgid ""
"Compiler ensures that you don't accidentally mutate data after some point."
msgstr ""
"ある時点以降にデータを誤って変更してしまうことを、コンパイラが防ぎます。"

#: src/idioms/temporary-mutability.md:44
#, fuzzy
msgid ""
"Nested block requires additional indentation of block body. One more line to "
"return data from block or redefine variable."
msgstr ""
"ネストされたブロックは、ブロックの本体に追加のインデントが必要になります。\n"
"ブロックからデータを返したり、変数を再定義するに、追加の1行が必要です。"

#: src/idioms/return-consumed-arg-on-error.md:1
#, fuzzy
msgid "Return consumed argument on error"
msgstr "# エラー時に消費した引数を返す"

#: src/idioms/return-consumed-arg-on-error.md:5
#, fuzzy
msgid ""
"If a fallible function consumes (moves) an argument, return that argument "
"back inside an error."
msgstr ""
"失敗する可能性のある関数が引数を消費(move)した場合、その引数をエラーの中に返"
"却しましょう。"

#: src/idioms/return-consumed-arg-on-error.md:12
#, fuzzy
msgid "\"using {value} in a meaningful way\""
msgstr "\"【0】を有意義に使う\""

#: src/idioms/return-consumed-arg-on-error.md:13
#, fuzzy
msgid "// Simulate non-deterministic fallible action.\n"
msgstr "// 非決定論的な誤りやすい行動をシミュレートする。\n"

#: src/idioms/return-consumed-arg-on-error.md:28
#, fuzzy
msgid "\"imagine this is very long string\""
msgstr "\"これはとても長い紐だと想像してください\""

#: src/idioms/return-consumed-arg-on-error.md:31
#, fuzzy
msgid "// Try to send value two times.\n"
msgstr "// 値を2回送信してみる。\n"

#: src/idioms/return-consumed-arg-on-error.md:41
#, fuzzy
msgid "\"success: {success}\""
msgstr "\"成功：{success}\""

#: src/idioms/return-consumed-arg-on-error.md:47
#, fuzzy
msgid ""
"In case of error you may want to try some alternative way or to retry action "
"in case of non-deterministic function. But if the argument is always "
"consumed, you are forced to clone it on every call, which is not very "
"efficient."
msgstr ""
"エラーが発生した際、なにか別の手段を試したり、非決定的な関数であるならリトラ"
"イしたくなるものです。\n"
"しかし、もし引数が常に消費されてしまうのであれば、呼び出しのたびに引数をク"
"ローンしなければならなくなります。\n"
"これではとても効率的とは言えません。"

#: src/idioms/return-consumed-arg-on-error.md:51
#, fuzzy
msgid ""
"The standard library uses this approach in e.g. `String::from_utf8` method. "
"When given a vector that doesn't contain valid UTF-8, a `FromUtf8Error` is "
"returned. You can get original vector back using `FromUtf8Error::into_bytes` "
"method."
msgstr ""
"標準ライブラリでは、このアプローチを `String::from_utf8` メソッドなどで使用し"
"ています。\n"
"有効な UTF-8 を含まないベクタが与えられた場合、 `FromUtf8Error` を返しま"
"す。\n"
" `FromUtf8Error::into_bytes` メソッドを使用することで、元のベクタを取得できま"
"す。"

#: src/idioms/return-consumed-arg-on-error.md:57
msgid "Better performance because of moving arguments whenever possible."
msgstr "可能な限り引数をmoveすることで、パフォーマンスを向上させます。"

#: src/idioms/return-consumed-arg-on-error.md:61
msgid "Slightly more complex error types."
msgstr "エラーの型がやや複雑になります。"

#: src/patterns/index.md:3
#, fuzzy
msgid ""
"[Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) are "
"\"general reusable solutions to a commonly occurring problem within a given "
"context in software design\". Design patterns are a great way to describe "
"the culture of a programming language. Design patterns are very language-"
"specific - what is a pattern in one language may be unnecessary in another "
"due to a language feature, or impossible to express due to a missing feature."
msgstr ""
"[デザインパターン](https://en.wikipedia.org/wiki/Software_design_pattern) と"
"は\n"
"「general reusable solutions to a commonly occurring problem within a given\n"
"context in software design(ソフトウェア設計において、与えられた文脈の中で一般"
"的に発生する問題に対する一般的で再利用可能な解決策)」です。\n"
"デザインパターンはプログラミング言語の文化を表現する素晴らしい方法です。\n"
"デザインパターンはとても言語固有のものです。\n"
"ある言語ではパターンであっても、別の言語ではその言語の特徴によって不要であっ"
"たり、欠けている機能によって表現できなかったりします。"

#: src/patterns/index.md:10
#, fuzzy
msgid ""
"If overused, design patterns can add unnecessary complexity to programs. "
"However, they are a great way to share intermediate and advanced level "
"knowledge about a programming language."
msgstr ""
"デザインパターンは使い過ぎると、プログラムに不必要な複雑さを加えることがあり"
"ます。\n"
"しかし、デザインパターンは、プログラミング言語に関する中級および上級レベルの"
"知識を共有するための素晴らしい方法です。"

#: src/patterns/index.md:16
#, fuzzy
msgid ""
"Rust has many unique features. These features give us great benefit by "
"removing whole classes of problems. Some of them are also patterns that are "
"_unique_ to Rust."
msgstr ""
"Rust には多くのユニークな特徴があります。\n"
"これらの機能は、各種問題の大半を取り除く、大きなメリットをもたらします。その"
"中には、Rust _独自_ のパターンもあります。"

#: src/patterns/index.md:20
#, fuzzy
msgid "YAGNI"
msgstr "## YAGNI"

#: src/patterns/index.md:22
#, fuzzy
msgid ""
"YAGNI is an acronym that stands for `You Aren't Going to Need It`. It's a "
"vital software design principle to apply as you write code."
msgstr ""
"YAGNIとは「You Aren't Going to Need It」の頭文字をとったものです。\n"
"これは、コードを書くときに適用すべき重要なソフトウェア設計の原則です。"

#: src/patterns/index.md:25
#, fuzzy
msgid "The best code I ever wrote was code I never wrote."
msgstr "> これまで書いた中で最高のコードは、書かなかったコードです。"

#: src/patterns/index.md:27
#, fuzzy
msgid ""
"If we apply YAGNI to design patterns, we see that the features of Rust allow "
"us to throw out many patterns. For instance, there is no need for the "
"[strategy pattern](https://en.wikipedia.org/wiki/Strategy_pattern) in Rust "
"because we can just use [traits](https://doc.rust-lang.org/book/traits.html)."
msgstr ""
"YAGNIをデザインパターンに適用すると、Rustの機能によって多くのパターンを捨てる"
"ことができることがわかります。\n"
"例えば、Rustでは [strategyパターン](https://en.wikipedia.org/wiki/"
"Strategy_pattern) は不要です。\n"
"なぜなら、単に [trait](https://doc.rust-lang.org/book/traits.html) を使えば良"
"いためです。"

#: src/patterns/behavioural/intro.md:1
#, fuzzy
msgid "Behavioural Patterns"
msgstr "# 振る舞いに関するパターン"

#: src/patterns/behavioural/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern) より："

#: src/patterns/behavioural/intro.md:5
#, fuzzy
msgid ""
"Design patterns that identify common communication patterns among objects. "
"By doing so, these patterns increase flexibility in carrying out "
"communication."
msgstr ""
"> Design patterns that identify common communication patterns among "
"objects.\n"
"> By doing so, these patterns increase flexibility in carrying out "
"communication.\n"
"> (オブジェクト間で共通するコミュニケーションのパターンを特定するデザインパ"
"ターン。\n"
"> これらのパターンの実践により、コミュニケーションを実行する際の柔軟性が高ま"
"ります。)"

#: src/patterns/behavioural/command.md:5
#, fuzzy
msgid ""
"The basic idea of the Command pattern is to separate out actions into its "
"own objects and pass them as parameters."
msgstr ""
"Commandパターンの基本的な考え方は、アクションを独自のオブジェクトに分離し、\n"
"それらをパラメータとして渡すことです。"

#: src/patterns/behavioural/command.md:10
#, fuzzy
msgid ""
"Suppose we have a sequence of actions or transactions encapsulated as "
"objects. We want these actions or commands to be executed or invoked in some "
"order later at different time. These commands may also be triggered as a "
"result of some event. For example, when a user pushes a button, or on "
"arrival of a data packet. In addition, these commands might be undoable. "
"This may come in useful for operations of an editor. We might want to store "
"logs of executed commands so that we could reapply the changes later if the "
"system crashes."
msgstr ""
"オブジェクトとしてカプセル化された一連のアクションやトランザクションがあると"
"します。\n"
"これらのアクションやコマンドを、ある順序で、別の時間に実行したり呼び出したり"
"したいとします。\n"
"これらのコマンドは、何らかのイベントの結果としてトリガーされることもあるで"
"しょう。\n"
"例えば、ユーザーがボタンを押した時や、データパケットが到着した時などのよう"
"に。\n"
"また他に、これらのコマンドはアンドゥ可能であるかもしれません。これはエディ"
"ターの操作などに役立つでしょう。\n"
"また実行したコマンドのログを保存しておき、後でシステムがクラッシュしたときに"
"その変更を再適用できるようにしておきたいこともあるでしょう。"

#: src/patterns/behavioural/command.md:20
#, fuzzy
msgid ""
"Define two database operations `create table` and `add field`. Each of these "
"operations is a command which knows how to undo the command, e.g., `drop "
"table` and `remove field`. When a user invokes a database migration "
"operation then each command is executed in the defined order, and when the "
"user invokes the rollback operation then the whole set of commands is "
"invoked in reverse order."
msgstr ""
"`create table` と `add field` の2つのデータベース操作を定義します。これらの操"
"作はそれぞれ\n"
"これらの操作はそれぞれ、そのコマンドをアンドゥする方法(例えば `drop table` "
"と `remove field` )が分かっているコマンドです。\n"
"ユーザがデータベースの移行操作を実行すると、各コマンドが定義された順序で実行"
"され、\n"
"またロールバック操作を実行すると、コマンド一式が逆の順序で実行されます。"

#: src/patterns/behavioural/command.md:26
#, fuzzy
msgid "Approach: Using trait objects"
msgstr "## アプローチ：トレイトオブジェクトの使用"

#: src/patterns/behavioural/command.md:28
#, fuzzy
msgid ""
"We define a common trait which encapsulates our command with two operations "
"`execute` and `rollback`. All command `structs` must implement this trait."
msgstr ""
"`execute` と `rollback` の2つの操作を持つコマンドをカプセル化する共通のトレイ"
"トを定義します。\n"
"すべてのコマンドの `struct` はこのトレイトを実装しなければなりません。"

#: src/patterns/behavioural/command.md:40
#: src/patterns/behavioural/command.md:90
#: src/patterns/behavioural/command.md:143
#: src/patterns/behavioural/command.md:145
#: src/patterns/behavioural/command.md:196
#: src/patterns/behavioural/command.md:198
#, fuzzy
msgid "\"create table\""
msgstr ""
"`create table` と `add field` の2つのデータベース操作を定義します。これらの操"
"作はそれぞれ\n"
"これらの操作はそれぞれ、そのコマンドをアンドゥする方法(例えば `drop table` "
"と `remove field` )が分かっているコマンドです。\n"
"ユーザがデータベースの移行操作を実行すると、各コマンドが定義された順序で実行"
"され、\n"
"またロールバック操作を実行すると、コマンド一式が逆の順序で実行されます。"

#: src/patterns/behavioural/command.md:43
#: src/patterns/behavioural/command.md:91
#: src/patterns/behavioural/command.md:143
#: src/patterns/behavioural/command.md:146
#: src/patterns/behavioural/command.md:196
#: src/patterns/behavioural/command.md:199
#, fuzzy
msgid "\"drop table\""
msgstr ""
"`create table` と `add field` の2つのデータベース操作を定義します。これらの操"
"作はそれぞれ\n"
"これらの操作はそれぞれ、そのコマンドをアンドゥする方法(例えば `drop table` "
"と `remove field` )が分かっているコマンドです。\n"
"ユーザがデータベースの移行操作を実行すると、各コマンドが定義された順序で実行"
"され、\n"
"またロールバック操作を実行すると、コマンド一式が逆の順序で実行されます。"

#: src/patterns/behavioural/command.md:50
#: src/patterns/behavioural/command.md:90
#: src/patterns/behavioural/command.md:134
#: src/patterns/behavioural/command.md:145
#: src/patterns/behavioural/command.md:187
#: src/patterns/behavioural/command.md:198
#, fuzzy
msgid "\"add field\""
msgstr ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:53
#: src/patterns/behavioural/command.md:91
#: src/patterns/behavioural/command.md:138
#: src/patterns/behavioural/command.md:146
#: src/patterns/behavioural/command.md:191
#: src/patterns/behavioural/command.md:199
#, fuzzy
msgid "\"remove field\""
msgstr ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:76
#, fuzzy
msgid "// reverse iterator's direction\n"
msgstr "// イテレータの方向を逆にする\n"

#: src/patterns/behavioural/command.md:95
#, fuzzy
msgid "Approach: Using function pointers"
msgstr "## アプローチ：関数ポインタの使用"

#: src/patterns/behavioural/command.md:97
#, fuzzy
msgid ""
"We could follow another approach by creating each individual command as a "
"different function and store function pointers to invoke these functions "
"later at a different time. Since function pointers implement all three "
"traits `Fn`, `FnMut`, and `FnOnce` we could as well pass and store closures "
"instead of function pointers."
msgstr ""
"他のアプローチとして、個々のコマンドを別個の関数として作成し、関数ポインタを"
"格納、後でこれらの関数を別の時間に呼び出す方法があります。\n"
"関数ポインタは `Fn` 、 `FnMut` 、 `FnOnce` の3つのトレイトを実装しているの"
"で、関数ポインタの代わりにクロージャを渡して格納することもできます。"

#: src/patterns/behavioural/command.md:150
#, fuzzy
msgid "Approach: Using `Fn` trait objects"
msgstr "## アプローチ： `Fn` トレイトオブジェクトの使用"

#: src/patterns/behavioural/command.md:152
#, fuzzy
msgid ""
"Finally, instead of defining a common command trait we could store each "
"command implementing the `Fn` trait separately in vectors."
msgstr ""
"最後に、共通のコマンドのトレイトを定義する代わりに、個々に `Fn` トレイトを実"
"装した各コマンドをベクタに格納することができます。"

#: src/patterns/behavioural/command.md:205
#, fuzzy
msgid ""
"If our commands are small and may be defined as functions or passed as a "
"closure then using function pointers might be preferable since it does not "
"exploit dynamic dispatch. But if our command is a whole struct with a bunch "
"of functions and variables defined as separated module then using trait "
"objects would be more suitable. A case of application can be found in "
"[`actix`](https://actix.rs/), which uses trait objects when it registers a "
"handler function for routes. In case of using `Fn` trait objects we can "
"create and use commands in the same way as we used in case of function "
"pointers."
msgstr ""
"コマンドが小さく、関数として定義されたり、クロージャとして渡されたりするので"
"あれば、関数ポインタを使うのが望ましいでしょう。\n"
"動的ディスパッチを濫用せずに済みます。\n"
"しかし、コマンドが、別のモジュールに定義されている関数や変数の多い構造体全体"
"である場合は、 トレイトオブジェクトを使用するのが望ましいでしょう。\n"
"その応用例が [`actix`](https://actix.rs/) です。これは、ルート用のハンドラ関"
"数を登録するときにトレイトオブジェクトを使用しています。\n"
"`Fn` トレイトオブジェクトを使用する場合、関数ポインタを使用するの場合と同じよ"
"うにコマンドを作成して使用することができます。"

#: src/patterns/behavioural/command.md:214
#, fuzzy
msgid ""
"As performance, there is always a trade-off between performance and code "
"simplicity and organisation. Static dispatch gives faster performance, while "
"dynamic dispatch provides flexibility when we structure our application."
msgstr ""
"パフォーマンスとコードのシンプルさと秩序の間には常にトレードオフがありま"
"す。\n"
"静的ディスパッチはより高速なパフォーマンスをもたらしますが、\n"
"動的ディスパッチはアプリケーションを構成する際に柔軟性をもたらします。"

#: src/patterns/behavioural/command.md:220
#, fuzzy
msgid "[Command pattern](https://en.wikipedia.org/wiki/Command_pattern)"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/patterns/behavioural/command.md:222
#, fuzzy
msgid ""
"[Another example for the `command` pattern](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"
msgstr ""
"- [Command pattern](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [`command` パターンのもう一つの例](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"

#: src/patterns/behavioural/interpreter.md:5
#, fuzzy
msgid ""
"If a problem occurs very often and requires long and repetitive steps to "
"solve it, then the problem instances might be expressed in a simple language "
"and an interpreter object could solve it by interpreting the sentences "
"written in this simple language."
msgstr ""
"ある問題が非常に頻繁に発生し、その解決に長く反復的な手順を必要とする場合、\n"
"その問題のインスタンスは単純な言語で表現可能であり、インタープリタ・オブジェ"
"クトがこの言語による記述を解釈するという形で解決可能であるかもしれません。"

#: src/patterns/behavioural/interpreter.md:10
msgid "Basically, for any kind of problems we define:"
msgstr "基本的に、あらゆる種類の問題に対して、以下定義します："

#: src/patterns/behavioural/interpreter.md:12
#, fuzzy
msgid ""
"A [domain specific language](https://en.wikipedia.org/wiki/Domain-"
"specific_language),"
msgstr ""
"- [ドメイン固有言語](https://en.wikipedia.org/wiki/Domain-"
"specific_language)、\n"
"- この言語のための文法、\n"
"- 問題インスタンスを解決するインタプリタ。"

#: src/patterns/behavioural/interpreter.md:14
#, fuzzy
msgid "A grammar for this language,"
msgstr "この言語の文法、"

#: src/patterns/behavioural/interpreter.md:15
#, fuzzy
msgid "An interpreter that solves the problem instances."
msgstr "問題インスタンスを解決するインタープリター。"

#: src/patterns/behavioural/interpreter.md:19
#, fuzzy
msgid ""
"Our goal is to translate simple mathematical expressions into postfix "
"expressions (or [Reverse Polish notation](https://en.wikipedia.org/wiki/"
"Reverse_Polish_notation)) For simplicity, our expressions consist of ten "
"digits `0`, ..., `9` and two operations `+`, `-`. For example, the "
"expression `2 + 4` is translated into `2 4 +`."
msgstr ""
"私たちの目標は、簡単な数式を後置記法([逆ポーランド記法](https://en.wikipedia."
"org/wiki/Reverse_Polish_notation)ともに変換することです。\n"
"簡略にするため、式は10桁の数字 `0`, ..., `9` と2つの演算 `+`, `-` で構成され"
"るとします。\n"
"例えば `2 + 4` という式は `2 4 +` に変換されます。"

#: src/patterns/behavioural/interpreter.md:26
#, fuzzy
msgid "Context Free Grammar for our problem"
msgstr "## 私たちの問題に対する文脈自由文法"

#: src/patterns/behavioural/interpreter.md:28
#, fuzzy
msgid ""
"Our task is translating infix expressions into postfix ones. Let's define a "
"context free grammar for a set of infix expressions over `0`, ..., `9`, `+`, "
"and `-`, where:"
msgstr ""
"私たちのタスクは中置記法を後置記法に変換することです。\n"
"`0`, ..., `9`, `+`, `-` に対応する中置記法の式の集合に対して文脈自由文法を以"
"下に定義します："

#: src/patterns/behavioural/interpreter.md:32
#, fuzzy
msgid "Terminal symbols: `0`, `...`, `9`, `+`, `-`"
msgstr "終端記号：`0`, `...`, `9`, `+`, `-`"

#: src/patterns/behavioural/interpreter.md:33
#, fuzzy
msgid "Non-terminal symbols: `exp`, `term`"
msgstr "非終端記号：exp`、`term`。"

#: src/patterns/behavioural/interpreter.md:34
#, fuzzy
msgid "Start symbol is `exp`"
msgstr "開始記号は `exp` である。"

#: src/patterns/behavioural/interpreter.md:35
#, fuzzy
msgid "And the following are production rules"
msgstr "そして、以下はプロダクション・ルールである。"

#: src/patterns/behavioural/interpreter.md:44
#, fuzzy
msgid ""
"**NOTE:** This grammar should be further transformed depending on what we "
"are going to do with it. For example, we might need to remove left "
"recursion. For more details please see [Compilers: Principles,Techniques, "
"and Tools](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,"
"_and_Tools) (aka Dragon Book)."
msgstr ""
"**注：** この文法は、これによって私たちが何をしようとしているかによって、さら"
"に変形されるべきです。\n"
"例えば、左再帰を削除する必要があるかもしれません。詳しくは[Compilers: "
"Principles,Techniques, and Tools](https://en.wikipedia.org/wiki/Compilers:"
"_Principles,_Techniques,_and_Tools) (別名 Dragon Book)を参照してください。"

#: src/patterns/behavioural/interpreter.md:50
msgid "Solution"
msgstr "解決方法"

#: src/patterns/behavioural/interpreter.md:52
#, fuzzy
msgid ""
"We simply implement a recursive descent parser. For simplicity's sake, the "
"code panics when an expression is syntactically wrong (for example `2-34` or "
"`2+5-` are wrong according to the grammar definition)."
msgstr ""
"再帰降下パーサを実装するだけです。\n"
"簡略にするために、構文的に誤った式があればコードはパニックします(例えば、 "
"`2-34` や `2+5-` は文法定義に照らすと誤りです)。"

#: src/patterns/behavioural/interpreter.md:74
#, fuzzy
msgid "'+'"
msgstr "'+'"

#: src/patterns/behavioural/interpreter.md:74
#, fuzzy
msgid "'-'"
msgstr "'-'"

#: src/patterns/behavioural/interpreter.md:78
#, fuzzy
msgid "\"Unexpected symbol '{op}'\""
msgstr "「予期せぬ記号 '{op}'\""

#: src/patterns/behavioural/interpreter.md:86
#, fuzzy
msgid "\"Unexpected symbol '{ch}'\""
msgstr "「予期せぬ記号 '{ch}'\""

#: src/patterns/behavioural/interpreter.md:87
#, fuzzy
msgid "\"Unexpected end of string\""
msgstr "「予期せぬ文字列の終わり"

#: src/patterns/behavioural/interpreter.md:93
#, fuzzy
msgid "\"2+3\""
msgstr ""
"```rust\n"
"macro_rules! patterns {\n"
"    ($( $( $pat:pat_param )|+ )*) => ();\n"
"}\n"
"\n"
"patterns! {\n"
"    \"literal\"\n"
"    _\n"
"    0..5\n"
"    ref mut PatternsAreNice\n"
"    0 | 1 | 2 | 3\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/patterns/behavioural/interpreter.md:96
#, fuzzy
msgid "\"23+\""
msgstr "\"23+\""

#: src/patterns/behavioural/interpreter.md:98
#, fuzzy
msgid "\"1-2+3-4\""
msgstr "\"1-2+3-4\""

#: src/patterns/behavioural/interpreter.md:101
#, fuzzy
msgid "\"12-3+4-\""
msgstr "\"12-3+4-\""

#: src/patterns/behavioural/interpreter.md:107
#, fuzzy
msgid ""
"There may be a wrong perception that the Interpreter design pattern is about "
"design grammars for formal languages and implementation of parsers for these "
"grammars. In fact, this pattern is about expressing problem instances in a "
"more specific way and implementing functions/classes/structs that solve "
"these problem instances. Rust language has `macro_rules!` that allow us to "
"define special syntax and rules on how to expand this syntax into source "
"code."
msgstr ""
"Interpreter デザインパターンに対して「形式言語の文法を設計し、その文法に対応"
"したパーサの実装することである」という誤った認識があるかもしれません。\n"
"実際には、このパターンは問題インスタンスをより具体的に表現し、その問題インス"
"タンスを解決する関数/クラス/構造を実装するというものです。\n"
"Rust には `macro_rules!` があり、これにより特別な構文と、この構文をソースコー"
"ドへ展開するためのルールを定義することができます。"

#: src/patterns/behavioural/interpreter.md:114
#, fuzzy
msgid ""
"In the following example we create a simple `macro_rules!` that computes "
"[Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) of `n` "
"dimensional vectors. Writing `norm!(x,1,2)` might be easier to express and "
"more efficient than packing `x,1,2` into a `Vec` and calling a function "
"computing the length."
msgstr ""
"次の例では、 `n` 次元ベクタの[ユークリッド距離](https://en.wikipedia.org/"
"wiki/Euclidean_distance) を計算する、単純な `macro_rules!` を作成します。\n"
"`norm!(x,1,2)` と記述するのは、 `x,1,2` を `Vec` に詰め込んで、距離を計算する"
"関数を呼び出すよりも表現が簡単で効率的です。"

#: src/patterns/behavioural/interpreter.md:146
#, fuzzy
msgid ""
"[Interpreter pattern](https://en.wikipedia.org/wiki/Interpreter_pattern)"
msgstr "[ウィキペディア記事](https://en.wikipedia.org/wiki/Visitor_pattern)"

#: src/patterns/behavioural/interpreter.md:147
#, fuzzy
msgid ""
"[Context free grammar](https://en.wikipedia.org/wiki/Context-free_grammar)"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/patterns/behavioural/interpreter.md:148
#, fuzzy
msgid "[macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"
msgstr ""
"[マクロ_ルール！](https://doc.rust-lang.org/rust-by-example/macros.html)"

#: src/patterns/behavioural/newtype.md:3
#, fuzzy
msgid ""
"What if in some cases we want a type to behave similar to another type or "
"enforce some behaviour at compile time when using only type aliases would "
"not be enough?"
msgstr ""
"ある型に別の型と似たような振る舞いをさせたり、コンパイル時にある振る舞いを強"
"制させたりしたいが、\n"
"型エイリアスだけでは不十分な場合どのようにすればよいでしょうか？"

#: src/patterns/behavioural/newtype.md:7
#, fuzzy
msgid ""
"For example, if we want to create a custom `Display` implementation for "
"`String` due to security considerations (e.g. passwords)."
msgstr ""
"例えば、セキュリティを考慮(パスワード等)して、`String` に対しカスタムした "
"`Display` の実装を作成したい場合があります。"

#: src/patterns/behavioural/newtype.md:10
#, fuzzy
msgid ""
"For such cases we could use the `Newtype` pattern to provide **type safety** "
"and **encapsulation**."
msgstr ""
"このような場合、 `Newtype` パターンを使うことで、 **型の安全性** と **カプセ"
"ル化** を提供できます。"

#: src/patterns/behavioural/newtype.md:15
#, fuzzy
msgid ""
"Use a tuple struct with a single field to make an opaque wrapper for a type. "
"This creates a new type, rather than an alias to a type (`type` items)."
msgstr ""
"単一のフィールドを持つタプル構造体を使用して、型の不透明なラッパーを作成しま"
"す。\n"
"これは、型のエイリアス (`type` によるもの) ではなく、新しい型を作成します。"

#: src/patterns/behavioural/newtype.md:22
#, fuzzy
msgid "// Create Newtype Password to override the Display trait for String\n"
msgstr ""
"// 文字列の Display 特性をオーバーライドする Newtype Password を作成する。\n"

#: src/patterns/behavioural/newtype.md:28
#, fuzzy
msgid "\"****************\""
msgstr "\"****************\""

#: src/patterns/behavioural/newtype.md:33
#, fuzzy
msgid "\"ThisIsMyPassword\""
msgstr "\"ThisIsMyPassword\""

#: src/patterns/behavioural/newtype.md:35
#, fuzzy
msgid "\"unsecured_password: {unsecured_password}\""
msgstr "\"unsecured_password: {unsecured_password}\""

#: src/patterns/behavioural/newtype.md:36
#, fuzzy
msgid "\"secured_password: {secured_password}\""
msgstr "\"secured_password: {secured_password}\""

#: src/patterns/behavioural/newtype.md:47
#, fuzzy
msgid ""
"The primary motivation for newtypes is abstraction. It allows you to share "
"implementation details between types while precisely controlling the "
"interface. By using a newtype rather than exposing the implementation type "
"as part of an API, it allows you to change implementation backwards "
"compatibly."
msgstr ""
"ニュータイプの主な動機は抽象化です。これによってインタフェースを正確に制御し"
"ながら、型間で実装の詳細を共有することができます。\n"
"実装型をAPIの一部としてさらけ出すのではなく、 newtype を使うことで、後方互換"
"性を保ったまま実装を変更することができます。"

#: src/patterns/behavioural/newtype.md:52
#, fuzzy
msgid ""
"Newtypes can be used for distinguishing units, e.g., wrapping `f64` to give "
"distinguishable `Miles` and `Kilometres`."
msgstr ""
"newtype は単位を区別するために使用できます。\n"
"例えば `f64` をラップすることで、`Miles` と `Kilometers` を区別します。"

#: src/patterns/behavioural/newtype.md:57
#, fuzzy
msgid ""
"The wrapped and wrapper types are not type compatible (as opposed to using "
"`type`), so users of the newtype will never 'confuse' the wrapped and "
"wrapper types."
msgstr ""
"ラップ対象の型とラップする側の型の間には、(`type` を使うのとは対照的に)型互換"
"性はありません。\n"
"そのため、 newtype のユーザがこれらの型を「混同」することはありません。"

#: src/patterns/behavioural/newtype.md:61
msgid "Newtypes are a zero-cost abstraction - there is no runtime overhead."
msgstr "newtype はゼロコスト抽象化です。実行時のオーバーヘッドはありません。"

#: src/patterns/behavioural/newtype.md:63
#, fuzzy
msgid ""
"The privacy system ensures that users cannot access the wrapped type (if the "
"field is private, which it is by default)."
msgstr ""
"プライバシーシステムは、 ユーザがラップされた型にアクセスできないことを保証し"
"ます(フィールドがprivateである場合。既定では private)。"

#: src/patterns/behavioural/newtype.md:68
#, fuzzy
msgid ""
"The downside of newtypes (especially compared with type aliases), is that "
"there is no special language support. This means there can be _a lot_ of "
"boilerplate. You need a 'pass through' method for every method you want to "
"expose on the wrapped type, and an impl for every trait you want to also be "
"implemented for the wrapper type."
msgstr ""
"newtype の欠点は（特に型のエイリアスと比べて）、特別な言語サポートがないこと"
"です。\n"
"特別な言語サポートがないことです。つまり、 _多くのボイラーテンプレート_ が必"
"要になります。\n"
"ラップされた型にて公開したいメソッドには「パススルー」メソッドが必要です。ま"
"たラップされた型に実装したいトレイトについても同様です。"

#: src/patterns/behavioural/newtype.md:76
#, fuzzy
msgid ""
"Newtypes are very common in Rust code. Abstraction or representing units are "
"the most common uses, but they can be used for other reasons:"
msgstr ""
"Rustのコードでは、newtype がよく使われます。\n"
"抽象化や単位の表現が最も一般的な使用法ですが、その他の理由でも使用できます："

#: src/patterns/behavioural/newtype.md:79
#, fuzzy
msgid ""
"restricting functionality (reduce the functions exposed or traits "
"implemented),"
msgstr "機能を制限する（公開される関数や実装される特性を減らす）、"

#: src/patterns/behavioural/newtype.md:81
#, fuzzy
msgid "making a type with copy semantics have move semantics,"
msgstr "コピー・セマンティクスを持つ型にムーブ・セマンティクスを持たせる、"

#: src/patterns/behavioural/newtype.md:82
#, fuzzy
msgid ""
"abstraction by providing a more concrete type and thus hiding internal "
"types, e.g.,"
msgstr "より具象的な型を提供することで抽象化し、内部型を隠蔽する、"

#: src/patterns/behavioural/newtype.md:89
#, fuzzy
msgid ""
"Here, `Bar` might be some public, generic type and `T1` and `T2` are some "
"internal types. Users of our module shouldn't know that we implement `Foo` "
"by using a `Bar`, but what we're really hiding here is the types `T1` and "
"`T2`, and how they are used with `Bar`."
msgstr ""
"ここで、`Bar` は public な汎用型であり、`T1` と `T2` は内部型です。\n"
"このモジュールのユーザは `Bar` を使って `Foo` を実装していることを知るべきで"
"はないはずです。\n"
"しかし、ここで本当に隠しているのは `T1` と `T2` という型であり、それらが "
"`Bar` でどのように使われているかということです。"

#: src/patterns/behavioural/newtype.md:96
#, fuzzy
msgid ""
"[Advanced Types in the book](https://doc.rust-lang.org/book/ch19-04-advanced-"
"types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-"
"abstraction)"
msgstr ""
"[本の中の上級タイプ](https://doc.rust-lang.org/book/ch19-04-advanced-types."
"html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-"
"abstraction)"

#: src/patterns/behavioural/newtype.md:97
#, fuzzy
msgid "[Newtypes in Haskell](https://wiki.haskell.org/Newtype)"
msgstr "[ハスケルの新型](https://wiki.haskell.org/Newtype)"

#: src/patterns/behavioural/newtype.md:98
#, fuzzy
msgid ""
"[Type aliases](https://doc.rust-lang.org/stable/book/ch19-04-advanced-types."
"html#creating-type-synonyms-with-type-aliases)"
msgstr ""
"[タイプ別エイリアス](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
"types.html#creating-type-synonyms-with-type-aliases)"

#: src/patterns/behavioural/newtype.md:99
#, fuzzy
msgid ""
"[derive_more](https://crates.io/crates/derive_more), a crate for deriving "
"many builtin traits on newtypes."
msgstr ""
"[derive_more](https://crates.io/crates/derive_more)は、newtypesに多くの組み込"
"み特性を派生させるためのクレートです。"

#: src/patterns/behavioural/newtype.md:101
#, fuzzy
msgid ""
"[The Newtype Pattern In Rust](https://web.archive.org/web/20230519162111/"
"https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"
msgstr ""
"[RustのNewtypeパターン](https://web.archive.org/web/20230519162111/https://"
"www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"

#: src/patterns/behavioural/RAII.md:1
#, fuzzy
msgid "RAII with guards"
msgstr "# ガード付きRAII"

#: src/patterns/behavioural/RAII.md:5
#, fuzzy
msgid ""
"[RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) "
"stands for \"Resource Acquisition is Initialisation\" which is a terrible "
"name. The essence of the pattern is that resource initialisation is done in "
"the constructor of an object and finalisation in the destructor. This "
"pattern is extended in Rust by using a RAII object as a guard of some "
"resource and relying on the type system to ensure that access is always "
"mediated by the guard object."
msgstr ""
"[RAII][wikipedia]は「Resource Acquisition is Initialisation」の略です。・・・"
"ひどい名前です。\n"
"このパターンの本質は、リソースの初期化をオブジェクトのコンストラクタで行い、"
"ファイナライズをデストラクタで行うというものです。\n"
"RAIIオブジェクトをリソースのガードとして使い、またアクセスが常にガードオブ"
"ジェクトを介することを保証するために型システムに依存することで、Rustではこの"
"パターンが拡張されます。"

#: src/patterns/behavioural/RAII.md:14
#, fuzzy
msgid ""
"Mutex guards are the classic example of this pattern from the std library "
"(this is a simplified version of the real implementation):"
msgstr ""
"ミューテックスのガードは、stdライブラリにあるこのパターンの典型的な例です（こ"
"れは実際の実装を簡略化したものです）："

#: src/patterns/behavioural/RAII.md:23
#, fuzzy
msgid ""
"// We keep a reference to our data: T here.\n"
"    //..\n"
msgstr ""
"// データへの参照を保持する：Tはここにある。\n"
"    //..\n"

#: src/patterns/behavioural/RAII.md:31
#, fuzzy
msgid "// Locking the mutex is explicit.\n"
msgstr "// ミューテックスのロックは明示的に行う。\n"

#: src/patterns/behavioural/RAII.md:35
#, fuzzy
msgid ""
"// Lock the underlying OS mutex.\n"
"        //..\n"
msgstr ""
"// OSのミューテックスをロックする。\n"
"        //..\n"

#: src/patterns/behavioural/RAII.md:38
#, fuzzy
msgid "// MutexGuard keeps a reference to self\n"
msgstr "// MutexGuardはselfへの参照を保持する。\n"

#: src/patterns/behavioural/RAII.md:45
#, fuzzy
msgid "// Destructor for unlocking the mutex.\n"
msgstr "// ミューテックスのロックを解除するためのデストラクタ。\n"

#: src/patterns/behavioural/RAII.md:49
#, fuzzy
msgid ""
"// Unlock the underlying OS mutex.\n"
"        //..\n"
msgstr ""
"// OSのミューテックスのロックを解除する。\n"
"        //..\n"

#: src/patterns/behavioural/RAII.md:53
#, fuzzy
msgid ""
"// Implementing Deref means we can treat MutexGuard like a pointer to T.\n"
msgstr ""
"// Derefを実装するということは、MutexGuardをTへのポインタのように扱うことがで"
"きるということだ。\n"

#: src/patterns/behavioural/RAII.md:65
#, fuzzy
msgid ""
"// foo is a method on Foo.\n"
"              // The borrow checker ensures we can't store a reference to "
"the underlying\n"
"              // Foo which will outlive the guard xx.\n"
msgstr ""
"// fooはFooのメソッドです。\n"
"              借用チェッカーは、 // ガード xx よりも長い Foo への参照を保存で"
"きないことを保証する。\n"
"              // への参照を保存できないことを保証します。\n"

#: src/patterns/behavioural/RAII.md:69
#, fuzzy
msgid ""
"// x is unlocked when we exit this function and xx's destructor is "
"executed.\n"
msgstr ""
"// この関数を終了し、xxのデストラクタが実行されると、xのロックは解除され"
"る。\n"

#: src/patterns/behavioural/RAII.md:75
#, fuzzy
msgid ""
"Where a resource must be finalised after use, RAII can be used to do this "
"finalisation. If it is an error to access that resource after finalisation, "
"then this pattern can be used to prevent such errors."
msgstr ""
"リソースの使用後にファイナライズが必要な場合、RAIIを使用してファイナライズを"
"行うことができます。\n"
"ファイナライズ後にリソースにアクセスすることがエラーとなる場合、このパターン"
"はそのようなエラーを防ぐことに使用できます。"

#: src/patterns/behavioural/RAII.md:81
#, fuzzy
msgid ""
"Prevents errors where a resource is not finalised and where a resource is "
"used after finalisation."
msgstr ""
"リソースがファイナライズされない、もしくはリソースがファイナライズされた後に"
"使用されてしまう、といったエラーを防ぎます。"

#: src/patterns/behavioural/RAII.md:86
#, fuzzy
msgid ""
"RAII is a useful pattern for ensuring resources are properly deallocated or "
"finalised. We can make use of the borrow checker in Rust to statically "
"prevent errors stemming from using resources after finalisation takes place."
msgstr ""
"RAIIは、リソースが適切に解放またはファイナライズされることを保証するための有"
"用なパターンです。\n"
"Rustの借用チェッカーを使用することで、ファイナライズ後にリソースを使用するこ"
"とにより生じるエラーを静的に防ぐことが可能です。"

#: src/patterns/behavioural/RAII.md:90
#, fuzzy
msgid ""
"The core aim of the borrow checker is to ensure that references to data do "
"not outlive that data. The RAII guard pattern works because the guard object "
"contains a reference to the underlying resource and only exposes such "
"references. Rust ensures that the guard cannot outlive the underlying "
"resource and that references to the resource mediated by the guard cannot "
"outlive the guard. To see how this works it is helpful to examine the "
"signature of `deref` without lifetime elision:"
msgstr ""
"借用チェッカーの主な目的は、データへの参照がそのデータ自体より長く生存しない"
"ことを保証することです。\n"
"RAIIガードパターンが機能するのは、\n"
"ガードオブジェクトが基のリソースへの参照を保持し、その参照のみを公開するから"
"です。\n"
"Rustは、ガードが、基のリソースより長く生存しないことを保証するとともに、\n"
"ガードが介するそのリソースへの参照がガードよりも長く生存しないことを保証しま"
"す。\n"
"これがどのように機能するかを見るために、ライフタイムを省略せずに `deref`のシ"
"グネチャを確かめることが助けになるでしょう："

#: src/patterns/behavioural/RAII.md:104
#, fuzzy
msgid ""
"The returned reference to the resource has the same lifetime as `self` "
"(`'a`). The borrow checker therefore ensures that the lifetime of the "
"reference to `T` is shorter than the lifetime of `self`."
msgstr ""
"戻り値であるリソースへの参照は `self` (`'a`) と同じライフタイムを持ちます。\n"
"したがって、借用チェッカーは `T` への参照のライフタイムが `self` のライフタイ"
"ムよりも短いことを保証します。"

#: src/patterns/behavioural/RAII.md:108
#, fuzzy
msgid ""
"Note that implementing `Deref` is not a core part of this pattern, it only "
"makes using the guard object more ergonomic. Implementing a `get` method on "
"the guard works just as well."
msgstr ""
"`Deref` を実装することがこのパターンの核心部分でないことに注意してくださ"
"い。\n"
"ガードオブジェクトをより人間工学的に使えるようにするだけです。\n"
"ガードに `get` メソッドを実装しても同じように動作します。"

#: src/patterns/behavioural/RAII.md:114
msgid "[Finalisation in destructors idiom](../../idioms/dtor-finally.md)"
msgstr "[デストラクタでのファイナライズ](../../idioms/dtor-finally.md)"

#: src/patterns/behavioural/RAII.md:116
#, fuzzy
msgid ""
"RAII is a common pattern in C++: [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii), [wikipedia](https://en.wikipedia.org/wiki/"
"Resource_Acquisition_Is_Initialization)."
msgstr ""
"C++ではRAIIは一般的なパターン： [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii)、\n"
"[wikipedia][ウィキペディア]。"

#: src/patterns/behavioural/RAII.md:122
#, fuzzy
msgid ""
"[Style guide entry](https://doc.rust-lang.org/1.0.0/style/ownership/raii."
"html) (currently just a placeholder)."
msgstr ""
"[Style Guidelines のエントリ](https://doc.rust-lang.org/1.0.0/style/"
"ownership/raii.html)\n"
"(現在は単なるプレースホルダ）。"

#: src/patterns/behavioural/strategy.md:1
#, fuzzy
msgid "Strategy (aka Policy)"
msgstr "# Strategy (Polich とも)"

#: src/patterns/behavioural/strategy.md:5
#, fuzzy
msgid ""
"The [Strategy design pattern](https://en.wikipedia.org/wiki/"
"Strategy_pattern) is a technique that enables separation of concerns. It "
"also allows to decouple software modules through [Dependency Inversion]"
"(https://en.wikipedia.org/wiki/Dependency_inversion_principle)."
msgstr ""
"[Strategy デザインパターン](https://en.wikipedia.org/wiki/Strategy_pattern)"
"は、関心事の分離を可能にするテクニックです。\n"
"また、[依存関係逆転の原則](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)によって、ソフトウェアモジュールを分離すること"
"も可能になります。"

#: src/patterns/behavioural/strategy.md:10
#, fuzzy
msgid ""
"The basic idea behind the Strategy pattern is that, given an algorithm "
"solving a particular problem, we define only the skeleton of the algorithm "
"at an abstract level, and we separate the specific algorithm’s "
"implementation into different parts."
msgstr ""
"Strategyパターンの基本的な考え方は、\n"
"ある特定の問題を解決するアルゴリズムが与えられたとき、\n"
"抽象的なレベルではアルゴリズムの骨組みだけを定義し、\n"
"具体的なアルゴリズムの実装は別の部分に分離する、というものです。"

#: src/patterns/behavioural/strategy.md:15
#, fuzzy
msgid ""
"In this way, a client using the algorithm may choose a specific "
"implementation, while the general algorithm workflow remains the same. In "
"other words, the abstract specification of the class does not depend on the "
"specific implementation of the derived class, but specific implementation "
"must adhere to the abstract specification. This is why we call it "
"\"Dependency Inversion\"."
msgstr ""
"この方法では、アルゴリズムを使用するクライアントは、アルゴリズムの共通のワー"
"クフローをそのままに、具体的な実装を選択することが可能です。\n"
"言い換えれば、クラスの抽象的な仕様が派生クラスの具体的な実装に依存するのでは"
"なく、\n"
"具体的な実装が抽象的な仕様に従う必要があります。\n"
"これが「依存関係逆転」と呼ばれる理由です。"

#: src/patterns/behavioural/strategy.md:23
#, fuzzy
msgid ""
"Imagine we are working on a project that generates reports every month. We "
"need the reports to be generated in different formats (strategies), e.g., in "
"`JSON` or `Plain Text` formats. But things vary over time, and we don't know "
"what kind of requirement we may get in the future. For example, we may need "
"to generate our report in a completely new format, or just modify one of the "
"existing formats."
msgstr ""
"私たちは毎月レポートを生成するプロジェクトに取り組んでいるとしましょう。\n"
"このレポートはさまざまな形式(ストラテジ)、例えば `JSON` や `Plain Text` な"
"ど、で生成される必要があります。\n"
"しかし、物事は時間の経過とともに変化するもので、将来どんな要求が来るかわかり"
"ません。\n"
"例えば、まったく新しい形式でレポートを生成する必要があるかもしれませんし、\n"
"あるいは既存のフォーマットの1つを変更するだけかもしれません。"

#: src/patterns/behavioural/strategy.md:32
#, fuzzy
msgid ""
"In this example our invariants (or abstractions) are `Formatter` and "
"`Report`, while `Text` and `Json` are our strategy structs. These strategies "
"have to implement the `Formatter` trait."
msgstr ""
"この例では、 `Formatter` と `Report` が不変（または抽象）な部分であり、対し"
"て `Text` と `Json` がストラテジの構造体です。\n"
"これらのストラテジは `Formatter` トレイトを実装する必要があります。"

#: src/patterns/behavioural/strategy.md:48
#, fuzzy
msgid ""
"// Write should be used but we kept it as String to ignore error handling\n"
msgstr ""
"// Writeを使うべきだが、エラー処理を無視するためにStringのままにしている。\n"

#: src/patterns/behavioural/strategy.md:50
#, fuzzy
msgid "// backend operations...\n"
msgstr "// バックエンドの操作...\n"

#: src/patterns/behavioural/strategy.md:52
#, fuzzy
msgid "\"one\""
msgstr "これを以下のように呼び出せるように:"

#: src/patterns/behavioural/strategy.md:53
#, fuzzy
msgid "\"two\""
msgstr "2つ？"

#: src/patterns/behavioural/strategy.md:54
#, fuzzy
msgid "// generate report\n"
msgstr "// レポートを生成する\n"

#: src/patterns/behavioural/strategy.md:63
#, fuzzy
msgid "\"{k} {v}\\n\""
msgstr "\"{k} {v}\\n\""

#: src/patterns/behavioural/strategy.md:72
#, fuzzy
msgid "'['"
msgstr "'['"

#: src/patterns/behavioural/strategy.md:74
#, fuzzy
msgid "r#\"{{\"{}\":\"{}\"}}\"#"
msgstr ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"type Data = HashMap<String, u32>;\n"
"\n"
"trait Formatter {\n"
"    fn format(&self, data: &Data, buf: &mut String);\n"
"}\n"
"\n"
"struct Report;\n"
"\n"
"impl Report {\n"
"    // Write を使用すべきですが、エラーハンドリングを無視するため String のま"
"まとしています\n"
"    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
"        // バックエンド処理...\n"
"        let mut data = HashMap::new();\n"
"        data.insert(\"one\".to_string(), 1);\n"
"        data.insert(\"two\".to_string(), 2);\n"
"        // レポート生成\n"
"        g.format(&data, s);\n"
"    }\n"
"}\n"
"\n"
"struct Text;\n"
"impl Formatter for Text {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        for (k, v) in data {\n"
"            let entry = format!(\"{} {}\\n\", k, v);\n"
"            buf.push_str(&entry);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json;\n"
"impl Formatter for Json {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        buf.push('[');\n"
"        for (k, v) in data.into_iter() {\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
"            buf.push_str(&entry);\n"
"            buf.push(',');\n"
"        }\n"
"        if !data.is_empty() {\n"
"            buf.pop(); // 最後の余分な , を削除\n"
"        }\n"
"        buf.push(']');\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut s = String::from(\"\");\n"
"    Report::generate(Text, &mut s);\n"
"    assert!(s.contains(\"one 1\"));\n"
"    assert!(s.contains(\"two 2\"));\n"
"\n"
"    s.clear(); // バッファ再利用\n"
"    Report::generate(Json, &mut s);\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:76
#, fuzzy
msgid "','"
msgstr "','"

#: src/patterns/behavioural/strategy.md:79
#, fuzzy
msgid "// remove extra , at the end\n"
msgstr "// 最後の余分な , を取り除く\n"

#: src/patterns/behavioural/strategy.md:81
#, fuzzy
msgid "']'"
msgstr "']'"

#: src/patterns/behavioural/strategy.md:86
#, fuzzy
msgid "\"\""
msgstr "\"\""

#: src/patterns/behavioural/strategy.md:88
#, fuzzy
msgid "\"one 1\""
msgstr "\"one 1\""

#: src/patterns/behavioural/strategy.md:89
#, fuzzy
msgid "\"two 2\""
msgstr "\"two 2\""

#: src/patterns/behavioural/strategy.md:91
#, fuzzy
msgid "// reuse the same buffer\n"
msgstr "// 同じバッファを再利用する\n"

#: src/patterns/behavioural/strategy.md:93
#, fuzzy
msgid "r#\"{\"one\":\"1\"}\"#"
msgstr "r#\"{\"one\":\"1\"}\"#"

#: src/patterns/behavioural/strategy.md:94
#, fuzzy
msgid "r#\"{\"two\":\"2\"}\"#"
msgstr "r#\"{\"two\":\"2\"}\"#"

#: src/patterns/behavioural/strategy.md:100
#, fuzzy
msgid ""
"The main advantage is separation of concerns. For example, in this case "
"`Report` does not know anything about specific implementations of `Json` and "
"`Text`, whereas the output implementations does not care about how data is "
"preprocessed, stored, and fetched. The only thing they have to know is a "
"specific trait to implement and its method defining the concrete algorithm "
"implementation processing the result, i.e., `Formatter` and `format(...)`."
msgstr ""
"主な利点は関心の分離です。\n"
"例えば、この例の `Report` は、 `Json` と `Text` の具体的な実装については何も"
"知りません。\n"
"その一方では、出力の実装はデータがどのように前処理され、保存され、フェッチさ"
"れるのか気にしません。\n"
"それらが知っていなければならないのは、実装すべき「特定のトレイト」と、結果の"
"処理を行うアルゴリズムの具体的な実装を定義している「そのメソッド」、つまり "
"`Formatter` と `format(...)` 、のみです。"

#: src/patterns/behavioural/strategy.md:109
#, fuzzy
msgid ""
"For each strategy there must be implemented at least one module, so number "
"of modules increases with number of strategies. If there are many strategies "
"to choose from then users have to know how strategies differ from one "
"another."
msgstr ""
"各ストラテジ毎に少なくとも1つのモジュールが実装されることになるため、ストラテ"
"ジの数だけモジュールの数が増えます。\n"
"選択できるストラテジーがたくさんある場合、ユーザーはあるストラテジと別のスト"
"ラテジとの違いを知らなければなりません。"

#: src/patterns/behavioural/strategy.md:115
#, fuzzy
msgid ""
"In the previous example all strategies are implemented in a single file. "
"Ways of providing different strategies includes:"
msgstr ""
"前の例では、すべてのストラテジは1つのファイルに実装されていました。\n"
"個々のストラテジーを提供する方法には次のようなものがあります："

#: src/patterns/behavioural/strategy.md:118
#, fuzzy
msgid ""
"All in one file (as shown in this example, similar to being separated as "
"modules)"
msgstr ""
"すべて1つのファイル（この例のように、モジュールとして分離されているのと似てい"
"る）"

#: src/patterns/behavioural/strategy.md:120
#, fuzzy
msgid ""
"Separated as modules, E.g. `formatter::json` module, `formatter::text` module"
msgstr "例：`formatter::json` モジュール、`formatter::text` モジュール"

#: src/patterns/behavioural/strategy.md:121
#, fuzzy
msgid "Use compiler feature flags, E.g. `json` feature, `text` feature"
msgstr "コンパイラの機能フラグを使う（例：`json`機能、`text`機能"

#: src/patterns/behavioural/strategy.md:122
#, fuzzy
msgid "Separated as crates, E.g. `json` crate, `text` crate"
msgstr "json`クレート、`text`クレートなど。"

#: src/patterns/behavioural/strategy.md:124
#, fuzzy
msgid ""
"Serde crate is a good example of the `Strategy` pattern in action. Serde "
"allows [full customization](https://serde.rs/custom-serialization.html) of "
"the serialization behavior by manually implementing `Serialize` and "
"`Deserialize` traits for our type. For example, we could easily swap "
"`serde_json` with `serde_cbor` since they expose similar methods. Having "
"this makes the helper crate `serde_transcode` much more useful and ergonomic."
msgstr ""
"Serde crateは `Strategy` パターンが実際に使われている良い例です。\n"
"Serdeでは、型に `Serialize` と `Deserialize` を手動で実装することで、シリアラ"
"イズ動作の [フルカスタマイズ](https://serde.rs/custom-serialization.html) が"
"可能です。\n"
"例えば、似たようなメソッドを公開している `serde_json` と `serde_cbor` を簡単"
"に入れ替えることができます。\n"
"これにより、ヘルパー crate `serde_transcode` がより便利で人間工学的なものにな"
"ります。"

#: src/patterns/behavioural/strategy.md:131
msgid ""
"However, we don't need to use traits in order to design this pattern in Rust."
msgstr ""
"しかしながら、Rustでこのパターンを設計するためにトレイトを使うことは必須では"
"ありません。"

#: src/patterns/behavioural/strategy.md:133
#, fuzzy
msgid ""
"The following toy example demonstrates the idea of the Strategy pattern "
"using Rust `closures`:"
msgstr ""
"次の単純化した例は、Rustの `closure` を使った Strategy パターンのアイデアを示"
"しています："

#: src/patterns/behavioural/strategy.md:164
msgid "In fact, Rust already uses this idea for `Options`'s `map` method:"
msgstr ""
"実際、Rust はすでに `Options` の `map` メソッドでこのアイデアを使っています："

#: src/patterns/behavioural/strategy.md:168
#, fuzzy
msgid "\"Rust\""
msgstr "The Little Book of Rust Macros"

#: src/patterns/behavioural/strategy.md:180
#, fuzzy
msgid "[Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)"
msgstr ""
"YAGNIをデザインパターンに適用すると、Rustの機能によって多くのパターンを捨てる"
"ことができることがわかります。\n"
"例えば、Rustでは [strategyパターン](https://en.wikipedia.org/wiki/"
"Strategy_pattern) は不要です。\n"
"なぜなら、単に [trait](https://doc.rust-lang.org/book/traits.html) を使えば良"
"いためです。"

#: src/patterns/behavioural/strategy.md:181
#, fuzzy
msgid ""
"[Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection)"
msgstr ""
"## [契約による設計（DbC）](https://en.wikipedia.org/wiki/Design_by_contract)"

#: src/patterns/behavioural/strategy.md:182
#, fuzzy
msgid ""
"[Policy Based Design](https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-"
"based_design)"
msgstr ""
"[ポリシー・ベース・デザイン](https://en.wikipedia.org/wiki/Modern_C+"
"+_Design#Policy-based_design)"

#: src/patterns/behavioural/strategy.md:183
#, fuzzy
msgid ""
"[Implementing a TCP server for Space Applications in Rust using the Strategy "
"Pattern](https://web.archive.org/web/20231003171500/https://robamu.github.io/"
"posts/rust-strategy-pattern/)"
msgstr ""
"[Strategyパターンを用いたRustでの宇宙アプリケーション用TCPサーバーの実装]"
"(https://web.archive.org/web/20231003171500/https://robamu.github.io/posts/"
"rust-strategy-pattern/)"

#: src/patterns/behavioural/visitor.md:5
#, fuzzy
msgid ""
"A visitor encapsulates an algorithm that operates over a heterogeneous "
"collection of objects. It allows multiple different algorithms to be written "
"over the same data without having to modify the data (or their primary "
"behaviour)."
msgstr ""
"visitor は、異種のオブジェクトのコレクションを操作するアルゴリズムをカプセル"
"化します。\n"
"これにより、データ(またはその主要な振る舞い)を変更する必要なしに、同じデータ"
"に対して複数の異なるアルゴリズムを書くことができます。"

#: src/patterns/behavioural/visitor.md:10
#, fuzzy
msgid ""
"Furthermore, the visitor pattern allows separating the traversal of a "
"collection of objects from the operations performed on each object."
msgstr ""
"さらに、Visitor パターンでは、オブジェクトの集合の走査を、\n"
"各オブジェクトに対し実行される操作から分離することができます。"

#: src/patterns/behavioural/visitor.md:16
#, fuzzy
msgid "// The data we will visit\n"
msgstr "// 訪問するデータ\n"

#: src/patterns/behavioural/visitor.md:33
#, fuzzy
msgid "// The abstract visitor\n"
msgstr "// 抽象的な訪問者\n"

#: src/patterns/behavioural/visitor.md:47
#, fuzzy
msgid ""
"// An example concrete implementation - walks the AST interpreting it as "
"code.\n"
msgstr "// ASTをコードとして解釈して歩く。\n"

#: src/patterns/behavioural/visitor.md:71
#, fuzzy
msgid ""
"One could implement further visitors, for example a type checker, without "
"having to modify the AST data."
msgstr ""
"ASTデータを変更することなく、さらなる visitor 、例えば型チェッカーなど、を実"
"装可能です。"

#: src/patterns/behavioural/visitor.md:76
#, fuzzy
msgid ""
"The visitor pattern is useful anywhere that you want to apply an algorithm "
"to heterogeneous data. If data is homogeneous, you can use an iterator-like "
"pattern. Using a visitor object (rather than a functional approach) allows "
"the visitor to be stateful and thus communicate information between nodes."
msgstr ""
"ビジター・パターンは、異種データにアルゴリズムを適用したい場合に便利です。\n"
"データが同種であれば、イテレータのようなパターンを使うことができます。\n"
"(関数型アプローチと比較して) visitor オブジェクトを使用することにより、\n"
"visitor はステートフルになり、そのためノード間で情報を伝達することができま"
"す。"

#: src/patterns/behavioural/visitor.md:83
#, fuzzy
msgid ""
"It is common for the `visit_*` methods to return void (as opposed to in the "
"example). In that case it is possible to factor out the traversal code and "
"share it between algorithms (and also to provide noop default methods). In "
"Rust, the common way to do this is to provide `walk_*` functions for each "
"datum. For example,"
msgstr ""
"`visit_*` メソッドが void を返すのは(例とは異なり)一般的です。\n"
"この場合、走査コードを分離してアルゴリズム間で共有することが可能です(また、"
"noopデフォルトメソッドを提供することも可能です)。\n"
"Rustでは、データ各個に対して `walk_*` 関数を提供するのが一般的です。\n"
"例えば、"

#: src/patterns/behavioural/visitor.md:105
#, fuzzy
msgid ""
"In other languages (e.g., Java) it is common for data to have an `accept` "
"method which performs the same duty."
msgstr ""
"他の言語（例えばJava）では、データに対し同様の責務を担う `accept` メソッドが"
"あるのが普通です。"

#: src/patterns/behavioural/visitor.md:110
msgid "The visitor pattern is a common pattern in most OO languages."
msgstr ""
"Visitor パターンは、ほとんどのオブジェクト指向言語で一般的なパターンです。"

#: src/patterns/behavioural/visitor.md:112
msgid "[Wikipedia article](https://en.wikipedia.org/wiki/Visitor_pattern)"
msgstr "[ウィキペディア記事](https://en.wikipedia.org/wiki/Visitor_pattern)"

#: src/patterns/behavioural/visitor.md:114
#, fuzzy
msgid ""
"The [fold](../creational/fold.md) pattern is similar to visitor but produces "
"a new version of the visited data structure."
msgstr ""
"[Fold](../creational/fold.md)パターンは Visitor に似ていますが、訪問したデー"
"タ構造の新しいバージョンを生成する点が異なります。"

#: src/patterns/creational/intro.md:1
#, fuzzy
msgid "Creational Patterns"
msgstr "# 生成に関するパターン"

#: src/patterns/creational/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/patterns/creational/intro.md:5
#, fuzzy
msgid ""
"Design patterns that deal with object creation mechanisms, trying to create "
"objects in a manner suitable to the situation. The basic form of object "
"creation could result in design problems or in added complexity to the "
"design. Creational design patterns solve this problem by somehow controlling "
"this object creation."
msgstr ""
"> Design patterns that deal with object creation mechanisms, trying to "
"create objects\n"
"> in a manner suitable to the situation. The basic form of object creation "
"could\n"
"> result in design problems or in added complexity to the design. Creational "
"design\n"
"> patterns solve this problem by somehow controlling this object creation.\n"
"> (オブジェクト生成のメカニズムを扱う、状況に適した方法でオブジェクトを生成し"
"ようとするデザインパターン。\n"
"> 状況に適した方法でオブジェクト生成の基本形は設計上の問題が発生したり、設計"
"が複雑になったりします。\n"
">  生成に関するデザインパターンは、オブジェクト生成を何らかの方法で制御するこ"
"とで、この問題を解決します。)"

#: src/patterns/creational/builder.md:5
msgid "Construct an object with calls to a builder helper."
msgstr "builder ヘルパの呼び出しによりオブジェクトを構築します。"

#: src/patterns/creational/builder.md:12
#, fuzzy
msgid "// Lots of complicated fields.\n"
msgstr "// 複雑なフィールドがたくさんある。\n"

#: src/patterns/creational/builder.md:17
#, fuzzy
msgid "// This method will help users to discover the builder\n"
msgstr "// このメソッドは、ユーザーがビルダーを発見するのを助ける。\n"

#: src/patterns/creational/builder.md:25
#, fuzzy
msgid "// Probably lots of optional fields.\n"
msgstr "// おそらく多くのオプション・フィールドがある。\n"

#: src/patterns/creational/builder.md:31
#, fuzzy
msgid "// Set the minimally required fields of Foo.\n"
msgstr "// Foo の最低限必要なフィールドを設定します。\n"

#: src/patterns/creational/builder.md:33
#, fuzzy
msgid "\"X\""
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"mod b {\n"
"    // X!(); // 定義されていない\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/patterns/creational/builder.md:38
#, fuzzy
msgid ""
"// Set the name on the builder itself, and return the builder by value.\n"
msgstr "// ビルダ自身に名前を設定し、ビルダを値で返す。\n"

#: src/patterns/creational/builder.md:43
#, fuzzy
msgid ""
"// If we can get away with not consuming the Builder here, that is an\n"
"    // advantage. It means we can use the FooBuilder as a template for "
"constructing\n"
"    // many Foos.\n"
msgstr ""
"もしここでビルダーを消費せずに済むのであれば、それは // 利点である。\n"
"    // 利点である。つまり、FooBuilderをテンプレートとして使って、 // 多くの"
"Fooを構築することができる。\n"
"    // 多くのFooを構築するためのテンプレートとして使えるということです。\n"

#: src/patterns/creational/builder.md:47
#, fuzzy
msgid ""
"// Create a Foo from the FooBuilder, applying all settings in FooBuilder\n"
"        // to Foo.\n"
msgstr ""
"// FooBuilder のすべての設定を Foo に適用します。\n"
"        // のすべての設定を Foo に適用します。\n"

#: src/patterns/creational/builder.md:56 src/patterns/creational/builder.md:58
#, fuzzy
msgid "\"Y\""
msgstr ""
"```rust,ignore\n"
"// `X!` マクロ _のみ_ をインポート\n"
"#[macro_use(X)] extern crate macs;\n"
"\n"
"// X!(); // X は定義されているが、 Y! が定義されていない\n"
"\n"
"macro_rules! Y { () => {} }\n"
"\n"
"X!(); // X は定義されており、 Y! も定義されている\n"
"\n"
"fn main() {}\n"
"```"

#: src/patterns/creational/builder.md:65
#, fuzzy
msgid ""
"Useful when you would otherwise require many constructors or where "
"construction has side effects."
msgstr ""
"多くのコンストラクタが必要な場合や、オブジェクトを構築する際に副作用がある場"
"合に便利です。"

#: src/patterns/creational/builder.md:70
msgid "Separates methods for building from other methods."
msgstr "構築のためのメソッドを他のメソッドから分離します。"

#: src/patterns/creational/builder.md:72
msgid "Prevents proliferation of constructors."
msgstr "コンストラクタの増殖を防ぎます。"

#: src/patterns/creational/builder.md:74
msgid ""
"Can be used for one-liner initialisation as well as more complex "
"construction."
msgstr "ワンライナーでの初期化にも、より複雑な構築にも使用できます。"

#: src/patterns/creational/builder.md:78
#, fuzzy
msgid ""
"More complex than creating a struct object directly, or a simple constructor "
"function."
msgstr ""
"構造体オブジェクトを直接作成したり、単純なコンストラクタ関数を使用するよりも"
"複雑です。"

#: src/patterns/creational/builder.md:83
#, fuzzy
msgid ""
"This pattern is seen more frequently in Rust (and for simpler objects) than "
"in many other languages because Rust lacks overloading. Since you can only "
"have a single method with a given name, having multiple constructors is less "
"nice in Rust than in C++, Java, or others."
msgstr ""
"Rustにはオーバーロードがないため、他の多くの言語と比較して、このパターンが頻"
"繁に登場します(またより単純なオブジェクトに適用されます)。\n"
"1つの名前を持つメソッドは1つのみであることから、Rust にて複数のコンストラクタ"
"を定義することは、C++ や Java などと比べてあまり良いことではありません。"

#: src/patterns/creational/builder.md:88
#, fuzzy
msgid ""
"This pattern is often used where the builder object is useful in its own "
"right, rather than being just a builder. For example, see [`std::process::"
"Command`](https://doc.rust-lang.org/std/process/struct.Command.html) is a "
"builder for [`Child`](https://doc.rust-lang.org/std/process/struct.Child."
"html) (a process). In these cases, the `T` and `TBuilder` naming pattern is "
"not used."
msgstr ""
"このパターンは、builder オブジェクトが単なる builder としてではなく、それ自体"
"として有用である場合によく使われます。\n"
"例えば[`std::process::Command`](https://doc.rust-lang.org/std/process/struct."
"Command.html)\n"
"は [`Child`](https://doc.rust-lang.org/std/process/struct.Child.html) (プロセ"
"ス) のビルダーです。\n"
"これらの場合、 `T` と `TBuilder` の命名パターンは使用されていません。"

#: src/patterns/creational/builder.md:95
#, fuzzy
msgid ""
"The example takes and returns the builder by value. It is often more "
"ergonomic (and more efficient) to take and return the builder as a mutable "
"reference. The borrow checker makes this work naturally. This approach has "
"the advantage that one can write code like"
msgstr ""
"例ではbuilderを値として引数に受け、return しています。\n"
"可変参照として引数に受け、return する形式が、多くの場合、より人間工学的(かつ"
"効率的)です。\n"
"借用チェッカーはこれを自然に動作させます。\n"
"このアプローチには下記のようなコードを書けるようになるメリットがあります。"

#: src/patterns/creational/builder.md:107
msgid "as well as the `FooBuilder::new().a().b().build()` style."
msgstr "`FooBuilder::new().a().b().build()` のスタイルと同様です。"

#: src/patterns/creational/builder.md:111
#, fuzzy
msgid ""
"[Description in the style guide](https://web.archive.org/web/20210104103100/"
"https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)"
msgstr ""
"[スタイルガイドの記述](https://web.archive.org/web/20210104103100/https://"
"doc.rust-lang.org/1.12.0/style/ownership/builders.html)"

#: src/patterns/creational/builder.md:112
#, fuzzy
msgid ""
"[derive_builder](https://crates.io/crates/derive_builder), a crate for "
"automatically implementing this pattern while avoiding the boilerplate."
msgstr ""
"[derive_builder](https://crates.io/crates/derive_builder)は、定型文を避けなが"
"らこのパターンを自動的に実装するためのクレートです。"

#: src/patterns/creational/builder.md:114
#, fuzzy
msgid ""
"[Constructor pattern](../../idioms/ctor.md) for when construction is simpler."
msgstr ""
"[コンストラクタのパターン](../../idioms/ctor.md) 構築がより単純な場合用。"

#: src/patterns/creational/builder.md:115
#, fuzzy
msgid ""
"[Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/Builder_pattern)"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern) より："

#: src/patterns/creational/builder.md:116
#, fuzzy
msgid ""
"[Construction of complex values](https://web.archive.org/web/20210104103000/"
"https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder)"
msgstr ""
"[複素数値の構成](https://web.archive.org/web/20210104103000/https://rust-"
"lang.github.io/api-guidelines/type-safety.html#c-builder)"

#: src/patterns/creational/fold.md:5
#, fuzzy
msgid ""
"Run an algorithm over each item in a collection of data to create a new "
"item, thus creating a whole new collection."
msgstr ""
"データのコレクション内の各項目に対してアルゴリズムを実行し新しい項目を作成、"
"こうして、全く新しいコレクションを作成します。"

#: src/patterns/creational/fold.md:8
#, fuzzy
msgid ""
"The etymology here is unclear to me. The terms 'fold' and 'folder' are used "
"in the Rust compiler, although it appears to me to be more like a map than a "
"fold in the usual sense. See the discussion below for more details."
msgstr ""
"この語源は私には理解できません。「fold」と「folder」という用語は、Rustコンパ"
"イラで使われています。\n"
"通常の感覚では fold というより map が近いように思います。詳しくは以下の議論を"
"参照してください。"

#: src/patterns/creational/fold.md:15
#, fuzzy
msgid "// The data we will fold, a simple AST.\n"
msgstr "// 折り畳むデータ、単純なAST。\n"

#: src/patterns/creational/fold.md:32
#, fuzzy
msgid "// The abstract folder\n"
msgstr "// 抽象フォルダ\n"

#: src/patterns/creational/fold.md:38
#, fuzzy
msgid ""
"// A leaf node just returns the node itself. In some cases, we can do this\n"
"        // to inner nodes too.\n"
msgstr ""
"// リーフ・ノードは単にノード自身を返す。場合によっては\n"
"        // 内部ノードに対しても\n"

#: src/patterns/creational/fold.md:41
#, fuzzy
msgid "// Create a new inner node by folding its children.\n"
msgstr "// 子ノードを折りたたんで新しい内部ノードを作成する。\n"

#: src/patterns/creational/fold.md:54
#, fuzzy
msgid "// An example concrete implementation - renames every name to 'foo'.\n"
msgstr "// すべての名前を'foo'にリネームする。\n"

#: src/patterns/creational/fold.md:59
#, fuzzy
msgid "\"foo\""
msgstr ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo,\n"
"}\n"
"\n"
"impl Deref for Bar {\n"
"    type Target = Foo;\n"
"    fn deref(&self) -> &Foo {\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} };\n"
"    b.m();\n"
"}\n"
"```"

#: src/patterns/creational/fold.md:61
#, fuzzy
msgid "// Use the default methods for the other nodes.\n"
msgstr "// 他のノードにはデフォルトのメソッドを使用します。\n"

#: src/patterns/creational/fold.md:65
#, fuzzy
msgid ""
"The result of running the `Renamer` on an AST is a new AST identical to the "
"old one, but with every name changed to `foo`. A real life folder might have "
"some state preserved between nodes in the struct itself."
msgstr ""
"ASTに対して `Renamer` を実行した結果は、すべての名前が `foo` に変更されたこと"
"を除いて元のASTとまったく同一の、新しいASTになります。\n"
"実際の folder では構造体のノード間で何らかの状態を保持する可能性があります。"

#: src/patterns/creational/fold.md:69
#, fuzzy
msgid ""
"A folder can also be defined to map one data structure to a different (but "
"usually similar) data structure. For example, we could fold an AST into a "
"HIR tree (HIR stands for high-level intermediate representation)."
msgstr ""
"folder は、あるデータ構造を別の(しかし通常は類似した)データ構造にマッピングす"
"るものとして定義することもできます。\n"
"例えば、ASTをHIRツリーに折り畳むことができます(HIRは high-level intermediate "
"representation (高水準中間表現) の略です)。"

#: src/patterns/creational/fold.md:75
#, fuzzy
msgid ""
"It is common to want to map a data structure by performing some operation on "
"each node in the structure. For simple operations on simple data structures, "
"this can be done using `Iterator::map`. For more complex operations, perhaps "
"where earlier nodes can affect the operation on later nodes, or where "
"iteration over the data structure is non-trivial, using the fold pattern is "
"more appropriate."
msgstr ""
"データ構造内の各ノードに対して何らかの操作を実行することで、データ構造をマッ"
"プしたい場合がよくあります。\n"
"これは、単純なデータ構造に対する単純な操作であれば、 `Iterator::map` を使って"
"行えます。\n"
"より複雑な操作、例えば前のノードが後のノードの操作に影響を与えるような操作"
"や、\n"
"データ構造に対するイテレーションが自明でないような操作には、foldパターンを使"
"うことがより適切です。"

#: src/patterns/creational/fold.md:82
#, fuzzy
msgid ""
"Like the visitor pattern, the fold pattern allows us to separate traversal "
"of a data structure from the operations performed to each node."
msgstr ""
"Visitor パターンと同様に Fold パターンでも、データ構造の走査を各ノードに対し"
"て行われる操作から分離することができます。"

#: src/patterns/creational/fold.md:87
#, fuzzy
msgid ""
"Mapping data structures in this fashion is common in functional languages. "
"In OO languages, it would be more common to mutate the data structure in "
"place. The 'functional' approach is common in Rust, mostly due to the "
"preference for immutability. Using fresh data structures, rather than "
"mutating old ones, makes reasoning about the code easier in most "
"circumstances."
msgstr ""
"このような形でデータ構造をマッピングすることは、関数型言語では一般的です。\n"
"OO言語では、データ構造をその場で書き換えることがより一般的でしょう。\n"
"Rustでは、主に不変性を好むため、「関数型」アプローチが一般的です。\n"
"Rustでは「関数型」アプローチが一般的です。古いデータ構造を書き換えるのではな"
"く、\n"
"新しいデータ構造を使用することで、ほとんどの状況でコードに関する推論が容易に"
"なります。"

#: src/patterns/creational/fold.md:93
#, fuzzy
msgid ""
"The trade-off between efficiency and reusability can be tweaked by changing "
"how nodes are accepted by the `fold_*` methods."
msgstr ""
"効率と再利用性のトレードオフは、`fold_*` メソッドでノードを受け入れる方法を変"
"更することで調整できます。"

#: src/patterns/creational/fold.md:96
#, fuzzy
msgid ""
"In the above example we operate on `Box` pointers. Since these own their "
"data exclusively, the original copy of the data structure cannot be re-used. "
"On the other hand if a node is not changed, reusing it is very efficient."
msgstr ""
"上の例では `Box` ポインタを操作しています。\n"
"これらはそのデータを排他的に所有するため、データ構造の元のコピーを再利用する"
"ことはできません。\n"
"一方、ノードが変更されなければ、それを再利用することは非常に効率的です。"

#: src/patterns/creational/fold.md:100
#, fuzzy
msgid ""
"If we were to operate on borrowed references, the original data structure "
"can be reused; however, a node must be cloned even if unchanged, which can "
"be expensive."
msgstr ""
"借用した参照を操作していたのであれば、元のデータ構造を再利用することができま"
"す。\n"
"しかし、変更がなくともノードをクローンする必要があり、コストがかかります。"

#: src/patterns/creational/fold.md:104
#, fuzzy
msgid ""
"Using a reference counted pointer gives the best of both worlds - we can "
"reuse the original data structure, and we don't need to clone unchanged "
"nodes. However, they are less ergonomic to use and mean that the data "
"structures cannot be mutable."
msgstr ""
"参照カウントされたポインタを使用すると両方の利点が得られます。元のデータ構造"
"を再利用でき、変更されていないノードをクローンする必要がないためです。\n"
"これらは人間工学的に使いにくく、データ構造をミュータブルにできないことを意味"
"します。"

#: src/patterns/creational/fold.md:111
#, fuzzy
msgid ""
"Iterators have a `fold` method, however this folds a data structure into a "
"value, rather than into a new data structure. An iterator's `map` is more "
"like this fold pattern."
msgstr ""
"イテレータには `fold` メソッドがありますが、これはデータ構造を新しいデータ構"
"造に fold するのではなく、1つの値に畳み込みます。\n"
"イテレータの `map` が、この Fold パターンには似ています。"

#: src/patterns/creational/fold.md:115
#, fuzzy
msgid ""
"In other languages, fold is usually used in the sense of Rust's iterators, "
"rather than this pattern. Some functional languages have powerful constructs "
"for performing flexible maps over data structures."
msgstr ""
"他の言語では、fold は、この Fold パターンではなく、通常Rustのイテレータにおけ"
"る意味 (`fold` メソッド) で使われます。\n"
"関数型言語の中には、データ構造に対して柔軟なマップを行うための強力な構成要素"
"を持つものがあります。"

#: src/patterns/creational/fold.md:119
#, fuzzy
msgid ""
"The [visitor](../behavioural/visitor.md) pattern is closely related to fold. "
"They share the concept of walking a data structure performing an operation "
"on each node. However, the visitor does not create a new data structure nor "
"consume the old one."
msgstr ""
"[Visitor](../behavioural/visitor.md)パターンは Fold と密接に関連していま"
"す。\n"
"この2つのパターンは、データ構造を巡りながら各ノードに対して操作を行う、という"
"概念を共有しています。\n"
"しかし、Visitor は新しいデータ構造を生成したり、古いデータ構造を消費したりは"
"しません。"

#: src/patterns/structural/intro.md:1
#, fuzzy
msgid "Structural Patterns"
msgstr "# 構造に関するパターン"

#: src/patterns/structural/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern)より："

#: src/patterns/structural/intro.md:5
#, fuzzy
msgid ""
"Design patterns that ease the design by identifying a simple way to realize "
"relationships among entities."
msgstr ""
"> Design patterns that ease the design by identifying a simple way to "
"realize relationships\n"
"> among entities.\n"
"> (エンティティ間の関係を表現するシンプルな方法を特定することで、設計を容易に"
"するデザインパターン。)"

#: src/patterns/structural/compose-structs.md:1
#, fuzzy
msgid "Struct decomposition for independent borrowing"
msgstr "# 個別借用のための構造体の分解"

#: src/patterns/structural/compose-structs.md:5
#, fuzzy
msgid ""
"Sometimes a large struct will cause issues with the borrow checker - "
"although fields can be borrowed independently, sometimes the whole struct "
"ends up being used at once, preventing other uses. A solution might be to "
"decompose the struct into several smaller structs. Then compose these "
"together into the original struct. Then each struct can be borrowed "
"separately and have more flexible behaviour."
msgstr ""
"大きな構造体では、借用チェッカーにて問題が発生することがあります - \n"
"フィールドを個別に借用できますが、同時に構造体全体が使用されてしまうことにな"
"り、他の使用を妨げることがあります。\n"
"解決策としては、構造体を複数の小さな構造体に分解することです。それから、これ"
"らを元の構造体にまとめます。\n"
"そうすれば、各構造体を個別に借用でき、より柔軟な操作が可能になります。"

#: src/patterns/structural/compose-structs.md:12
#, fuzzy
msgid ""
"This will often lead to a better design in other ways: applying this design "
"pattern often reveals smaller units of functionality."
msgstr ""
"これは、別の形でより良い設計につながることがあります：このデザインパターンを"
"適用することにより、より小さな機能の単位の存在が明らかになることがあります。"

#: src/patterns/structural/compose-structs.md:17
#, fuzzy
msgid ""
"Here is a contrived example of where the borrow checker foils us in our plan "
"to use a struct:"
msgstr "以下は、借用チェッカーが構造体の利用を妨げ失敗させる、作為的な例です："

#: src/patterns/structural/compose-structs.md:28
#, fuzzy
msgid "\"Connection string: {}\""
msgstr "「接続文字列：{}\""

#: src/patterns/structural/compose-structs.md:29
#, fuzzy
msgid "\"Timeout: {}\""
msgstr "「タイムアウト{}\""

#: src/patterns/structural/compose-structs.md:30
#, fuzzy
msgid "\"Pool size: {}\""
msgstr ""
"```rust\n"
"// Databaseを3つの構造体 ConnectionStringとTimeout、PoolSize として構成しま"
"す。\n"
"// まず、より小さな構造体へ分解します。\n"
"#[derive(Debug, Clone)]\n"
"struct ConnectionString(String);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct Timeout(u32);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct PoolSize(u32);\n"
"\n"
"// そして `Database` を 3つのより小さな構造体により構成し直します。\n"
"struct Database {\n"
"    connection_string: ConnectionString,\n"
"    timeout: Timeout,\n"
"    pool_size: PoolSize,\n"
"}\n"
"\n"
"// print_database は ConnectionString と Timeout 、 Poolsize を代わりに引き受"
"けることが可能になります。\n"
"fn print_database(connection_str: ConnectionString, \n"
"                  timeout: Timeout, \n"
"                  pool_size: PoolSize) {\n"
"    println!(\"Connection string: {:?}\", connection_str);\n"
"    println!(\"Timeout: {:?}\", timeout);\n"
"    println!(\"Pool size: {:?}\", pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    // Database を 3つの構造体にて初期化します。\n"
"    let mut db = Database {\n"
"        connection_string: ConnectionString(\"localhost\".to_string()),\n"
"        timeout: Timeout(30),\n"
"        pool_size: PoolSize(100),\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
"    *connection_string = ConnectionString(\"new string\".to_string());\n"
"}\n"
"```"

#: src/patterns/structural/compose-structs.md:35
#, fuzzy
msgid "\"initial string\""
msgstr "\"初期文字列\""

#: src/patterns/structural/compose-structs.md:41
#, fuzzy
msgid ""
"// Immutable borrow of `db` happens here\n"
"                         // *connection_string = \"new string\"."
"to_string();  // Mutable borrow is used\n"
"                         // here\n"
msgstr ""
"// ここでは `db` の不変借用が行われる。\n"
"                         // *connection_string = \"新しい文字列\"."
"to_string(); // Mutable borrow が使用される\n"
"                         // ここで\n"

#: src/patterns/structural/compose-structs.md:47
#, fuzzy
msgid ""
"We can apply this design pattern and refactor `Database` into three smaller "
"structs, thus solving the borrow checking issue:"
msgstr ""
"このデザインパターンを適用し、`Database`を3つの小さな構造体にリファクタリング"
"します。これにより借用チェッカーの問題を解決します："

#: src/patterns/structural/compose-structs.md:51
#, fuzzy
msgid ""
"// Database is now composed of three structs - ConnectionString, Timeout and "
"PoolSize.\n"
"// Let's decompose it into smaller structs\n"
msgstr ""
"// データベースは現在、ConnectionString、Timeout、PoolSizeの3つの構造体で構成"
"されている。\n"
"// これをより小さな構造体に分解してみよう。\n"

#: src/patterns/structural/compose-structs.md:61
#, fuzzy
msgid "// We then compose these smaller structs back into `Database`\n"
msgstr "// 次に、これらの小さな構造体を `Database` にまとめる。\n"

#: src/patterns/structural/compose-structs.md:68
#, fuzzy
msgid ""
"// print_database can then take ConnectionString, Timeout and Poolsize "
"struct instead\n"
msgstr ""
"// print_database は、代わりに ConnectionString、Timeout、Poolsize 構造体を受"
"け取ることができる。\n"

#: src/patterns/structural/compose-structs.md:71
#, fuzzy
msgid "\"Connection string: {connection_str:?}\""
msgstr "「接続文字列：{connection_str:?}\""

#: src/patterns/structural/compose-structs.md:72
#, fuzzy
msgid "\"Timeout: {timeout:?}\""
msgstr "「タイムアウト{timeout:?}\""

#: src/patterns/structural/compose-structs.md:73
#, fuzzy
msgid "\"Pool size: {pool_size:?}\""
msgstr "「プールサイズ：{pool_size:?}\""

#: src/patterns/structural/compose-structs.md:77
#, fuzzy
msgid "// Initialize the Database with the three structs\n"
msgstr "// 以下の3つの構造体でデータベースを初期化する。\n"

#: src/patterns/structural/compose-structs.md:79
#, fuzzy
msgid "\"localhost\""
msgstr "「ローカルホスト"

#: src/patterns/structural/compose-structs.md:86
#, fuzzy
msgid "\"new string\""
msgstr "「新しい文字列"

#: src/patterns/structural/compose-structs.md:92
#, fuzzy
msgid ""
"This pattern is most useful, when you have a struct that ended up with a lot "
"of fields that you want to borrow independently. Thus having a more flexible "
"behaviour in the end."
msgstr ""
"このパターンは、独立して借用したいフィールドがたくさんある構造体を持っている"
"場合に、最も便利です。\n"
"結果として、最終的にはより柔軟な操作が可能になります。"

#: src/patterns/structural/compose-structs.md:98
#, fuzzy
msgid ""
"Decomposition of structs lets you work around limitations in the borrow "
"checker. And it often produces a better design."
msgstr ""
"構造体の分解は借用チェッカーの制限を回避するのに利用できます。またより良い設"
"計を生み出すこともあります。"

#: src/patterns/structural/compose-structs.md:103
#, fuzzy
msgid ""
"It can lead to more verbose code. And sometimes, the smaller structs are not "
"good abstractions, and so we end up with a worse design. That is probably a "
"'code smell', indicating that the program should be refactored in some way."
msgstr ""
"冗長なコードにつながる可能性があります。またときに、より小さな構造体が良い抽"
"象でなく、より悪い設計になってしまうことがあります。\n"
"これはおそらく「コードの臭い」であり、プログラムを何らかの方法でリファクタす"
"べきことを示しています。"

#: src/patterns/structural/compose-structs.md:109
#, fuzzy
msgid ""
"This pattern is not required in languages that don't have a borrow checker, "
"so in that sense is unique to Rust. However, making smaller units of "
"functionality often leads to cleaner code: a widely acknowledged principle "
"of software engineering, independent of the language."
msgstr ""
"このパターンは、借用チェッカーを持たない言語では必要ありません。\n"
"その意味ではRust独自のものです。\n"
"しかし、機能の単位を小さくすることがクリーンなコードにつながることは、\n"
"ソフトウェア工学の原則として、言語とは関係なく広く認められています。"

#: src/patterns/structural/compose-structs.md:114
#, fuzzy
msgid ""
"This pattern relies on Rust's borrow checker to be able to borrow fields "
"independently of each other. In the example, the borrow checker knows that "
"`a.b` and `a.c` are distinct and can be borrowed independently, it does not "
"try to borrow all of `a`, which would make this pattern useless."
msgstr ""
"このパターンは、Rustの借用チェッカーがフィールドを互いに独立して借用できるこ"
"とに依存しています。\n"
"この例では、借用チェッカーは `a.b` と `a.c` が別個のものであり、独立して借用"
"できることを知っており、\n"
"`a` のすべてを借用しようとはしません。そうでなければ、このパターンは役に立た"
"ないところでした。"

#: src/patterns/structural/small-crates.md:1
#, fuzzy
msgid "Prefer small crates"
msgstr "小さなクレートを好む"

#: src/patterns/structural/small-crates.md:5
msgid "Prefer small crates that do one thing well."
msgstr "1つのことをよく熟す小さな crate をより好みましょう。"

#: src/patterns/structural/small-crates.md:7
#, fuzzy
msgid ""
"Cargo and crates.io make it easy to add third-party libraries, much more so "
"than in say C or C++. Moreover, since packages on crates.io cannot be edited "
"or removed after publication, any build that works now should continue to "
"work in the future. We should take advantage of this tooling, and use "
"smaller, more fine-grained dependencies."
msgstr ""
"cargo と crates.io は、サードパーティーライブラリの追加を、CやC++よりもはるか"
"に簡単なものにします。\n"
"また、crates.io上のパッケージは公開後に編集・削除不可能なため、現在機能してい"
"るビルドは将来も機能し続けるはずです。\n"
"私たちはこのツールを活用し、より小さく、細かな依存関係を使うべきです。"

#: src/patterns/structural/small-crates.md:15
#, fuzzy
msgid "Small crates are easier to understand, and encourage more modular code."
msgstr "小さなクレートは理解しやすく、よりモジュール化されたコードを促進する。"

#: src/patterns/structural/small-crates.md:16
#, fuzzy
msgid ""
"Crates allow for re-using code between projects. For example, the `url` "
"crate was developed as part of the Servo browser engine, but has since found "
"wide use outside the project."
msgstr ""
"- 小さな crate は理解しやすく、よりモジュール化されたコードを促進します。\n"
"- crate はプロジェクト間でのコードの再利用を可能にします。\n"
"  例えば、`url` クレートは Servo ブラウザエンジンの一部として開発されました"
"が、\n"
"  その後プロジェクト外で広く使用されるようになりました。\n"
"- Rustのコンパイル単位は crate であるため、\n"
"  プロジェクトを複数の crate に分割することで、より多くのコードを並列にビルド"
"できるようになります。"

#: src/patterns/structural/small-crates.md:19
#, fuzzy
msgid ""
"Since the compilation unit of Rust is the crate, splitting a project into "
"multiple crates can allow more of the code to be built in parallel."
msgstr ""
"Rustのコンパイル単位はクレートなので、プロジェクトを複数のクレートに分割すれ"
"ば、より多くのコードを並行してビルドできる。"

#: src/patterns/structural/small-crates.md:24
#, fuzzy
msgid ""
"This can lead to \"dependency hell\", when a project depends on multiple "
"conflicting versions of a crate at the same time. For example, the `url` "
"crate has both versions 1.0 and 0.5. Since the `Url` from `url:1.0` and the "
"`Url` from `url:0.5` are different types, an HTTP client that uses `url:0.5` "
"would not accept `Url` values from a web scraper that uses `url:1.0`."
msgstr ""
"- これはプロジェクトが競合するバージョンの複数の crate に依存しているとき、"
"「依存性地獄」につながる可能性があります。\n"
"  例えば、 `url` crate はバージョン 1.0 と 0.5 があります。 `url:1.0` の "
"`Url` と `url:0.5` の `Url` は異なる型であるため、\n"
"  `url:0.5` を使用するHTTPクライアントは、 `url:1.0` を使用するWebスクレイ"
"パーからの `Url` を受け付けません。\n"
"- crates.io のパッケージはキュレーションされていません。\n"
"  crate には作りが甘かったり、ドキュメントが助けにならないものであったり、あ"
"からさまに悪意のあるものもあります。\n"
"- コンパイラはデフォルトでリンク時最適化(LTO)を行わないので、2つの小さなク"
"レートは1つの大きなクレートよりも最適化されていないかもしれません。"

#: src/patterns/structural/small-crates.md:29
#, fuzzy
msgid ""
"Packages on crates.io are not curated. A crate may be poorly written, have "
"unhelpful documentation, or be outright malicious."
msgstr ""
"crates.ioのパッケージはキュレーションされていません。crateの書き方が悪かった"
"り、役に立たないドキュメントがあったり、悪意があったりします。"

#: src/patterns/structural/small-crates.md:31
#, fuzzy
msgid ""
"Two small crates may be less optimized than one large one, since the "
"compiler does not perform link-time optimization (LTO) by default."
msgstr ""
"コンパイラーはデフォルトでリンク時最適化（LTO）を行わないため、2つの小さなク"
"レートは1つの大きなクレートよりも最適化されない可能性がある。"

#: src/patterns/structural/small-crates.md:36
#, fuzzy
msgid ""
"The [`url`](https://crates.io/crates/url) crate provides tools for working "
"with URLs."
msgstr ""
"[`url`](https://crates.io/crates/url) crateはURLを扱うツールを提供します。"

#: src/patterns/structural/small-crates.md:39
#, fuzzy
msgid ""
"The [`num_cpus`](https://crates.io/crates/num_cpus) crate provides a "
"function to query the number of CPUs on a machine."
msgstr ""
"[`num_cpus`](https://crates.io/crates/num_cpus) crate はマシンのCPU数を問い合"
"わせる関数を提供します。"

#: src/patterns/structural/small-crates.md:42
#, fuzzy
msgid ""
"The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions for converting `&T` to `&[T]`. (Historical example)"
msgstr ""
"[`ref_slice`](https://crates.io/crates/ref_slice) crate は `&T` を `&[T]` に"
"変換する関数を提供します(歴史的な例)。"

#: src/patterns/structural/small-crates.md:47
#, fuzzy
msgid "[crates.io: The Rust community crate host](https://crates.io/)"
msgstr "- [crates.io: Rustコミュニティの crate ホスト](https://crates.io/)"

#: src/patterns/structural/unsafe-mods.md:5
#, fuzzy
msgid ""
"If you have `unsafe` code, create the smallest possible module that can "
"uphold the needed invariants to build a minimal safe interface upon the "
"unsafety. Embed this into a larger module that contains only safe code and "
"presents an ergonomic interface. Note that the outer module can contain "
"unsafe functions and methods that call directly into the unsafe code. Users "
"may use this to gain speed benefits."
msgstr ""
"`unsafe` なコードがある場合、安全でないコードの上に最小限の安全なインタフェー"
"スを構築するために、必要な不変性を維持できる可能な限り小さなモジュールを作り"
"ましょう。\n"
"これを安全なコードのみ含む大きなモジュールに組み込み、人間工学的なインタ"
"フェースを提供してください。\n"
"外側のモジュールには unsafe なコードを呼び出す unsafe な関数やメソッドを含め"
"でもよいことに注意してください。\n"
"ユーザはこれを使用して、速度の利点を得ることができます。"

#: src/patterns/structural/unsafe-mods.md:14
#, fuzzy
msgid "This restricts the unsafe code that must be audited"
msgstr "これにより、監査されるべき安全でないコードが制限される。"

#: src/patterns/structural/unsafe-mods.md:15
#, fuzzy
msgid ""
"Writing the outer module is much easier, since you can count on the "
"guarantees of the inner module"
msgstr ""
"- これにより、検査が必要な unsafe なコードが制限されます\n"
"- 内側のモジュールによる保証に頼ることで、外側のモジュールを書くことがずっと"
"簡単になります"

#: src/patterns/structural/unsafe-mods.md:20
#, fuzzy
msgid "Sometimes, it may be hard to find a suitable interface."
msgstr ""
"- 適切なインタフェースを見つけるのが難しい場合もあります。\n"
"- 抽象化が非効率をもたらすかもしれません。"

#: src/patterns/structural/unsafe-mods.md:21
#, fuzzy
msgid "The abstraction may introduce inefficiencies."
msgstr ""
"- 適切なインタフェースを見つけるのが難しい場合もあります。\n"
"- 抽象化が非効率をもたらすかもしれません。"

#: src/patterns/structural/unsafe-mods.md:25
#, fuzzy
msgid ""
"The [`toolshed`](https://docs.rs/toolshed) crate contains its unsafe "
"operations in submodules, presenting a safe interface to users."
msgstr ""
"toolshed`](https://docs.rs/toolshed)クレートは、安全でない操作をサブモジュー"
"ルに含み、ユーザーに安全なインターフェースを提供する。"

#: src/patterns/structural/unsafe-mods.md:27
#, fuzzy
msgid ""
"`std`'s `String` class is a wrapper over `Vec<u8>` with the added invariant "
"that the contents must be valid UTF-8. The operations on `String` ensure "
"this behavior. However, users have the option of using an `unsafe` method to "
"create a `String`, in which case the onus is on them to guarantee the "
"validity of the contents."
msgstr ""
"- [`toolshed`](https://docs.rs/toolshed) crateは、安全でない操作をサブモ"
"ジュールにとじ込めることで、ユーザーに安全なインターフェイスを提供します。\n"
"- `std` の `String` クラスは、その中身が妥当なUTF-8であるという不変性を追加し"
"た `Vec<u8>` のラッパーです。\n"
"  `String` に対する操作はこの振る舞いを保証します。\n"
"  しかし、ユーザが、その内容の妥当性を保証する責任を持つ前提で、 `String` を"
"作成する `unsafe` メソッドを利用する選択肢があります。"

#: src/patterns/structural/unsafe-mods.md:35
#, fuzzy
msgid ""
"[Ralf Jung's Blog about invariants in unsafe code](https://www.ralfj.de/"
"blog/2018/08/22/two-kinds-of-invariants.html)"
msgstr ""
"- [unsafe コードにおける不変性に関する Ralf jung のブログ](https://www.ralfj."
"de/blog/2018/08/22/two-kinds-of-invariants.html)"

#: src/patterns/ffi/intro.md:1
#, fuzzy
msgid "FFI Patterns"
msgstr "# FFI に関するパターン"

#: src/patterns/ffi/intro.md:3
#, fuzzy
msgid ""
"Writing FFI code is an entire course in itself. However, there are several "
"idioms here that can act as pointers, and avoid traps for inexperienced "
"users of unsafe Rust."
msgstr ""
"FFIコードを書くことは、それ自体が1つの課程です。\n"
"しかしながら、ポインタの役割を担い、`unsafe` Rustの経験の浅いユーザーが陥る罠"
"を回避する、いくつかのイディオムがあります。"

#: src/patterns/ffi/intro.md:7
msgid ""
"This section contains design patterns that may be useful when doing FFI."
msgstr "このセクションでは、FFIを行う際に役立つデザインパターンを紹介します。"

#: src/patterns/ffi/intro.md:9
#, fuzzy
msgid ""
"[Object-Based API](./export.md) design that has good memory safety "
"characteristics, and a clean boundary of what is safe and what is unsafe"
msgstr ""
"オブジェクトベースのAPI設計は、メモリ安全性に優れたくさびを記述することを可能"
"にし、`unsafe` なものと安全ななものの境界を明確にするものです。"

#: src/patterns/ffi/intro.md:12
#, fuzzy
msgid ""
"[Type Consolidation into Wrappers](./wrappers.md) - group multiple Rust "
"types together into an opaque \"object\""
msgstr ""
"[型のラッパーへの統合](./wrappers.md) - 複数のRust型を不透明な \"オブジェク"
"ト \"にまとめる。"

#: src/patterns/ffi/export.md:5
#, fuzzy
msgid ""
"When designing APIs in Rust which are exposed to other languages, there are "
"some important design principles which are contrary to normal Rust API "
"design:"
msgstr ""
"Rustにて、他の言語へ公開するAPIを設計する場合、通常のRustのAPI設計に反する重"
"要な設計原則がいくつかあります："

#: src/patterns/ffi/export.md:8
#, fuzzy
msgid ""
"All Encapsulated types should be _owned_ by Rust, _managed_ by the user, and "
"_opaque_."
msgstr ""
"すべてのカプセル化された型は、Rustが所有し、ユーザーが管理し、そしてopaqueで"
"なければならない。"

#: src/patterns/ffi/export.md:10
#, fuzzy
msgid ""
"All Transactional data types should be _owned_ by the user, and "
"_transparent_."
msgstr ""
"すべてのトランザクション・データ型は、ユーザーによって所有され、透過的である"
"べきだ。"

#: src/patterns/ffi/export.md:12
#, fuzzy
msgid ""
"All library behavior should be functions acting upon Encapsulated types."
msgstr ""
"ライブラリの動作はすべて、カプセル化された型に作用する関数でなければならな"
"い。"

#: src/patterns/ffi/export.md:13
#, fuzzy
msgid ""
"All library behavior should be encapsulated into types not based on "
"structure, but _provenance/lifetime_."
msgstr ""
"すべてのライブラリーの動作は、構造ではなく、_provenance/lifetime_に基づく型に"
"カプセル化されるべきである。"

#: src/patterns/ffi/export.md:18
#, fuzzy
msgid ""
"Rust has built-in FFI support to other languages. It does this by providing "
"a way for crate authors to provide C-compatible APIs through different ABIs "
"(though that is unimportant to this practice)."
msgstr ""
"Rustには、他の言語へのFFIサポートが組み込まれています。\n"
"これは、クレート作者が異なるABIを通じてC互換のAPIを提供する方法を提供すること"
"で実現しています（このことは当実践には重要ではありませんが）。"

# foreign API はなんと訳すとそれっぽいのだろう。
# 試しに言語間の、と訳してみる
#: src/patterns/ffi/export.md:22
#, fuzzy
msgid ""
"Well-designed Rust FFI follows C API design principles, while compromising "
"the design in Rust as little as possible. There are three goals with any "
"foreign API:"
msgstr ""
"うまく設計されたRust FFIは、C言語のAPI設計の原則に従いつつ、Rustの設計を可能"
"な限り損なわないようにします。\n"
"言語間のAPIには3つのゴールがあります："

#: src/patterns/ffi/export.md:26
#, fuzzy
msgid "Make it easy to use in the target language."
msgstr "ターゲット言語で使いやすくする。"

#: src/patterns/ffi/export.md:27
#, fuzzy
msgid ""
"Avoid the API dictating internal unsafety on the Rust side as much as "
"possible."
msgstr "APIがRust側の内部的な安全性の欠如を指示することはできるだけ避ける。"

#: src/patterns/ffi/export.md:29
#, fuzzy
msgid ""
"Keep the potential for memory unsafety and Rust `undefined behaviour` as "
"small as possible."
msgstr ""
"メモリが安全でなくなる可能性や、Rustの`未定義の動作`を可能な限り小さくする。"

#: src/patterns/ffi/export.md:32
#, fuzzy
msgid ""
"Rust code must trust the memory safety of the foreign language beyond a "
"certain point. However, every bit of `unsafe` code on the Rust side is an "
"opportunity for bugs, or to exacerbate `undefined behaviour`."
msgstr ""
"Rustコードは、外部言語のメモリ安全性を一定以上信頼しなければなりません。\n"
"しかし、Rust側の `unsafe` コードすべては、バグを発生させたり、 `undefined "
"behaviour` を悪化させるきっかけとなりえます。"

# (Pointer) provenance : (ポインタの)由来
# 同じメモリアドレスを指すポインタを識別することに使用するモノ。コンパイラのVMが認識する情報らしい。コード生成には影響する。この情報は実行時に保持されない。
# https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#pointer-provenance
#: src/patterns/ffi/export.md:36
#, fuzzy
msgid ""
"For example, if a pointer provenance is wrong, that may be a segfault due to "
"invalid memory access. But if it is manipulated by unsafe code, it could "
"become full-blown heap corruption."
msgstr ""
"例えば、ポインタの provenance が間違っている場合、それは無効なメモリアクセス"
"が原因のセグメンテーション違反となりえます。\n"
"しかし、それが unsafe コードによって操作された場合、本格的なヒープ破壊を起こ"
"す可能性があります。"

#: src/patterns/ffi/export.md:40
#, fuzzy
msgid ""
"The Object-Based API design allows for writing shims that have good memory "
"safety characteristics, and a clean boundary of what is safe and what is "
"`unsafe`."
msgstr ""
"オブジェクトベースのAPI設計は、メモリ安全性に優れたくさびを記述することを可能"
"にし、`unsafe` なものと安全ななものの境界を明確にするものです。"

#: src/patterns/ffi/export.md:46
#, fuzzy
msgid ""
"The POSIX standard defines the API to access an on-file database, known as "
"[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/"
"ndbm.h). It is an excellent example of an \"object-based\" API."
msgstr ""
"POSIX標準では、[DBM](https://web.archive.org/web/20210105035602/https://www."
"mankier.com/0p/ndbm.h)として知られるオンファイル・データベースにアクセスする"
"ためのAPIを定義しています。\n"
"これは「オブジェクトベース」APIの優れた例です。"

#: src/patterns/ffi/export.md:50
#, fuzzy
msgid ""
"Here is the definition in C, which hopefully should be easy to read for "
"those involved in FFI. The commentary below should help explain it for those "
"who miss the subtleties."
msgstr ""
"以下はC言語による定義です。FFIに携わっている人には読みやすいと思います。\n"
"以下の解説は、微妙な点を理解し損ねた人のために役立つはずです。"

#: src/patterns/ffi/export.md:69
msgid "This API defines two types: `DBM` and `datum`."
msgstr "このAPIは2つの型を定義しています： `DBM` と `datum` です。"

#: src/patterns/ffi/export.md:71
#, fuzzy
msgid ""
"The `DBM` type was called an \"encapsulated\" type above. It is designed to "
"contain internal state, and acts as an entry point for the library's "
"behavior."
msgstr ""
"`DBM`型は上述した「カプセル化された」型と呼ばれるものです。\n"
"`DBM`型は内部状態を持つように設計されており、ライブラリの操作のエントリポイン"
"トとして振る舞います。"

#: src/patterns/ffi/export.md:74
#, fuzzy
msgid ""
"It is completely opaque to the user, who cannot create a `DBM` themselves "
"since they don't know its size or layout. Instead, they must call "
"`dbm_open`, and that only gives them _a pointer to one_."
msgstr ""
"サイズやレイアウトを知らないので、ユーザは `DBM` 直接作成することができませ"
"ん。\n"
"その代わりに、 `dbm_open` を呼び出す必要があります。そしてこれは _DBMへのポイ"
"ンタ_ を与えてくれるだけです。"

#: src/patterns/ffi/export.md:78
#, fuzzy
msgid ""
"This means all `DBM`s are \"owned\" by the library in a Rust sense. The "
"internal state of unknown size is kept in memory controlled by the library, "
"not the user. The user can only manage its life cycle with `open` and "
"`close`, and perform operations on it with the other functions."
msgstr ""
"これはRust的な感覚で言えば、ライブラリがすべての `DBM` を「所有」している、と"
"いうことになります。\n"
"サイズ不明の内部状態は、ユーザ側ではなく、ライブラリが管理するメモリに保持さ"
"れます。\n"
"ユーザが行えるのは、 `DBM` のライフサイクルを `open` と `close` によって管理"
"し、他の関数によって操作することに限られます。"

#: src/patterns/ffi/export.md:83
#, fuzzy
msgid ""
"The `datum` type was called a \"transactional\" type above. It is designed "
"to facilitate the exchange of information between the library and its user."
msgstr ""
"`datum` 型は上述した 「トランザクション」型と呼ばれるものです。\n"
"これはライブラリと利用者の間の情報交換を容易にするために設計されています。"

#: src/patterns/ffi/export.md:86
#, fuzzy
msgid ""
"The database is designed to store \"unstructured data\", with no pre-defined "
"length or meaning. As a result, the `datum` is the C equivalent of a Rust "
"slice: a bunch of bytes, and a count of how many there are. The main "
"difference is that there is no type information, which is what `void` "
"indicates."
msgstr ""
"データベースは、あらかじめ長さや意味の定義されていない「非構造化データ」を保"
"存するように設計されています。\n"
"その結果、`datum` は C において Rust のスライス - バイトの列であり、その数を"
"カウントされたもの - に相当します。\n"
"主な相違点は、これには型情報がないことです。 `void` はそれを示唆しています。"

#: src/patterns/ffi/export.md:91
#, fuzzy
msgid ""
"Keep in mind that this header is written from the library's point of view. "
"The user likely has some type they are using, which has a known size. But "
"the library does not care, and by the rules of C casting, any type behind a "
"pointer can be cast to `void`."
msgstr ""
"このヘッダーはライブラリーの視点から記述されていることに留意してください。\n"
"ユーザは、サイズが既知である何らかの型を使用しているはずです。\n"
"しかし、ライブラリはそれについて関知しません。またCのキャストの規則では、あら"
"ゆる型を `void` にキャストできます。"

#: src/patterns/ffi/export.md:96
#, fuzzy
msgid ""
"As noted earlier, this type is _transparent_ to the user. But also, this "
"type is _owned_ by the user. This has subtle ramifications, due to that "
"pointer inside it. The question is, who owns the memory that pointer points "
"to?"
msgstr ""
"前述したように、この型はユーザーにとって _透過的_ です。しかし同時に、この型"
"はユーザーによって _所有_ されます。\n"
"このことは、内部にあるポインタによって、微妙な影響を及ぼします。\n"
"問題は、そのポインタが指すメモリは誰のものなのか、ということです。"

#: src/patterns/ffi/export.md:100
#, fuzzy
msgid ""
"The answer for best memory safety is, \"the user\". But in cases such as "
"retrieving a value, the user does not know how to allocate it correctly "
"(since they don't know how long the value is). In this case, the library "
"code is expected to use the heap that the user has access to -- such as the "
"C library `malloc` and `free` -- and then _transfer ownership_ in the Rust "
"sense."
msgstr ""
"最高のメモリ安全性のための答えは「ユーザ」です。\n"
"しかし、値を取得するような場合、ユーザは(値の長さを知らないので)どのように値"
"を正しく割り当ればよいのかわかりません。\n"
"この場合ライブラリのコードには、ユーザがアクセスできるヒープを使用 - Cの "
"`malloc` や `free` のように - し、その語、Rust的の意味での _所有権移転_ を行"
"うことが期待されます。"

#: src/patterns/ffi/export.md:106
#, fuzzy
msgid ""
"This may all seem speculative, but this is what a pointer means in C. It "
"means the same thing as Rust: \"user defined lifetime.\" The user of the "
"library needs to read the documentation in order to use it correctly. That "
"said, there are some decisions that have fewer or greater consequences if "
"users do it wrong. Minimizing those are what this best practice is about, "
"and the key is to _transfer ownership of everything that is transparent_."
msgstr ""
"まったく観念的ですが、これこそがC言語におけるポインタの意味です。\n"
"これはRustにおける「ユーザー定義のライフタイム」と同じ意味です。\n"
"このライブラリのユーザーは、正しく使うためにドキュメントを読む必要がありま"
"す。\n"
"ドキュメントは、ユーザーが間違った使い方をした場合に、\n"
"大小さまざまな悪い結果をもたらす可能性があることについて記載されています。\n"
"それらを最小限にすることが、このベストプラクティスの目的であり、\n"
"_透過的であるものすべての所有権を移転すること_ が鍵なのです。"

#: src/patterns/ffi/export.md:115
#, fuzzy
msgid ""
"This minimizes the number of memory safety guarantees the user must uphold "
"to a relatively small number:"
msgstr ""
"これにより、ユーザが守らなければならないメモリ安全性保証を、比較的少数に抑え"
"ます："

#: src/patterns/ffi/export.md:118
#, fuzzy
msgid ""
"Do not call any function with a pointer not returned by `dbm_open` (invalid "
"access or corruption)."
msgstr ""
"dbm_open`が返していないポインタを持つ関数を呼び出してはならない（無効なアクセ"
"スまたは破損）。"

#: src/patterns/ffi/export.md:120
#, fuzzy
msgid "Do not call any function on a pointer after close (use after free)."
msgstr "close後のポインタに対して関数を呼び出さない（free後に使用する）。"

#: src/patterns/ffi/export.md:121
#, fuzzy
msgid ""
"The `dptr` on any `datum` must be `NULL`, or point to a valid slice of "
"memory at the advertised length."
msgstr ""
"任意の `datum` の `dptr` は `NULL` であるか、指定された長さの有効なメモリスラ"
"イスを指していなければならない。"

#: src/patterns/ffi/export.md:124
#, fuzzy
msgid ""
"In addition, it avoids a lot of pointer provenance issues. To understand "
"why, let us consider an alternative in some depth: key iteration."
msgstr ""
"さらに、ポインタの provenance に関する多くの問題を回避することができます。\n"
"その理由を理解するために、キーの反復という代替案について少し深く検討してみま"
"しょう。"

#: src/patterns/ffi/export.md:127
#, fuzzy
msgid ""
"Rust is well known for its iterators. When implementing one, the programmer "
"makes a separate type with a bounded lifetime to its owner, and implements "
"the `Iterator` trait."
msgstr ""
"Rustはイテレータでよく知られています。\n"
"イテレータを実装する場合、プログラマは、所有型に対しライフタイムが制限された"
"別の型を作成し、 `Iterator` トレイトを実装します。"

#: src/patterns/ffi/export.md:131
msgid "Here is how iteration would be done in Rust for `DBM`:"
msgstr "以下は `DBM` に対して行われ得る Rust での反復処理の方法です："

#: src/patterns/ffi/export.md:149
#, fuzzy
msgid ""
"This is clean, idiomatic, and safe. thanks to Rust's guarantees. However, "
"consider what a straightforward API translation would look like:"
msgstr ""
"これはクリーンでイディオム的で安全です。Rustの保障によるものです。\n"
"しかし、APIの簡素な翻訳がどのようになるかを考えてみましょう："

#: src/patterns/ffi/export.md:155 src/patterns/ffi/export.md:162
#: src/patterns/ffi/export.md:166
#, fuzzy
msgid ""
"// THIS API IS A BAD IDEA! For real applications, use object-based design "
"instead.\n"
msgstr ""
"// このAPIは悪い考えだ！実際のアプリケーションでは、代わりにオブジェクト・"
"ベースの設計を使おう。\n"

#: src/patterns/ffi/export.md:170
#, fuzzy
msgid ""
"This API loses a key piece of information: the lifetime of the iterator must "
"not exceed the lifetime of the `Dbm` object that owns it. A user of the "
"library could use it in a way which causes the iterator to outlive the data "
"it is iterating on, resulting in reading uninitialized memory."
msgstr ""
"このAPIは重要な情報を失っています。それは、イテレータのライフタイムはそれを所"
"有する `Dbm` オブジェクトのライフタイムを超えてはいけない、ということです。\n"
"ライブラリのユーザは反復対象のデータよりも長生きするイテレータを使用してしま"
"う可能性があります。\n"
"その結果、初期化されていないメモリを読み込むことになります。"

#: src/patterns/ffi/export.md:175
msgid ""
"This example written in C contains a bug that will be explained afterwards:"
msgstr "C言語で書かれたこの例には後述するバグがあります："

#: src/patterns/ffi/export.md:179
#, fuzzy
msgid "// DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!\n"
msgstr "// この関数は使用しないでください。微妙だが重大なバグがある！\n"

#: src/patterns/ffi/export.md:189
#, fuzzy
msgid "// an error is indicated by -1\n"
msgstr "// エラーは -1 で示される\n"

#: src/patterns/ffi/export.md:192
#, fuzzy
msgid "// end of the iterator\n"
msgstr "// イテレータの終わり\n"

#: src/patterns/ffi/export.md:204
#, fuzzy
msgid ""
"This bug is a classic. Here's what happens when the iterator returns the end-"
"of-iteration marker:"
msgstr ""
"このバグは古典的なものです。イテレータが反復完了を返したときに起こります："

#: src/patterns/ffi/export.md:207
#, fuzzy
msgid ""
"The loop condition sets `l` to zero, and enters the loop because `0 >= 0`."
msgstr "ループ条件は `l` をゼロに設定し、`0 >= 0` なのでループに入る。"

#: src/patterns/ffi/export.md:208
#, fuzzy
msgid "The length is incremented, in this case by zero."
msgstr "長さはインクリメントされ、この場合はゼロである。"

#: src/patterns/ffi/export.md:209
#, fuzzy
msgid ""
"The if statement is true, so the database is closed. There should be a break "
"statement here."
msgstr ""
"if文は真なので、データベースは閉じられている。ここにbreak文があるはずだ。"

#: src/patterns/ffi/export.md:211
#, fuzzy
msgid ""
"The loop condition executes again, causing a `next` call on the closed "
"object."
msgstr ""
"ループ条件が再び実行され、閉じたオブジェクトに対して `next` が呼び出される。"

#: src/patterns/ffi/export.md:214
#, fuzzy
msgid ""
"The worst part about this bug? If the Rust implementation was careful, this "
"code will work most of the time! If the memory for the `Dbm` object is not "
"immediately reused, an internal check will almost certainly fail, resulting "
"in the iterator returning a `-1` indicating an error. But occasionally, it "
"will cause a segmentation fault, or even worse, nonsensical memory "
"corruption!"
msgstr ""
"このバグで最悪なことはなんでしょう？\n"
"Rustの実装が慎重なものであれば、このコードはほとんどの場合動いてしまいま"
"す！\n"
"もし `Dbm` オブジェクトのメモリがすぐに再利用されなければ、内部チェックはほぼ"
"確実に失敗し、\n"
"イテレータはエラーを示す `-1` を返します。\n"
"しかし、時にはセグメンテーションフォールトを引き起こしたり、さらに悪いことに"
"わけのわからないメモリ破壊を引き起こすこともあります！"

#: src/patterns/ffi/export.md:220
#, fuzzy
msgid ""
"None of this can be avoided by Rust. From its perspective, it put those "
"objects on its heap, returned pointers to them, and gave up control of their "
"lifetimes. The C code simply must \"play nice\"."
msgstr ""
"Rust側はこのどれも避けようがありません。\n"
"Rust側から見れば、オブジェクトをヒープに置き、ポインタを返し、そのライフタイ"
"ムの制御を任せたことになります。\n"
"Cコードが「うまくやる」しかないのです。"

#: src/patterns/ffi/export.md:224
#, fuzzy
msgid ""
"The programmer must read and understand the API documentation. While some "
"consider that par for the course in C, a good API design can mitigate this "
"risk. The POSIX API for `DBM` did this by _consolidating the ownership_ of "
"the iterator with its parent:"
msgstr ""
"プログラマーはAPIドキュメントを読み、理解しなければなりません。\n"
"C言語では当然のことだと考える人もいますが、優れたAPI設計はこのリスクを軽減す"
"ることができます。\n"
"`DBM` の POSIX API ではイテレータの _所有権をその親に統合する_ ことによりこれ"
"を実現しています。"

#: src/patterns/ffi/export.md:234
msgid ""
"Thus, all the lifetimes were bound together, and such unsafety was prevented."
msgstr ""
"こうして、すべてのライフタイムが一つにまとめられ、このような安全性の欠如が予"
"防されています。"

#: src/patterns/ffi/export.md:238
#, fuzzy
msgid ""
"However, this design choice also has a number of drawbacks, which should be "
"considered as well."
msgstr ""
"しかしながら、この設計の選択にはいくつかの欠点があり、十分に検討すべきです。"

#: src/patterns/ffi/export.md:241
#, fuzzy
msgid ""
"First, the API itself becomes less expressive. With POSIX DBM, there is only "
"one iterator per object, and every call changes its state. This is much more "
"restrictive than iterators in almost any language, even though it is safe. "
"Perhaps with other related objects, whose lifetimes are less hierarchical, "
"this limitation is more of a cost than the safety."
msgstr ""
"まず、API自体の表現力が低下します。\n"
"POSIX DBMでは、1つのオブジェクトにつきイテレータは1つしかありません。\n"
"また呼び出しにより状態が変更されます。\n"
"これは、安全であるとはいえ、ほとんどすべての言語のイテレータよりもはるかに制"
"限的なものです。\n"
"おそらく、ライフタイムはそれほど階層的でない他の関連オブジェクトについて"
"は、\n"
"この制限は安全性よりもコストになります。"

#: src/patterns/ffi/export.md:247
#, fuzzy
msgid ""
"Second, depending on the relationships of the API's parts, significant "
"design effort may be involved. Many of the easier design points have other "
"patterns associated with them:"
msgstr ""
"次に、APIの部品の関係によっては、設計に多大な労力が必要になるかもしれませ"
"ん。\n"
"より簡単な設計点の多くには、他のパターンが関係しています："

#: src/patterns/ffi/export.md:251
#, fuzzy
msgid ""
"[Wrapper Type Consolidation](./wrappers.md) groups multiple Rust types "
"together into an opaque \"object\""
msgstr ""
"[ラッパー型の統合](./wrappers.md)は、複数のRust型を不透明な \"オブジェクト "
"\"にまとめる。"

#: src/patterns/ffi/export.md:254
#, fuzzy
msgid ""
"[FFI Error Passing](../../idioms/ffi/errors.md) explains error handling with "
"integer codes and sentinel return values (such as `NULL` pointers)"
msgstr ""
"[FFI Error Passing](../../idioms/ffi/errors.md) では、整数コードとセンチネル"
"戻り値 (`NULL` ポインタなど) を使ったエラー処理について説明しています。"

#: src/patterns/ffi/export.md:257
#, fuzzy
msgid ""
"[Accepting Foreign Strings](../../idioms/ffi/accepting-strings.md) allows "
"accepting strings with minimal unsafe code, and is easier to get right than "
"[Passing Strings to FFI](../../idioms/ffi/passing-strings.md)"
msgstr ""
"- [ラッパーへの型の統合](./wrappers.md)は、複数のRustタイプを不透明な「オブ"
"ジェクト」にまとめます。\n"
"\n"
"- [FFI のエラー処理](../../idioms/ffi/errors.md) では整数コードと番兵の戻り"
"値 (`NULL` ポインタなど) によるエラー処理について説明しています。\n"
"\n"
"- [文字列の受け入れ](../../idioms/ffi/accepting-strings.md) は、安全でない"
"コードを最小限に抑えて文字列を受け入れることができます。\n"
"  [文字列の受け渡し](../../idioms/ffi/passing-strings.md) よりも簡単に正しく"
"できます。"

#: src/patterns/ffi/export.md:261
#, fuzzy
msgid ""
"However, not every API can be done this way. It is up to the best judgement "
"of the programmer as to who their audience is."
msgstr ""
"しかしながら、すべてのAPIがこの方法でできるわけではありません。\n"
"利用者が誰であるか、プログラマの最善の判断次第です。"

#: src/patterns/ffi/wrappers.md:5
#, fuzzy
msgid ""
"This pattern is designed to allow gracefully handling multiple related "
"types, while minimizing the surface area for memory unsafety."
msgstr ""
"このパターンは、メモリ安全性の損なわれる表面面積を最小化しつつ、\n"
"関連する複数の型を優雅に扱えるように設計されています。"

#: src/patterns/ffi/wrappers.md:8
#, fuzzy
msgid ""
"One of the cornerstones of Rust's aliasing rules is lifetimes. This ensures "
"that many patterns of access between types can be memory safe, data race "
"safety included."
msgstr ""
"Rustのエイリアシングルールの基礎の1つはライフタイムです。\n"
"これにより、型間のアクセスの多くのパターン(データ競合の安全性を含む)がメモリ"
"セーフになります。"

#: src/patterns/ffi/wrappers.md:12
#, fuzzy
msgid ""
"However, when Rust types are exported to other languages, they are usually "
"transformed into pointers. In Rust, a pointer means \"the user manages the "
"lifetime of the pointee.\" It is their responsibility to avoid memory "
"unsafety."
msgstr ""
"しかし、Rustの型が他の言語にエクスポートされる場合、通常はポインタに変換され"
"ます。\n"
"Rustでは、ポインタは「ポインタが指すオブジェクトのライフタイムを、ユーザが管"
"理する」ことを意味します。\n"
"メモリの安全性が損なわれないようにすることは、ユーザの責務です。"

#: src/patterns/ffi/wrappers.md:16
#, fuzzy
msgid ""
"Some level of trust in the user code is thus required, notably around use-"
"after-free which Rust can do nothing about. However, some API designs place "
"higher burdens than others on the code written in the other language."
msgstr ""
"そのため、ユーザーコードにはある程度の信頼性が要求されます。Rust ではどうしよ"
"うもない 「使用後にfreeすること」 については特にこの通りです。\n"
"とはいえ、APIの設計によっては、ほかの言語によって記述されたコードと比して、高"
"い負担を強いることがあります。"

#: src/patterns/ffi/wrappers.md:20
#, fuzzy
msgid ""
"The lowest risk API is the \"consolidated wrapper\", where all possible "
"interactions with an object are folded into a \"wrapper type\", while "
"keeping the Rust API clean."
msgstr ""
"最もリスクの低いAPIは「統合ラッパー」です。\n"
"RustのAPIをクリーンに保ちながら、オブジェクトとの間のやりとりはすべて「ラッ"
"パー型」に折り畳むものです。"

#: src/patterns/ffi/wrappers.md:26
#, fuzzy
msgid ""
"To understand this, let us look at a classic example of an API to export: "
"iteration through a collection."
msgstr ""
"これを理解するために、エクスポートするAPIの典型的な例として「コレクションのイ"
"テレーション」を見てみましょう。"

#: src/patterns/ffi/wrappers.md:29
msgid "That API looks like this:"
msgstr "このAPIは以下の通りです："

#: src/patterns/ffi/wrappers.md:31
#, fuzzy
msgid "The iterator is initialized with `first_key`."
msgstr "イテレータは `first_key` で初期化される。"

#: src/patterns/ffi/wrappers.md:32
#, fuzzy
msgid "Each call to `next_key` will advance the iterator."
msgstr "next_key`を呼び出すたびにイテレータが進む。"

#: src/patterns/ffi/wrappers.md:33
#, fuzzy
msgid "Calls to `next_key` if the iterator is at the end will do nothing."
msgstr "イテレータが末尾にある場合、`next_key`を呼んでも何も起こらない。"

#: src/patterns/ffi/wrappers.md:34
#, fuzzy
msgid ""
"As noted above, the iterator is \"wrapped into\" the collection (unlike the "
"native Rust API)."
msgstr ""
"上述したように、反復子は（RustネイティブAPIとは異なり）コレクションに「包まれ"
"る」。"

#: src/patterns/ffi/wrappers.md:37
#, fuzzy
msgid ""
"If the iterator implements `nth()` efficiently, then it is possible to make "
"it ephemeral to each function call:"
msgstr ""
"イテレータが `nth()` を効率的に実装しているならば、\n"
"関数の各呼び出しに対してイテレータを短命なものとすることが可能です。"

#: src/patterns/ffi/wrappers.md:62
msgid "As a result, the wrapper is simple and contains no `unsafe` code."
msgstr "結果、ラッパーはシンプルで、 `unsafe` コードを含みません。"

#: src/patterns/ffi/wrappers.md:66
#, fuzzy
msgid ""
"This makes APIs safer to use, avoiding issues with lifetimes between types. "
"See [Object-Based APIs](./export.md) for more on the advantages and pitfalls "
"this avoids."
msgstr ""
"これにより、APIをより安全に使用できるようになり、型間のライフタイムの問題を避"
"けることができます。\n"
"[オブジェクトベースのAPI](./export.md) には、この利点と、これにより回避できる"
"落とし穴についてさらなる記載があります。"

#: src/patterns/ffi/wrappers.md:72
#, fuzzy
msgid ""
"Often, wrapping types is quite difficult, and sometimes a Rust API "
"compromise would make things easier."
msgstr ""
"多くの場合、型のラッピングは非常に難しいものです。事を簡単にするために Rust "
"API を妥協することになるかもしれません。"

#: src/patterns/ffi/wrappers.md:75
#, fuzzy
msgid ""
"As an example, consider an iterator which does not efficiently implement "
"`nth()`. It would definitely be worth putting in special logic to make the "
"object handle iteration internally, or to support a different access pattern "
"efficiently that only the Foreign Function API will use."
msgstr ""
"例として、`nth()` の実装が効率的でないイテレータを考えてみましょう。\n"
"オブジェクトに内部にて反復を処理するような特殊なロジックを組むことや、\n"
"FFI の API から使用されるためだけに効率的に異なるアクセスパターンをサポートす"
"ること、\n"
"これらには間違いなく価値があります。"

#: src/patterns/ffi/wrappers.md:80
#, fuzzy
msgid "Trying to Wrap Iterators (and Failing)"
msgstr "### イテレータのラップに挑戦(そして失敗)"

#: src/patterns/ffi/wrappers.md:82
#, fuzzy
msgid ""
"To wrap any type of iterator into the API correctly, the wrapper would need "
"to do what a C version of the code would do: erase the lifetime of the "
"iterator, and manage it manually."
msgstr ""
"どのようなタイプのイテレータでもAPIに正しくラップするためには、ラッパーはC"
"バージョンのコードが行うようなことを行う必要があります。つまりイテレータのラ"
"イフタイムを消去し、それを手動で管理することです。"

#: src/patterns/ffi/wrappers.md:86
msgid "Suffice it to say, this is _incredibly_ difficult."
msgstr "言うまでもなく、これは _信じられないほど_ 難しいことです。"

#: src/patterns/ffi/wrappers.md:88
msgid "Here is an illustration of just _one_ pitfall."
msgstr "ここで、 落とし穴をたった _ひとつ_ 、ご紹介しましょう。"

#: src/patterns/ffi/wrappers.md:90
msgid "A first version of `MySetWrapper` would look like this:"
msgstr "最初のバージョンの `MySetWrapper` は次のようになります："

#: src/patterns/ffi/wrappers.md:96
#, fuzzy
msgid "// created from a transmuted Box<KeysIter + 'self>\n"
msgstr "// Box<KeysIter+'self>を変換して作成。\n"

#: src/patterns/ffi/wrappers.md:101
#, fuzzy
msgid ""
"With `transmute` being used to extend a lifetime, and a pointer to hide it, "
"it's ugly already. But it gets even worse: _any other operation can cause "
"Rust `undefined behaviour`_."
msgstr ""
"`transmute` は寿命の延長に使われ、ポインタはそれを隠すのに使われます。\n"
"もうすでに醜いですね。しかし、さらに悪くなります： _他のあらゆる操作がRust "
"の `未定義の動作` を引き起こします_ 。"

#: src/patterns/ffi/wrappers.md:105
#, fuzzy
msgid ""
"Consider that the `MySet` in the wrapper could be manipulated by other "
"functions during iteration, such as storing a new value to the key it was "
"iterating over. The API doesn't discourage this, and in fact some similar C "
"libraries expect it."
msgstr ""
"ラッパー内の `MySet` は、イテレーション中に他の関数によって操作される可能性が"
"あります。\n"
"例えば、イテレーション中に新しい値を格納するなどです。APIはこれを禁じておら"
"ず、実際のところ同様のCライブラリの中にはこれを想定しているものもあります。"

#: src/patterns/ffi/wrappers.md:109
msgid "A simple implementation of `myset_store` would be:"
msgstr "`myset_store` の単純な実装は次のようになります："

#: src/patterns/ffi/wrappers.md:117
#, fuzzy
msgid "// DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.\n"
msgstr ""
"// このコードは使用しないでください。プロルベムのデモは安全ではありません。\n"

#: src/patterns/ffi/wrappers.md:120
#, fuzzy
msgid "// SAFETY: whoops, UB occurs in here!\n"
msgstr "// セーフティ：おっと、ここでUBが発生した！\n"

#: src/patterns/ffi/wrappers.md:124
#, fuzzy
msgid "/* ...check and cast key and value data... */"
msgstr "/* キーと値のデータをチェックし、キャストする。 */"

#: src/patterns/ffi/wrappers.md:134
#, fuzzy
msgid ""
"If the iterator exists when this function is called, we have violated one of "
"Rust's aliasing rules. According to Rust, the mutable reference in this "
"block must have _exclusive_ access to the object. If the iterator simply "
"exists, it's not exclusive, so we have `undefined behaviour`! [^1]"
msgstr ""
"この関数が呼ばれたときにイテレータが存在していた場合、Rustののエイリアシング"
"ルールに違反したことになります。\n"
"Rustによると、このブロック内の可変参照はオブジェクトへの _排他的_ アクセスで"
"なければなりません。\n"
"イテレータが単に存在しているだけで、排他的ではなくなります。よって "
"`undefined behaviour` が発生します!"

#: src/patterns/ffi/wrappers.md:139
#, fuzzy
msgid ""
"To avoid this, we must have a way of ensuring that mutable reference really "
"is exclusive. That basically means clearing out the iterator's shared "
"reference while it exists, and then reconstructing it. In most cases, that "
"will still be less efficient than the C version."
msgstr ""
"これを避けるには、可変参照が本当に排他的であることを保証する方法を持たなけれ"
"ばなりません。\n"
"これは基本的に、イテレータの共有参照が存在する間にそれを消去し、後に再構築す"
"ることを意味します。\n"
"たいていの場合、それでもCのバージョンより効率は悪くなります。"

#: src/patterns/ffi/wrappers.md:144
#, fuzzy
msgid ""
"Some may ask: how can C do this more efficiently? The answer is, it cheats. "
"Rust's aliasing rules are the problem, and C simply ignores them for its "
"pointers. In exchange, it is common to see code that is declared in the "
"manual as \"not thread safe\" under some or all circumstances. In fact, the "
"[GNU C library](https://manpages.debian.org/buster/manpages/attributes.7.en."
"html) has an entire lexicon dedicated to concurrent behavior!"
msgstr ""
"Cではどうすればもっと効率的にできるのか？疑問に思う人もいるでしょう。\n"
"答えは・・・ズルです。Rustのエイリアシングルールが問題なのであり、Cではそのポ"
"インタについてルールを無視します。\n"
"その代わりに、マニュアルで特定の(もしくはすべての)状況にて「スレッドセーフで"
"はない」と宣言されているコードをよく見かけます。\n"
"実際に[GNU Cライブラリ](https://manpages.debian.org/buster/manpages/"
"attributes.7.en.html)には、\n"
"並列動作に特化した用語集があります！"

#: src/patterns/ffi/wrappers.md:151
#, fuzzy
msgid ""
"Rust would rather make everything memory safe all the time, for both safety "
"and optimizations that C code cannot attain. Being denied access to certain "
"shortcuts is the price Rust programmers need to pay."
msgstr ""
"むしろRustは、安全性とCコードでは達成できない最適化の両方を実現するために、す"
"べてを常にメモリセーフにします。\n"
"特定のショートカットへのアクセスを拒否されることは、Rustプログラマが支払う価"
"値のある代償です。"

#: src/patterns/ffi/wrappers.md:155
#, fuzzy
msgid ""
"For the C programmers out there scratching their heads, the iterator need "
"not be read _during_ this code cause the UB. The exclusivity rule also "
"enables compiler optimizations which may cause inconsistent observations by "
"the iterator's shared reference (e.g. stack spills or reordering "
"instructions for efficiency). These observations may happen _any time after_ "
"the mutable reference is created."
msgstr ""
"頭を悩ませているCプログラマーのために言っておくと、UBを引き起こすこのコード中"
"の間に、イテレータを読み出す必要はありません。\n"
"また排他的ルールはコンパイラの一部の最適化を有効にしますが、これはイテレータ"
"の共有参照からみて一貫性のない現象(例えば、スタックの漏洩や、効率化のための命"
"令の並び替え)を引き起こすことがあります。\n"
"このような現象は、 可変参照を生成した後は _いつでも_ 発生する可能性がありま"
"す。"

#: src/anti_patterns/index.md:3
#, fuzzy
msgid ""
"An [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) is a solution "
"to a \"recurring problem that is usually ineffective and risks being highly "
"counterproductive\". Just as valuable as knowing how to solve a problem, is "
"knowing how _not_ to solve it. Anti-patterns give us great counter-examples "
"to consider relative to design patterns. Anti-patterns are not confined to "
"code. For example, a process can be an anti-pattern, too."
msgstr ""
"[アンチパターン](https://en.wikipedia.org/wiki/Anti-pattern)とは\n"
"「通常、効果がなく、大きな逆効果になるリスクのある、頻繁に見られる問題のある"
"こと」に対するソリューションです。\n"
"問題を解決する方法を知ることと同じくらい価値があるのは、問題を解決しない方法"
"を知ることです。\n"
"アンチパターンは、デザインパターンに対して、考慮すべき素晴らしい反例を与えて"
"くれます。\n"
"アンチパターンはコードに限ったことではありません。\n"
"例えば、プロセスもアンチパターンになりえます。"

#: src/anti_patterns/borrow_clone.md:5
#, fuzzy
msgid ""
"The borrow checker prevents Rust users from developing otherwise unsafe code "
"by ensuring that either: only one mutable reference exists, or potentially "
"many but all immutable references exist. If the code written does not hold "
"true to these conditions, this anti-pattern arises when the developer "
"resolves the compiler error by cloning the variable."
msgstr ""
"借用チェッカーは、Rustユーザが安全でないコードを開発することを、次のことを確"
"保することで防ぎます：\n"
"1つだけの可変参照が存在するか、もしくは幾つでもよいがすべて不変である参照が存"
"在すること。\n"
"もし書かれたコードがこれらの条件を満たさない場合に、\n"
"コンパイラのエラーを解決するために開発者が変数のクローンを作成したとき、\n"
"このアンチパターンが発生します。"

#: src/anti_patterns/borrow_clone.md:14
#, fuzzy
msgid "// define any variable\n"
msgstr "// 任意の変数を定義する\n"

#: src/anti_patterns/borrow_clone.md:16
#, fuzzy
msgid "// Borrow `x` -- but clone it first\n"
msgstr "// x` を借りる。\n"

#: src/anti_patterns/borrow_clone.md:19
#, fuzzy
msgid ""
"// without the x.clone() two lines prior, this line would fail on compile "
"as\n"
"// x has been borrowed\n"
"// thanks to x.clone(), x was never borrowed, and this line will run.\n"
msgstr ""
"// 2行前のx.clone()がなければ、この行はコンパイル時に失敗する。\n"
"// x が借用された\n"
"// x.clone()のおかげで、xは借用されなかったので、この行は実行される。\n"

#: src/anti_patterns/borrow_clone.md:23
#, fuzzy
msgid "\"{x}\""
msgstr ""
"```rust\n"
"mod a {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"mod b {\n"
"    // X!(); // 定義されていない\n"
"    macro_rules! X { () => {}; }\n"
"    X!(); // 定義されている\n"
"}\n"
"mod c {\n"
"    // X!(); // 定義されていない\n"
"}\n"
"# fn main() {}\n"
"```"

#: src/anti_patterns/borrow_clone.md:24
#, fuzzy
msgid ""
"// perform some action on the borrow to prevent rust from optimizing this\n"
"//out of existence\n"
msgstr ""
"// サビによる最適化を防ぐために、ボローに対して何らかのアクションを実行す"
"る。\n"
"//存在しない\n"

#: src/anti_patterns/borrow_clone.md:32
#, fuzzy
msgid ""
"It is tempting, particularly for beginners, to use this pattern to resolve "
"confusing issues with the borrow checker. However, there are serious "
"consequences. Using `.clone()` causes a copy of the data to be made. Any "
"changes between the two are not synchronized -- as if two completely "
"separate variables exist."
msgstr ""
"特に初心者の方にとっては、借入チェッカーによるややこしい問題を、このパターン"
"を使って解決したくなるものです。\n"
"しかし、この方法は深刻な悪影響があります。\n"
"`.clone()` を使うと、存在するデータのコピーが作成されます。\n"
"この2つの間の変更は同期されません -- 完全に別の2つの変数が存在することと同じ"
"です。"

#: src/anti_patterns/borrow_clone.md:38
#, fuzzy
msgid ""
"There are special cases -- `Rc<T>` is designed to handle clones "
"intelligently. It internally manages exactly one copy of the data, and "
"cloning it will only clone the reference."
msgstr ""
"特別なケースがあります -- `Rc<T>` はクローンをインテリジェントに扱うように設"
"計されています。\n"
"内部的にデータのコピーを1つだけ持っており、クローンを作成しても参照だけをク"
"ローンします。"

#: src/anti_patterns/borrow_clone.md:42
#, fuzzy
msgid ""
"There is also `Arc<T>` which provides shared ownership of a value of type T "
"that is allocated in the heap. Invoking `.clone()` on `Arc` produces a new "
"`Arc` instance, which points to the same allocation on the heap as the "
"source `Arc`, while increasing a reference count."
msgstr ""
"また、ヒープに確保されたT型の値に対する共有所有権を提供する `Arc<T>` もありま"
"す。\n"
"`Arc` に対して `.clone()` を呼び出すと、新しい `Arc` インスタンスが生成されま"
"すが、\n"
"このインスタンスは元とヒープの同じ値を指しています。また同時に、参照カウンタ"
"がインクリメントされます。"

#: src/anti_patterns/borrow_clone.md:47
#, fuzzy
msgid ""
"In general, clones should be deliberate, with full understanding of the "
"consequences. If a clone is used to make a borrow checker error disappear, "
"that's a good indication this anti-pattern may be in use."
msgstr ""
"一般に、クローンはその影響を十全に理解し、意図的に行われるべきものです。\n"
"もしも借用チェッカーのエラーを消すためにクローンが使われてるなら、それはこの"
"アンチパターンの使われている可能性を示す兆候と言えます。"

#: src/anti_patterns/borrow_clone.md:51
#, fuzzy
msgid ""
"Even though `.clone()` is an indication of a bad pattern, sometimes **it is "
"fine to write inefficient code**, in cases such as when:"
msgstr ""
"`.clone()` は悪しきパターンの表れですが、ときに **非効率なコードを書いてもよ"
"い** こともあります。\n"
"次のようなケースです："

#: src/anti_patterns/borrow_clone.md:54
#, fuzzy
msgid "the developer is still new to ownership"
msgstr "開発者はまだオーナーになって日が浅い"

#: src/anti_patterns/borrow_clone.md:55
#, fuzzy
msgid ""
"the code doesn't have great speed or memory constraints (like hackathon "
"projects or prototypes)"
msgstr ""
"コードのスピードやメモリに大きな制約がない（ハッカソンプロジェクトやプロトタ"
"イプのように）。"

#: src/anti_patterns/borrow_clone.md:57
#, fuzzy
msgid ""
"satisfying the borrow checker is really complicated, and you prefer to "
"optimize readability over performance"
msgstr ""
"借用チェッカーが本当に複雑で、パフォーマンスよりも読みやすさを最適化したい。"

#: src/anti_patterns/borrow_clone.md:60
#, fuzzy
msgid ""
"If an unnecessary clone is suspected, The [Rust Book's chapter on Ownership]"
"(https://doc.rust-lang.org/book/ownership.html) should be understood fully "
"before assessing whether the clone is required or not."
msgstr ""
"不必要なクローンが疑われる場合、[Rust Book の所有権の章](https://doc.rust-"
"lang.org/book/ownership.html)\n"
"を十分に理解した上で、クローンが必要かどうかを判断してください。"

#: src/anti_patterns/borrow_clone.md:65
#, fuzzy
msgid ""
"Also be sure to always run `cargo clippy` in your project, which will detect "
"some cases in which `.clone()` is not necessary, like [1](https://rust-lang."
"github.io/rust-clippy/master/index.html#redundant_clone), [2](https://rust-"
"lang.github.io/rust-clippy/master/index.html#clone_on_copy), [3](https://"
"rust-lang.github.io/rust-clippy/master/index.html#map_clone) or [4](https://"
"rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref)."
msgstr ""
"また、プロジェクト内で常に `cargo clippy` を実行するようにしてください。\n"
"これは[1](https://rust-lang.github.io/rust-clippy/master/index."
"html#redundant_clone)、\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_on_copy)、\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone)、[4]"
"(https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref)"
"のような `clone()` が不要なケースをいくつか検出します。"

#: src/anti_patterns/borrow_clone.md:74
#, fuzzy
msgid ""
"[`mem::{take(_), replace(_)}` to keep owned values in changed enums](../"
"idioms/mem-replace.md)"
msgstr "# `mem::{take(_), replace(_)}` による値を所有したままの列挙値の変換"

#: src/anti_patterns/borrow_clone.md:75
#, fuzzy
msgid ""
"[`Rc<T>` documentation, which handles .clone() intelligently](http://doc."
"rust-lang.org/std/rc/)"
msgstr ""
"[.clone() をスマートに扱う `Rc<T>` ドキュメント](http://doc.rust-lang.org/"
"std/rc/)"

#: src/anti_patterns/borrow_clone.md:76
#, fuzzy
msgid ""
"[`Arc<T>` documentation, a thread-safe reference-counting pointer](https://"
"doc.rust-lang.org/std/sync/struct.Arc.html)"
msgstr ""
"[スレッドセーフな参照カウントポインタ `Arc<T>` ドキュメント](https://doc."
"rust-lang.org/std/sync/struct.Arc.html)"

#: src/anti_patterns/borrow_clone.md:77
#, fuzzy
msgid ""
"[Tricks with ownership in Rust](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"
msgstr ""
"[Rustにおける所有権のトリック](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"

#: src/anti_patterns/deny-warnings.md:1
#, fuzzy
msgid "`#![deny(warnings)]`"
msgstr "`#[deny(warnings)]`"

#: src/anti_patterns/deny-warnings.md:5
#, fuzzy
msgid ""
"A well-intentioned crate author wants to ensure their code builds without "
"warnings. So they annotate their crate root with the following:"
msgstr ""
"善意のあるcrate作成者は、自分たちのコードが警告なしでビルドされることを保証し"
"たいと考えています。\n"
"そこで、彼らはcrateのルートに次のようなアノテーションを付けます："

#: src/anti_patterns/deny-warnings.md:12
#, fuzzy
msgid "// All is well.\n"
msgstr "// すべて順調だ。\n"

#: src/anti_patterns/deny-warnings.md:18
msgid "It is short and will stop the build if anything is amiss."
msgstr "これは簡単で、もし何か間違いがあるならビルドが止まります。"

#: src/anti_patterns/deny-warnings.md:20
#, fuzzy
msgid "Drawbacks"
msgstr "## デメリット"

#: src/anti_patterns/deny-warnings.md:22
#, fuzzy
msgid ""
"By disallowing the compiler to build with warnings, a crate author opts out "
"of Rust's famed stability. Sometimes new features or old misfeatures need a "
"change in how things are done, thus lints are written that `warn` for a "
"certain grace period before being turned to `deny`."
msgstr ""
"コンパイラが警告付きでビルドすることを禁止することにより、\n"
"Rustの有名な安定性から、crate作成者が切り離されてしまうことになります。\n"
"時に、新しい機能や古い問題ある機能により、物事の進め方を変える必要がでてくる"
"ことがあります。\n"
"このような場合に、lintは十分な一定の期間 `warn` し、その後に `deny` に切り替"
"えるように記述されます。"

#: src/anti_patterns/deny-warnings.md:27
#, fuzzy
msgid ""
"For example, it was discovered that a type could have two `impl`s with the "
"same method. This was deemed a bad idea, but in order to make the transition "
"smooth, the `overlapping-inherent-impls` lint was introduced to give a "
"warning to those stumbling on this fact, before it becomes a hard error in a "
"future release."
msgstr ""
"例えば、ある型が同じメソッドを持つ2つの`impl`を持つことができることが発見され"
"ました。\n"
"これは悪いアイデアだと判断されました。\n"
"しかしスムーズに移行するために、`overlapping-inherent-impls`というlintが導入"
"を導入し、\n"
"将来のリリースで完全なエラーとされる前に、この事実につまずいた人に警告を与え"
"るようにしました。"

#: src/anti_patterns/deny-warnings.md:32
#, fuzzy
msgid ""
"Also sometimes APIs get deprecated, so their use will emit a warning where "
"before there was none."
msgstr ""
"また、APIが非推奨になることもあります。この場合、それを使用していると、今まで"
"無かった警告が出るようになります。"

#: src/anti_patterns/deny-warnings.md:35
msgid ""
"All this conspires to potentially break the build whenever something changes."
msgstr ""
"これらすべてが、何かが変わるたびにビルドを壊してしまう可能性を持っています。"

#: src/anti_patterns/deny-warnings.md:37
#, fuzzy
msgid ""
"Furthermore, crates that supply additional lints (e.g. [rust-clippy](https://"
"github.com/Manishearth/rust-clippy)) can no longer be used unless the "
"annotation is removed. This is mitigated with [\\--cap-lints](https://doc."
"rust-lang.org/rustc/lints/levels.html#capping-lints). The `--cap-lints=warn` "
"command line argument, turns all `deny` lint errors into warnings."
msgstr ""
"さらに、追加のlintを提供するcrate（[rust-clippy]など）は、このアノテーション"
"を削除しない限り使用できなくなりました。\n"
"これは[--cap-lints]で緩和されます。\n"
"コマンドライン引数に `--cap-lints=warn` を指定すると、すべての `deny` lint エ"
"ラーを警告に変えます。"

#: src/anti_patterns/deny-warnings.md:42
#: src/functional/generics-type-classes.md:226
msgid "Alternatives"
msgstr "代替手段"

#: src/anti_patterns/deny-warnings.md:44
#, fuzzy
msgid ""
"There are two ways of tackling this problem: First, we can decouple the "
"build setting from the code, and second, we can name the lints we want to "
"deny explicitly."
msgstr ""
"この問題に対処する方法は2つあります。\n"
"一つは、コードからビルド設定を切り離すことです。\n"
"もう一つは、denyしたい lint を明示的に指定することです。"

#: src/anti_patterns/deny-warnings.md:48
msgid "The following command line will build with all warnings set to `deny`:"
msgstr ""
"次のコマンドラインは、すべての警告を `deny` に設定してビルドを行います："

#: src/anti_patterns/deny-warnings.md:50
msgid "`RUSTFLAGS=\"-D warnings\" cargo build`"
msgstr "`RUSTFLAGS=\"-D warnings\" cargo build`"

#: src/anti_patterns/deny-warnings.md:52
#, fuzzy
msgid ""
"This can be done by any individual developer (or be set in a CI tool like "
"Travis, but remember that this may break the build when something changes) "
"without requiring a change to the code."
msgstr ""
"これは個々の開発者が（あるいはTravisのようなCIツールでも。ただし変更があった"
"ときビルドが壊れる可能性に注意は必要）コードに変更を加えずに行えます。"

#: src/anti_patterns/deny-warnings.md:56
#, fuzzy
msgid ""
"Alternatively, we can specify the lints that we want to `deny` in the code. "
"Here is a list of warning lints that is (hopefully) safe to deny (as of "
"Rustc 1.48.0):"
msgstr ""
"あるいは、コード中で `deny` したいlintを指定することもできます。\n"
"以下は、(たぶん) 安全にdenyできる警告リントのリストです (Rustc 1.48.0 時点)："

#: src/anti_patterns/deny-warnings.md:81
msgid ""
"In addition, the following `allow`ed lints may be a good idea to `deny`:"
msgstr "さらに、以下の`allow`されたリントを`deny`するのはよい考えでしょう："

#: src/anti_patterns/deny-warnings.md:96
msgid "Some may also want to add `missing-copy-implementations` to their list."
msgstr ""
"また、`missing-copy-implementations` をリストに加えたい人もいるでしょう。"

#: src/anti_patterns/deny-warnings.md:98
#, fuzzy
msgid ""
"Note that we explicitly did not add the `deprecated` lint, as it is fairly "
"certain that there will be more deprecated APIs in the future."
msgstr ""
"`deprecated`のlintを明示的に追加していないことに注意してください。\n"
"将来的に非推奨のAPIが増えることは確実だからです。"

#: src/anti_patterns/deny-warnings.md:103
#, fuzzy
msgid ""
"[A collection of all clippy lints](https://rust-lang.github.io/rust-clippy/"
"master)"
msgstr ""
"[クリッピー・リント全集](https://rust-lang.github.io/rust-clippy/master)"

#: src/anti_patterns/deny-warnings.md:104
#, fuzzy
msgid ""
"[deprecate attribute](https://doc.rust-lang.org/reference/attributes."
"html#deprecation) documentation"
msgstr ""
"[非推奨属性](https://doc.rust-lang.org/reference/attributes."
"html#deprecation) ドキュメント"

#: src/anti_patterns/deny-warnings.md:105
#, fuzzy
msgid ""
"Type `rustc -W help` for a list of lints on your system. Also type `rustc --"
"help` for a general list of options"
msgstr ""
"rustc -W help` と入力すると、システム上のリントのリストが表示される。また、"
"`rustc --help` と入力すると、一般的なオプションのリストが表示される。"

#: src/anti_patterns/deny-warnings.md:107
#, fuzzy
msgid ""
"[rust-clippy](https://github.com/Manishearth/rust-clippy) is a collection of "
"lints for better Rust code"
msgstr ""
"[rust-clippy](https://github.com/Manishearth/rust-clippy)は、より良いRustコー"
"ドのためのリントのコレクションである。"

#: src/anti_patterns/deref.md:1
#, fuzzy
msgid "`Deref` polymorphism"
msgstr "# `Deref` ポリモーフィズム"

#: src/anti_patterns/deref.md:5
#, fuzzy
msgid ""
"Misuse the `Deref` trait to emulate inheritance between structs, and thus "
"reuse methods."
msgstr ""
"構造体間の継承をエミュレートする目的での `Deref` トレイトの悪用。これによりメ"
"ソッドを再利用しようとすること。"

#: src/anti_patterns/deref.md:10
#, fuzzy
msgid ""
"Sometimes we want to emulate the following common pattern from OO languages "
"such as Java:"
msgstr ""
"JavaのようなOO言語から、次のような一般的なパターンをエミュレートしたいことが"
"あります："

#: src/anti_patterns/deref.md:26
msgid "We can use the deref polymorphism anti-pattern to do so:"
msgstr "deref ポリモーフィズムのアンチパターンを使い、これを行います："

#: src/anti_patterns/deref.md:56
#, fuzzy
msgid ""
"There is no struct inheritance in Rust. Instead we use composition and "
"include an instance of `Foo` in `Bar` (since the field is a value, it is "
"stored inline, so if there were fields, they would have the same layout in "
"memory as the Java version (probably, you should use `#[repr(C)]` if you "
"want to be sure))."
msgstr ""
"Rustには構造体の継承はありません。\n"
"代わりにコンポジションを使用し、 `Foo` のインスタンスを `Bar` の持ち物にしま"
"す(\n"
"フィールドは値なのでインラインに保持されます。\n"
"したがってフィールドがあるのであれば、それらはJavaのバージョンと同じメモリレ"
"イアウトとなるでしょう(おそらくは。確実にそうしたいなら\n"
"`#[repr(C)]` を使うべきです))。"

#: src/anti_patterns/deref.md:61
#, fuzzy
msgid ""
"In order to make the method call work we implement `Deref` for `Bar` with "
"`Foo` as the target (returning the embedded `Foo` field). That means that "
"when we dereference a `Bar` (for example, using `*`) then we will get a "
"`Foo`. That is pretty weird. Dereferencing usually gives a `T` from a "
"reference to `T`, here we have two unrelated types. However, since the dot "
"operator does implicit dereferencing, it means that the method call will "
"search for methods on `Foo` as well as `Bar`."
msgstr ""
"メソッドコールを機能させるために、`Bar` に対して `Foo` をターゲットとして "
"`Deref` を実装します（埋め込まれた `Foo` フィールドを返します）。\n"
"これは (例えば `*` を使い) `Bar` を参照外しすると、 `Foo` が返されるというこ"
"とになります。\n"
"これはかなり奇怪なことです。\n"
"参照外しは通常 `T` の参照に対して `T` を返します。\n"
"例で扱っているのは２つの関連しない型です。\n"
"しかしながら、ドット演算子は暗黙的な参照外しを行うため、\n"
"メソッド呼び出しは `Bar` に対してと同様に `Foo` のメソッドを検索することにな"
"ります。"

#: src/anti_patterns/deref.md:71
msgid "You save a little boilerplate, e.g.,"
msgstr "ちょっとしたボイラーテンプレートを省けます。例えは、"

#: src/anti_patterns/deref.md:83
#, fuzzy
msgid ""
"Most importantly this is a surprising idiom - future programmers reading "
"this in code will not expect this to happen. That's because we are misusing "
"the `Deref` trait rather than using it as intended (and documented, etc.). "
"It's also because the mechanism here is completely implicit."
msgstr ""
"最も重要なことは、これは人を驚かせるイディオムであるということです - \n"
"コードのこれを読む後のプログラマーは、このようなことが起こるとは思わないで"
"しょう。\n"
"これは私たちが `Deref` トレイトを、その意図(およびドキュメント等)に反して、誤"
"用しているからです。\n"
"またこのメカニズムは完全に暗黙的なものだからです。"

#: src/anti_patterns/deref.md:88
#, fuzzy
msgid ""
"This pattern does not introduce subtyping between `Foo` and `Bar` like "
"inheritance in Java or C++ does. Furthermore, traits implemented by `Foo` "
"are not automatically implemented for `Bar`, so this pattern interacts badly "
"with bounds checking and thus generic programming."
msgstr ""
"このパターンでは、JavaやC++の継承のように`Foo` と `Bar` の間に部分型を導入す"
"ることはありません。\n"
"さらに、 `Foo` で実装された trait は自動的に `Bar` で実装されるわけではありま"
"せん。\n"
"そのため、このパターンは境界チェックと相性が悪くなり、それゆえにジェネリック"
"プログラミングとの相性も悪くなります。"

# 2023/8/20 訳中思考メモ：
# いまいち意味がとれていない。どういうこと？
# (A)ほとんどのOO言語では：
# self (java なら this) は
# 「サブクラスへの参照」？そう？・・・うーん。
# 定義されているクラス、およびそのサブクラスへの参照というならわかる気はする。
# (B)このパターンでは：
# 「メソッドが定義されているクラス」。
# implしたstructで、ここではstructをクラスのように扱おうとしているのだから、ここだけなら、まぁ理解はできるような。
# (A)との対比を考える。
# `Foo` の impl 時の self は あくまで `Foo` である。
# これはパターンの意図するサブタイプ（を deref で模倣したもの)、これを含めた表現になっていない、という感じかな。
# `Bar` が `Foo` のサブタイプもどきのつもりだが、`Foo` の impl 内の self はサブタイプを含めた表現でない。
# これが表にでてくる状況はまずそうそうないんだろう。リフレクションとか出てくると影響しそうではある。
# いずれにせよ、動きだけ模倣して、意味的には異なる状態といのは、危うい。
# 言語仕様的なものと異なる意味を持たせると、理解しにくいだけでなく、言語仕様上の意味を前提にした言語拡張や第三者のライブラリ等々と組み合わせられなくなる。
#: src/anti_patterns/deref.md:93
#, fuzzy
msgid ""
"Using this pattern gives subtly different semantics from most OO languages "
"with regards to `self`. Usually it remains a reference to the sub-class, "
"with this pattern it will be the 'class' where the method is defined."
msgstr ""
"このパターンを使うことは、`self`に関して、ほとんどのOO言語とは微妙に異なるセ"
"マンティクスを与えます。\n"
"通常はこれはサブクラスに対する参照のままですが、このパターンではメソッドが定"
"義されている「クラス」に対するものになります。"

#: src/anti_patterns/deref.md:97
#, fuzzy
msgid ""
"Finally, this pattern only supports single inheritance, and has no notion of "
"interfaces, class-based privacy, or other inheritance-related features. So, "
"it gives an experience that will be subtly surprising to programmers used to "
"Java inheritance, etc."
msgstr ""
"最後に、このパターンは単一継承のみをサポートし、インターフェイス、クラスベー"
"スのプライバシー、\n"
"その他の継承に関連する機能はありません。\n"
"そのためJavaの継承などに慣れているプログラマにとっては、微妙に驚くような経験"
"をすることになります。"

#: src/anti_patterns/deref.md:104
#, fuzzy
msgid ""
"There is no one good alternative. Depending on the exact circumstances it "
"might be better to re-implement using traits or to write out the facade "
"methods to dispatch to `Foo` manually. We do intend to add a mechanism for "
"inheritance similar to this to Rust, but it is likely to be some time before "
"it reaches stable Rust. See these [blog](http://aturon.github.io/"
"blog/2015/09/18/reuse/) [posts](http://smallcultfollowing.com/babysteps/"
"blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/) and "
"this [RFC issue](https://github.com/rust-lang/rfcs/issues/349) for more "
"details."
msgstr ""
"唯一の良い代替案はありません。\n"
"それぞれの状況によっては\n"
"トレイトを再実装するのがよいかもしれませんし、または手動で `Foo` にディスパッ"
"チするファサードメソッドを書くのがよいかもしれません。\n"
"このような継承の仕組みがRustに追加されようとしていますが、しかし安定版の "
"Rust に至るまでに時間がかかりそうです。\n"
"詳細は [blog](http://aturon.github.io/blog/2015/09/18/reuse/)\n"
"[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-"
"structs-part-4-extended-enums-and-thin-traits/)\n"
"や [RFC issue](https://github.com/rust-lang/rfcs/issues/349) \n"
"を参照してください。"

#: src/anti_patterns/deref.md:113
#, fuzzy
msgid ""
"The `Deref` trait is designed for the implementation of custom pointer "
"types. The intention is that it will take a pointer-to-`T` to a `T`, not "
"convert between different types. It is a shame that this isn't (probably "
"cannot be) enforced by the trait definition."
msgstr ""
"`Deref` トレイトはカスタムポインタ型の実装のために設計されています。\n"
"これは、`T` へのポインタを `T` に変換するもので、異なる型間の変換を行うもので"
"はありません。\n"
"このことをトレイトの定義により強制されない（おそらくはできない）のは残念で"
"す。"

#: src/anti_patterns/deref.md:118
#, fuzzy
msgid ""
"Rust tries to strike a careful balance between explicit and implicit "
"mechanisms, favouring explicit conversions between types. Automatic "
"dereferencing in the dot operator is a case where the ergonomics strongly "
"favour an implicit mechanism, but the intention is that this is limited to "
"degrees of indirection, not conversion between arbitrary types."
msgstr ""
"Rustは、明示的なメカニズムと暗黙的なメカニズムのバランスを慎重に取ろうとして"
"います。\n"
"そして型間の変換では明示的な変換を支持しています。\n"
"ドット演算子での自動参照外しは、人間工学的に暗黙的なメカニズムを強く支持する"
"ケースですが、\n"
"これは間接的な程度に限定されており、任意の型間の変換を行うものではありませ"
"ん。"

#: src/anti_patterns/deref.md:126
#, fuzzy
msgid "[Collections are smart pointers idiom](../idioms/deref.md)."
msgstr "# スマートポインタとしてのコレクション"

#: src/anti_patterns/deref.md:127
#, fuzzy
msgid ""
"Delegation crates for less boilerplate like [delegate](https://crates.io/"
"crates/delegate) or [ambassador](https://crates.io/crates/ambassador)"
msgstr ""
"- イディオムの [スマートポインタとしてのコレクション](../idioms/deref.md)。\n"
"- [delegate](https://crates.io/crates/delegate)や[ambassador](https://crates."
"io/crates/ambassador)ような、ボイラーテンプレートを減らすデリゲーション"
"crate。\n"
"- [`Deref` トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."

#: src/functional/index.md:1
#, fuzzy
msgid "Functional Usage of Rust"
msgstr "# Rustので関数型使用法"

#: src/functional/index.md:3
#, fuzzy
msgid ""
"Rust is an imperative language, but it follows many [functional programming]"
"(https://en.wikipedia.org/wiki/Functional_programming) paradigms."
msgstr ""
"Rustは命令型言語ですが、数々の[関数型プログラミング](https://en.wikipedia."
"org/wiki/Functional_programming)\n"
"のパラダイムを模範としています。"

#: src/functional/index.md:7
#, fuzzy
msgid ""
"In computer science, _functional programming_ is a programming paradigm "
"where programs are constructed by applying and composing functions. It is a "
"declarative programming paradigm in which function definitions are trees of "
"expressions that each return a value, rather than a sequence of imperative "
"statements which change the state of the program."
msgstr ""
"> In computer science, _functional programming_ is a programming paradigm "
"where\n"
"> programs are constructed by applying and composing functions.\n"
"> It is a declarative programming paradigm in which function definitions "
"are\n"
"> trees of expressions that each return a value, rather than a sequence of\n"
"> imperative statements which change the state of the program.\n"
"> (コンピュータサイエンスにおいて、関数型プログラミングとは、関数の適用と合成"
"によってプログラムを構成するプログラミングパラダイムです。\n"
"> これは宣言的なプログラミングパラダイムです。その関数の定義は、プログラムの"
"状態を変更する命令文の列ではなく、値を返す式のツリーです。)"

#: src/functional/paradigms.md:3
#, fuzzy
msgid ""
"One of the biggest hurdles to understanding functional programs when coming "
"from an imperative background is the shift in thinking. Imperative programs "
"describe **how** to do something, whereas declarative programs describe "
"**what** to do. Let's sum the numbers from 1 to 10 to show this."
msgstr ""
"関数型プログラミングを理解する上で、命令型プログラミング出身者にとって最大の"
"ハードルのひとつは、考え方の転換です。\n"
"命令型プログラムは **どうやるのか** を記述するのに対し、\n"
"宣言型プログラムは **何をするのか** を記述します。\n"
"これを示すために1から10までの数字を合計してみましょう。"

#: src/functional/paradigms.md:8
#, fuzzy
msgid "Imperative"
msgstr "## 命令型"

#: src/functional/paradigms.md:15
#, fuzzy
msgid "\"{sum}\""
msgstr "\"{sum}\""

#: src/functional/paradigms.md:18
#, fuzzy
msgid ""
"With imperative programs, we have to play compiler to see what is happening. "
"Here, we start with a `sum` of `0`. Next, we iterate through the range from "
"1 to 10. Each time through the loop, we add the corresponding value in the "
"range. Then we print it out."
msgstr ""
"命令型プログラムでは、何が起こっているのかを確認するためにコンパイラを演じな"
"ければなりません。\n"
"ここでは、まず `sum` が `0` から始めます。\n"
"次に、1から10までの範囲を繰り返します。\n"
"ループの各回で、ループ範囲内の対応する値を加算します。\n"
"そして結果を出力します。"

#: src/functional/paradigms.md:23
#, fuzzy
msgid "`i`"
msgstr ""
"```rust\n"
"let mut sum = 0;\n"
"for i in 1..11 {\n"
"    sum += i;\n"
"}\n"
"println!(\"{}\", sum);\n"
"```"

#: src/functional/paradigms.md:23
#, fuzzy
msgid "`sum`"
msgstr "合計"

#: src/functional/paradigms.md:25 src/functional/paradigms.md:59
#: src/functional/paradigms.md:60
msgid "1"
msgstr "1"

#: src/functional/paradigms.md:26 src/functional/paradigms.md:60
msgid "2"
msgstr "2"

#: src/functional/paradigms.md:26 src/functional/paradigms.md:27
#: src/functional/paradigms.md:60 src/functional/paradigms.md:61
msgid "3"
msgstr "3"

#: src/functional/paradigms.md:27 src/functional/paradigms.md:30
#: src/functional/paradigms.md:61 src/functional/paradigms.md:62
#: src/functional/paradigms.md:64
msgid "6"
msgstr "6"

#: src/functional/paradigms.md:28 src/functional/paradigms.md:62
msgid "4"
msgstr "4"

#: src/functional/paradigms.md:28 src/functional/paradigms.md:34
#: src/functional/paradigms.md:62 src/functional/paradigms.md:63
#: src/functional/paradigms.md:68
msgid "10"
msgstr "10"

#: src/functional/paradigms.md:29 src/functional/paradigms.md:63
msgid "5"
msgstr "5"

#: src/functional/paradigms.md:29 src/functional/paradigms.md:63
#: src/functional/paradigms.md:64
msgid "15"
msgstr "15"

#: src/functional/paradigms.md:30 src/functional/paradigms.md:64
#: src/functional/paradigms.md:65
msgid "21"
msgstr "21"

#: src/functional/paradigms.md:31 src/functional/paradigms.md:65
msgid "7"
msgstr "7"

#: src/functional/paradigms.md:31 src/functional/paradigms.md:65
#: src/functional/paradigms.md:66
msgid "28"
msgstr "28"

#: src/functional/paradigms.md:32 src/functional/paradigms.md:66
msgid "8"
msgstr "8"

#: src/functional/paradigms.md:32 src/functional/paradigms.md:66
#: src/functional/paradigms.md:67
msgid "36"
msgstr "36"

#: src/functional/paradigms.md:33 src/functional/paradigms.md:67
msgid "9"
msgstr "9"

#: src/functional/paradigms.md:33 src/functional/paradigms.md:67
#: src/functional/paradigms.md:68
msgid "45"
msgstr "45"

#: src/functional/paradigms.md:34 src/functional/paradigms.md:68
msgid "55"
msgstr "55"

#: src/functional/paradigms.md:36
#, fuzzy
msgid ""
"This is how most of us start out programming. We learn that a program is a "
"set of steps."
msgstr ""
"私たちの多くは、こうしてプログラミングを始めました。\n"
"私たちはプログラムをステップの集まりだと学んできました。"

#: src/functional/paradigms.md:39
#, fuzzy
msgid "Declarative"
msgstr "## 宣言的"

#: src/functional/paradigms.md:42
#, fuzzy
msgid "\"{}\""
msgstr "\"{}\""

#: src/functional/paradigms.md:45
#, fuzzy
msgid ""
"Whoa! This is really different! What's going on here? Remember that with "
"declarative programs we are describing **what** to do, rather than **how** "
"to do it. `fold` is a function that [composes](https://en.wikipedia.org/wiki/"
"Function_composition) functions. The name is a convention from Haskell."
msgstr ""
"おぉ!これは全く異なりますね!何が起こっているのでしょう?\n"
"宣言型プログラムでは、**どうやるのか** ではなく、**何をするのか** を記述して"
"いることに留意してください。\n"
"`fold`は関数を[合成](https://en.wikipedia.org/wiki/Function_composition)する"
"関数です。\n"
"この関数名はHaskellからの慣例です。"

#: src/functional/paradigms.md:51
#, fuzzy
msgid ""
"Here, we are composing functions of addition (this closure: `|a, b| a + b`) "
"with a range from 1 to 10. The `0` is the starting point, so `a` is `0` at "
"first. `b` is the first element of the range, `1`. `0 + 1 = 1` is the "
"result. So now we `fold` again, with `a = 1`, `b = 2` and so `1 + 2 = 3` is "
"the next result. This process continues until we get to the last element in "
"the range, `10`."
msgstr ""
"ここでは、足し算の関数（クロージャ：`|a, b| a + b`）を1から10までの範囲に対し"
"合成しています。\n"
"この `0` は開始点です。よって `a` は最初は `0` です。\n"
"`b` は範囲の最初の要素である `1` です。 `0 + 1 = 1` が結果になります。\n"
"そして `a = 1` 、 `b=2` としてまた `fold` (折り返)し、 `1 + 2 = 3` が次の結果"
"になります。\n"
"このプロセスは範囲の最後の要素である `10` まで繰り返されます。"

#: src/functional/paradigms.md:57
#, fuzzy
msgid "`a`"
msgstr "`a`"

#: src/functional/paradigms.md:57
#, fuzzy
msgid "`b`"
msgstr "`$name ! $arg`; _e.g._ `println!(\"Hi!\")`, `concat!(\"a\", \"b\")`, …"

#: src/functional/paradigms.md:57
msgid "result"
msgstr "件"

#: src/functional/paradigms.md:59
msgid "0"
msgstr "0"

#: src/functional/generics-type-classes.md:5
#, fuzzy
msgid ""
"Rust's type system is designed more like functional languages (like Haskell) "
"rather than imperative languages (like Java and C++). As a result, Rust can "
"turn many kinds of programming problems into \"static typing\" problems. "
"This is one of the biggest wins of choosing a functional language, and is "
"critical to many of Rust's compile time guarantees."
msgstr ""
"Rustの型システムは、(JavaやC++のような)命令型言語ではなく、(Haskellのような)"
"関数型言語のように設計されています。\n"
"その結果、Rustは多くのプログラミング上の問題を「静的型付け」の問題にすること"
"ができます。\n"
"これは関数型言語を選択する最大の利点の1つでありまたRustのコンパイル時保証の多"
"くにとって重要なものです。"

#: src/functional/generics-type-classes.md:11
#, fuzzy
msgid ""
"A key part of this idea is the way generic types work. In C++ and Java, for "
"example, generic types are a meta-programming construct for the compiler. "
"`vector<int>` and `vector<char>` in C++ are just two different copies of the "
"same boilerplate code for a `vector` type (known as a `template`) with two "
"different types filled in."
msgstr ""
"この考え方の重要な部分は、ジェネリック型の動作方法です。\n"
"例えばC++やJavaでは、ジェネリック型はコンパイラのメタプログラミングの構成要素"
"です。\n"
"C++ における `vector<int>` や `vector<char>` は、 `vector` 型のボイラーテンプ"
"レート( `template` として知られるもの ) の\n"
"(それに異なる2つの型を埋め込んだ)異なる2つのコピーにすぎません。"

#: src/functional/generics-type-classes.md:17
#, fuzzy
msgid ""
"In Rust, a generic type parameter creates what is known in functional "
"languages as a \"type class constraint\", and each different parameter "
"filled in by an end user _actually changes the type_. In other words, "
"`Vec<isize>` and `Vec<char>` _are two different types_, which are recognized "
"as distinct by all parts of the type system."
msgstr ""
"Rustでは、ジェネリック型パラメータは関数型言語で「型クラス制約」として知られ"
"ているものを作成します。\n"
"and エンドユーザが埋め込むそれぞれの異なるパラメータは、 _実際に型を変えます"
"_ 。\n"
"言い換えると、 `Vec<isize> と `Vec<char>` は2つの _異なる型_ です。\n"
"これらは型システムのすべての箇所にて、別個の型として認識されます。"

#: src/functional/generics-type-classes.md:23
#, fuzzy
msgid ""
"This is called **monomorphization**, where different types are created from "
"**polymorphic** code. This special behavior requires `impl` blocks to "
"specify generic parameters. Different values for the generic type cause "
"different types, and different types can have different `impl` blocks."
msgstr ""
"これは **モノモーフィズム(単相化)** と呼ばれ、 **ポリモーフィック(多相の)** "
"コードから異なる型が作成されます。\n"
"この特別な振る舞いには、`impl`ブロックにジェネリックパラメータを指定する必要"
"があります。\n"
"ジェネリック型に異なる値を与えれば、異なる型が生成されます。\n"
"そして、異なる型は異なる `impl` ブロックを持つことができます。"

# 2023/8/26 いまいち意味が取れない。
# ---
# OO言語の継承はbehaviorを継承できる。
# でも、「to particular members of a type class」に「additional behavior」 を付加するだけでなく
# 「extra behavior」 も付加しちゃうよ！
# ---
# ・・・これはなんだろ？以下がぱっと思いついたが・・・
# (1)
# BaseClass を SubClass が継承する。
# 継承したかった振る舞いが、BaseClassのメソッドなどで表現されていたら、
# これが SubClassにとっての additinal behavior である。
# そして BaseClass の他の振る舞いは extra behavior である。
# (2)
# BaseClassがすでにある。機能拡張したものが必要だ。
# BaseClassをSubClass に継承させ、SubClassに機能追加を行う。
# これが additinal behavior の付加。
# でもその気になれば、当初その気がなかった別の機能をSubClassに追加できる。
# それが extra behavior 。
# ---
# ここで「additional behavior」の付加についての追加説明である、
# 「to particular members of a type class」を考える。
# ある型クラスの特定のメンバ、というのは BaseClass に対し SubClass を指すように聞こえる。BaseClasssという型の範囲に対し、その一部はSubClassであり、そこにadditinal behaviorを追加する。
# ---
# (1)でいいのかな？ほかのブロックと組み合わせてよんだとき意味がとおるかな・・・
#: src/functional/generics-type-classes.md:28
#, fuzzy
msgid ""
"In object-oriented languages, classes can inherit behavior from their "
"parents. However, this allows the attachment of not only additional behavior "
"to particular members of a type class, but extra behavior as well."
msgstr ""
"オブジェクト指向言語では、クラスは親から振る舞いを継承することができます。\n"
"しかしながらこれは、\n"
"ある型クラスの特定のメンバに対して、\n"
"追加的な振る舞いだけを付加することを可能にするにとどまらず、\n"
"同様に余分な振る舞いを付加することも許容します。"

#: src/functional/generics-type-classes.md:32
#, fuzzy
msgid ""
"The nearest equivalent is the runtime polymorphism in Javascript and Python, "
"where new members can be added to objects willy-nilly by any constructor. "
"However, unlike those languages, all of Rust's additional methods can be "
"type checked when they are used, because their generics are statically "
"defined. That makes them more usable while remaining safe."
msgstr ""
"最も近いのは、JavascriptやPythonのランタイムポリモーフィズムです。\n"
"これらの言語では、あらゆるコンストラクタにより、思ったときにオブジェクトに新"
"しいメンバを追加可能です。\n"
"しかしながら、これらの言語と異なりRustでは、追加されたメソッドは使用時にすべ"
"て型チェックされます。\n"
"なぜなら、それらジェネリックは静的に定義されているからです。\n"
"これはより使いやすく、かつ安全性を確保したものになっています。"

#: src/functional/generics-type-classes.md:40
#, fuzzy
msgid ""
"Suppose you are designing a storage server for a series of lab machines. "
"Because of the software involved, there are two different protocols you need "
"to support: BOOTP (for PXE network boot), and NFS (for remote mount storage)."
msgstr ""
"あなたは、一連のラボマシン用のストレージサーバを設計しているとします。\n"
"関連するソフトウェアのため、次の2つの異なるプロトコルをサポートする必要があり"
"ます：BOOTP（PXEネットワークブート用）とNFS（リモートマウントストレージ用）で"
"す。"

#: src/functional/generics-type-classes.md:44
#, fuzzy
msgid ""
"Your goal is to have one program, written in Rust, which can handle both of "
"them. It will have protocol handlers and listen for both kinds of requests. "
"The main application logic will then allow a lab administrator to configure "
"storage and security controls for the actual files."
msgstr ""
"あなたの目標は、Rustで書かれた1つのプログラムで、その両方を処理できるようにす"
"ることです。\n"
"です。このプログラムは(2つの)プロトコルハンドラを持ち、両方のリクエストを待ち"
"受けます。\n"
"そしてメインのアプリケーションロジックは、ラボの管理者が、実際のファイルのた"
"めの、ストレージとセキュリティ制御を設定できるようにします。"

#: src/functional/generics-type-classes.md:49
#, fuzzy
msgid ""
"The requests from machines in the lab for files contain the same basic "
"information, no matter what protocol they came from: an authentication "
"method, and a file name to retrieve. A straightforward implementation would "
"look something like this:"
msgstr ""
"ラボのマシンからの、ファイルに対してのリクエストは同じ基本情報を含みます。\n"
"どのプロトコルからであっても、認証方法と取得したいファイルの名前はありま"
"す。\n"
"ストレートな実装はこのようになるでしょう："

#: src/functional/generics-type-classes.md:66
#, fuzzy
msgid ""
"This design might work well enough. But now suppose you needed to support "
"adding metadata that was _protocol specific_. For example, with NFS, you "
"wanted to determine what their mount point was in order to enforce "
"additional security rules."
msgstr ""
"この設計は十分に機能するかもしれません。\n"
"しかし、次に _プロトコル固有_ のメタデータの追加をサポートする必要があるとし"
"ます。\n"
"例えば、NFSでは、あなたは追加のセキュリティ規則を実施するために、\n"
"マウントポイントを何にするか決定したいとします。"

#: src/functional/generics-type-classes.md:71
#, fuzzy
msgid ""
"The way the current struct is designed leaves the protocol decision until "
"runtime. That means any method that applies to one protocol and not the "
"other requires the programmer to do a runtime check."
msgstr ""
"現在の構造体の設計では、プロトコルは実行時まで決定されません。\n"
"つまり、一方のプロトコルにて適用されもう一方ではそうしないすべてのメソッドで"
"は、プログラマが実行時チェックを行う必要があります。"

#: src/functional/generics-type-classes.md:75
msgid "Here is how getting an NFS mount point would look:"
msgstr "NFSマウントポイントの取得方法は以下のようになります："

#: src/functional/generics-type-classes.md:85
#, fuzzy
msgid "// ... other methods ...\n"
msgstr "// ... その他のメソッド ...\n"

#: src/functional/generics-type-classes.md:87
#, fuzzy
msgid ""
"/// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
"    /// return None.\n"
msgstr ""
"/// これがNFSリクエストであれば、NFSマウントポイントを取得する。そうでない場"
"合は\n"
"    /// None を返します。\n"

#: src/functional/generics-type-classes.md:95
#, fuzzy
msgid ""
"Every caller of `mount_point()` must check for `None` and write code to "
"handle it. This is true even if they know only NFS requests are ever used in "
"a given code path!"
msgstr ""
"`mount_point()`のすべての呼び出し元は `None` をチェックして、それを処理する"
"コードを書かなければなりません。\n"
"これは、たとえそのコードパス上ではNFS リクエストしか使われないと知っていたと"
"してもです!"

#: src/functional/generics-type-classes.md:99
#, fuzzy
msgid ""
"It would be far more optimal to cause a compile-time error if the different "
"request types were confused. After all, the entire path of the user's code, "
"including what functions from the library they use, will know whether a "
"request is an NFS request or a BOOTP request."
msgstr ""
"もし異なるリクエストタイプが混同されるのであれば、コンパイル時エラーを発生さ"
"せる方がはるかに最適でしょう。\n"
"結局のところ、ユーザのコードパス全体は、\n"
"このライブラリのどの関数を使うかも含め、\n"
"あるリクエストがNFSリクエストかBOOTPリクエストか、わかっていることでしょう。"

#: src/functional/generics-type-classes.md:104
#, fuzzy
msgid ""
"In Rust, this is actually possible! The solution is to _add a generic type_ "
"in order to split the API."
msgstr ""
"Rustでは、実際にこれができます!\n"
"解決策は、APIを分割するために _ジェネリック型を追加_ することです。"

#: src/functional/generics-type-classes.md:107
msgid "Here is what that looks like:"
msgstr "これは以下のようになります："

#: src/functional/generics-type-classes.md:114
#, fuzzy
msgid "// NFS session management omitted\n"
msgstr "// NFSセッション管理は省略\n"

#: src/functional/generics-type-classes.md:118
#, fuzzy
msgid "// no authentication in bootp\n"
msgstr "// ブート時に認証を行わない\n"

#: src/functional/generics-type-classes.md:120
#, fuzzy
msgid ""
"// private module, lest outside users invent their own protocol kinds!\n"
msgstr "// 外部ユーザーが独自のプロトコルを作らないようにするため！\n"

#: src/functional/generics-type-classes.md:149
#, fuzzy
msgid "// no additional metadata\n"
msgstr "// メタデータの追加なし\n"

#: src/functional/generics-type-classes.md:159
#, fuzzy
msgid "// keep internal to prevent impls\n"
msgstr "// インプットを防ぐため、内部に留めておく\n"

#: src/functional/generics-type-classes.md:160
#, fuzzy
msgid "// re-export so callers can see them\n"
msgstr "呼び出し元がそれらを見ることができるように、 // 再エクスポートする。\n"

#: src/functional/generics-type-classes.md:166
#, fuzzy
msgid "// all common API parts go into a generic impl block\n"
msgstr "// すべての共通API部分は、一般的なimplブロックに入る\n"

#: src/functional/generics-type-classes.md:177
#, fuzzy
msgid "// all protocol-specific impls go into their own block\n"
msgstr "// プロトコル固有のインプットはすべて独自のブロックに入れる\n"

#: src/functional/generics-type-classes.md:186
#, fuzzy
msgid "// your code here\n"
msgstr "// ここにコードを記述する\n"

#: src/functional/generics-type-classes.md:190
#, fuzzy
msgid ""
"With this approach, if the user were to make a mistake and use the wrong "
"type;"
msgstr "このアプローチでは、もしユーザが間違えて異なる型を使ってしまったとき；"

#: src/functional/generics-type-classes.md:197
#, fuzzy
msgid "\"/secure\""
msgstr "\"/secure\""

#: src/functional/generics-type-classes.md:197
#, fuzzy
msgid "\"Access denied\""
msgstr "「アクセス拒否"

#: src/functional/generics-type-classes.md:198
#, fuzzy
msgid "// continue on...\n"
msgstr ""
"```rust,ignore\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?;\n"
"    while let Some(request) = socket.next_request()? {\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\"),\n"
"            _ => {} // 続く...\n"
"        }\n"
"        // ここに残りのコード\n"
"    }\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:200
#, fuzzy
msgid "// Rest of the code here\n"
msgstr "// 残りのコードはこちら\n"

#: src/functional/generics-type-classes.md:205
#, fuzzy
msgid ""
"They would get a syntax error. The type `FileDownloadRequest<Bootp>` does "
"not implement `mount_point()`, only the type `FileDownloadRequest<Nfs>` "
"does. And that is created by the NFS module, not the BOOTP module of course!"
msgstr ""
"構文エラーが発生します。\n"
"型 `FileDownloadRequest<Bootp>` は `mount_point()` を実装していません。\n"
"`FileDownloadRequest<Nfs>` 型だけが実装しています。\n"
"またもちろん、これはNFSモジュールによって作成されるもので、BOOTPモジュールに"
"よるって作成されるものではありません!"

#: src/functional/generics-type-classes.md:211
#, fuzzy
msgid ""
"First, it allows fields that are common to multiple states to be de-"
"duplicated. By making the non-shared fields generic, they are implemented "
"once."
msgstr ""
"第一に、複数のステートに共通するフィールドの重複をなくすことができます。\n"
"非共有のフィールドをジェネリックなものにすることで、それらは一度だけ実装され"
"ます。"

#: src/functional/generics-type-classes.md:214
#, fuzzy
msgid ""
"Second, it makes the `impl` blocks easier to read, because they are broken "
"down by state. Methods common to all states are typed once in one block, and "
"methods unique to one state are in a separate block."
msgstr ""
"第二に、状態別に分割されているため、`impl` ブロックが読みやすくなります。\n"
"すべてのステートに共通するメソッドは1つのブロックに1回だけ記述され、あるス"
"テートに固有のメソッドは別のブロックに記述されます。"

#: src/functional/generics-type-classes.md:218
msgid ""
"Both of these mean there are fewer lines of code, and they are better "
"organized."
msgstr "どちらも、コード行数が少なく、整理されているということになります。"

#: src/functional/generics-type-classes.md:222
#, fuzzy
msgid ""
"This currently increases the size of the binary, due to the way "
"monomorphization is implemented in the compiler. Hopefully the "
"implementation will be able to improve in the future."
msgstr ""
"現時点では、コンパイラの単相化の実装方法により、バイナリのサイズが大きくなり"
"ます。\n"
"将来的に実装が改善されることを願っています。"

#: src/functional/generics-type-classes.md:228
#, fuzzy
msgid ""
"If a type seems to need a \"split API\" due to construction or partial "
"initialization, consider the [Builder Pattern](../patterns/creational/"
"builder.md) instead."
msgstr ""
"- 型が、構築や部分的な初期化のために「分割API」を必要とするようであれば、\n"
"  [Builderパターン](../patterns/creational/builder.md)を検討してください。\n"
"\n"
"- 型間のAPIが変化しない場合 -- 振る舞いだけが変化する場合 -- は\n"
"  代わりに[Strategyパターン](../patterns/behavioural/strategy.md)を使うのがよ"
"いでしょう。"

#: src/functional/generics-type-classes.md:232
#, fuzzy
msgid ""
"If the API between types does not change -- only the behavior does -- then "
"the [Strategy Pattern](../patterns/behavioural/strategy.md) is better used "
"instead."
msgstr ""
"- 型が、構築や部分的な初期化のために「分割API」を必要とするようであれば、\n"
"  [Builderパターン](../patterns/creational/builder.md)を検討してください。\n"
"\n"
"- 型間のAPIが変化しない場合 -- 振る舞いだけが変化する場合 -- は\n"
"  代わりに[Strategyパターン](../patterns/behavioural/strategy.md)を使うのがよ"
"いでしょう。"

#: src/functional/generics-type-classes.md:238
msgid "This pattern is used throughout the standard library:"
msgstr "このパターンは標準ライブラリ全体で使われています："

#: src/functional/generics-type-classes.md:240
#, fuzzy
msgid ""
"`Vec<u8>` can be cast from a String, unlike every other type of `Vec<T>`.[^1]"
msgstr ""
"Vec<u8>` は、他のすべての `Vec<T>` の型とは異なり、文字列からキャストすること"
"ができる[^1]。"

#: src/functional/generics-type-classes.md:241
#, fuzzy
msgid ""
"They can also be cast into a binary heap, but only if they contain a type "
"that implements the `Ord` trait.[^2]"
msgstr ""
"バイナリヒープにキャストすることもできるが、`Ord` traitを実装した型を含む場合"
"に限られる[^2]。"

#: src/functional/generics-type-classes.md:243
#, fuzzy
msgid ""
"The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
msgstr "to_string` メソッドは `str` 型の `Cow` のみに特化されていた[^3]。"

#: src/functional/generics-type-classes.md:245
msgid "It is also used by several popular crates to allow API flexibility:"
msgstr ""
"また、APIの柔軟性のために、いくつかの人気のあるクレートで使用されています："

#: src/functional/generics-type-classes.md:247
#, fuzzy
msgid ""
"The `embedded-hal` ecosystem used for embedded devices makes extensive use "
"of this pattern. For example, it allows statically verifying the "
"configuration of device registers used to control embedded pins. When a pin "
"is put into a mode, it returns a `Pin<MODE>` struct, whose generic "
"determines the functions usable in that mode, which are not on the `Pin` "
"itself. [^4]"
msgstr ""
"- 組み込み機器のための `embedded-hal` エコシステムは、このパターンを多用して"
"います。\n"
"  例えば、組み込みのピンの制御に使われるデバイスレジスタの設定を静的に検証す"
"ることができます。\n"
"  ピンがあるモードになると、`Pin<MODE>` 構造体を返します。\n"
"  そのジェネリックはそのモードで使用可能な機能を決定します。 それら機能は "
"`Pin` 自体には実装されません。 [^4]\n"
"\n"
"- HTTPクライアントライブラリ `hyper` は、このパターンを使い、さまざまなプラグ"
"イン可能なリクエストに対して、リッチなAPIを公開しています。\n"
"  異なるコネクタを持つクライアントは、異なるメソッドと異なるトレイト実装を持"
"ちますが、\n"
"  メソッドのコアセットはすべてのコネクタに適用されます。[^5]\n"
"\n"
"- 「Type State」パターン -- 内部状態や不変量に基づいてオブジェクトがAPIを得た"
"り失ったりするパターン -- は、Rustで同じ基本概念と少し異なる手法を使って実装"
"されています。[^6]"

#: src/functional/generics-type-classes.md:253
#, fuzzy
msgid ""
"The `hyper` HTTP client library uses this to expose rich APIs for different "
"pluggable requests. Clients with different connectors have different methods "
"on them as well as different trait implementations, while a core set of "
"methods apply to any connector. [^5]"
msgstr ""
"HTTPクライアントライブラリ `hyper` は、さまざまなプラグイン可能なリクエストの"
"ためのリッチなAPIを公開するためにこれを使用する。異なるコネクタを持つクライア"
"ントは異なるメソッドと異なる trait の実装を持つが、コアとなるメソッドのセット"
"はどのコネクタにも適用される。[^5]"

#: src/functional/generics-type-classes.md:258
#, fuzzy
msgid ""
"The \"type state\" pattern -- where an object gains and loses API based on "
"an internal state or invariant -- is implemented in Rust using the same "
"basic concept, and a slightly different technique. [^6]"
msgstr ""
"オブジェクトが内部状態や不変量に基づいてAPIを得たり失ったりする「型状態」パ"
"ターンは、Rustでも同じ基本概念と少し異なる手法を使って実装されている。[^6]"

#: src/functional/generics-type-classes.md:262
msgid ""
"See: [impl From\\<CString\\> for Vec\\<u8\\>](https://doc.rust-lang."
"org/1.59.0/src/std/ffi/c_str.rs.html#803-811)"
msgstr ""
"参照：[impl From<CString> for Vec<u8>](https://doc.rust-lang.org/1.59.0/src/"
"std/ffi/c_str.rs.html#803-811)"

#: src/functional/generics-type-classes.md:265
#, fuzzy
msgid ""
"See: [impl\\<T: Ord\\> FromIterator\\<T\\> for BinaryHeap\\<T\\>](https://"
"web.archive.org/web/20201030132806/https://doc.rust-lang.org/stable/src/"
"alloc/collections/binary_heap.rs.html#1330-1335)"
msgstr ""
"参照：[impl <T> From<Vec<T, Global>> for BinaryHeap<T>](https://doc.rust-"
"lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354)"

#: src/functional/generics-type-classes.md:268
msgid ""
"See: [impl\\<'\\_\\> ToString for Cow\\<'\\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"
msgstr ""
"参照：[impl <' \\_xxxx ToString for Cow<' \\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"

#: src/functional/generics-type-classes.md:271
#, fuzzy
msgid ""
"Example: [https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/"
"struct.PA0.html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/"
"gpioa/struct.PA0.html)"
msgstr ""
"例：\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0."
"html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct."
"PA0.html)"

#: src/functional/generics-type-classes.md:274
#, fuzzy
msgid ""
"See: [https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://"
"docs.rs/hyper/0.14.5/hyper/client/struct.Client.html)"
msgstr ""
"参照：\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs."
"rs/hyper/0.14.5/hyper/client/struct.Client.html)"

#: src/functional/generics-type-classes.md:277
#, fuzzy
msgid ""
"See: [The Case for the Type State Pattern](https://web.archive.org/"
"web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-"
"typestate-pattern-the-typestate-pattern-itself/) and [Rusty Typestate Series "
"(an extensive thesis)](https://web.archive.org/web/20210328164854/https://"
"rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index)"
msgstr ""
"参照：\n"
"[The Case for the Type State Pattern](https://web.archive.org/"
"web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-"
"typestate-pattern-the-typestate-pattern-itself/)\n"
" および \n"
"[Rusty Typestate Series (広範な論説)](https://web.archive.org/"
"web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-"
"series/rust-typestate-index)"

#: src/functional/optics.md:1
#, fuzzy
msgid "Functional Language Optics"
msgstr "# Rustので関数型使用法"

#: src/functional/optics.md:3
#, fuzzy
msgid ""
"Optics is a type of API design that is common to functional languages. This "
"is a pure functional concept that is not frequently used in Rust."
msgstr ""
"Opticsは、関数型言語に共通するAPI設計の一種である。これは純粋な関数型の概念で"
"あり、Rustではあまり使われない。"

#: src/functional/optics.md:6
#, fuzzy
msgid ""
"Nevertheless, exploring the concept may be helpful to understand other "
"patterns in Rust APIs, such as [visitors](../patterns/behavioural/visitor."
"md). They also have niche use cases."
msgstr ""
"これは純粋な関数型の概念で、Rustではあまり使われません。\n"
"とはいえ、この概念を探求することは、\n"
"[visitors](../patterns/behavioural/visitor.md)のようなRust APIにおける他のパ"
"ターンを理解するのに役立つかもしれません。\n"
"これらのパターンにもニッチなユースケースがあります。"

#: src/functional/optics.md:10
#, fuzzy
msgid ""
"This is quite a large topic, and would require actual books on language "
"design to fully get into its abilities. However their applicability in Rust "
"is much simpler."
msgstr ""
"これは非常に大きなトピックであり、その能力を完全に理解するには、言語設計に関"
"する実際の書籍が必要になるだろう。しかし、Rustでの応用はもっと簡単だ。"

#: src/functional/optics.md:14
#, fuzzy
msgid ""
"To explain the relevant parts of the concept, the `Serde`\\-API will be used "
"as an example, as it is one that is difficult for many to to understand from "
"simply the API documentation."
msgstr "コンセプトの関連部分を説明するために、`Serde`-APIを例として使用する。"

#: src/functional/optics.md:18
#, fuzzy
msgid ""
"In the process, different specific patterns, called Optics, will be covered. "
"These are _The Iso_, _The Poly Iso_, and _The Prism_."
msgstr ""
"その過程で、オプティクスと呼ばれるさまざまな特定のパターンをカバーすることに"
"なる。これらは、_アイソ、_ポリアイソ、_プリズムである。"

#: src/functional/optics.md:21
#, fuzzy
msgid "An API Example: Serde"
msgstr "APIの例：セルデ"

#: src/functional/optics.md:23
#, fuzzy
msgid ""
"Trying to understand the way _Serde_ works by only reading the API is a "
"challenge, especially the first time. Consider the `Deserializer` trait, "
"implemented by any library which parses a new data format:"
msgstr ""
"APIを読むだけで、_Serde_の仕組みを理解しようとするのは難しいことで、特に最初"
"のうちは大変です。\n"
"`Deserializer` トレイトについて考えてみましょう。これは、新しいフォーマットを"
"パースするあらゆるライブラリの中で、なんらかの型に対し実装されるものです："

#: src/functional/optics.md:39 src/functional/optics.md:61
#: src/functional/optics.md:379 src/functional/optics.md:401
#, fuzzy
msgid "// remainder omitted\n"
msgstr "// 余りは省略\n"

#: src/functional/optics.md:43
#, fuzzy
msgid "And here's the definition of the `Visitor` trait passed in generically:"
msgstr ""
"これを理解するためには、lensの概念を念頭に置き、総称的に渡される `Visitor` 型"
"の定義を見てみる必要があります："

#: src/functional/optics.md:65
#, fuzzy
msgid ""
"There is a lot of type erasure going on here, with multiple levels of "
"associated types being passed back and forth."
msgstr ""
"ここでは多くの型消去が行われており、複数のレベルの関連型が行き来している。"

#: src/functional/optics.md:68
#, fuzzy
msgid ""
"But what is the big picture? Why not just have the `Visitor` return the "
"pieces the caller needs in a streaming API, and call it a day? Why all the "
"extra pieces?"
msgstr ""
"しかし、全体像とは何だろう？なぜ`Visitor`がストリーミングAPIで呼び出し元が必"
"要とする部分を返して、それで終わりにしないのか？なぜ余計なことをするのか？"

#: src/functional/optics.md:72
#, fuzzy
msgid ""
"One way to understand it is to look at a functional languages concept called "
"_optics_."
msgstr ""
"これを理解するひとつの方法は、関数型言語の概念である「光学」を見ることだ。"

#: src/functional/optics.md:75
#, fuzzy
msgid ""
"This is a way to do composition of behavior and proprieties that is designed "
"to facilitate patterns common to Rust: failure, type transformation, etc.[^1]"
msgstr ""
"これは、Rustに共通するパターン（失敗、型変換など）を容易にするように設計され"
"た、動作とプロパティの合成を行う方法である[^1]。"

#: src/functional/optics.md:78
#, fuzzy
msgid ""
"The Rust language does not have very good support for these directly. "
"However, they appear in the design of the language itself, and their "
"concepts can help to understand some of Rust's APIs. As a result, this "
"attempts to explain the concepts with the way Rust does it."
msgstr ""
"Rust言語では、これらを直接的にあまりうまくサポートしていない。しかし、Rust言"
"語自体の設計にはこれらの概念が登場し、RustのAPIの一部を理解するのに役立ちま"
"す。そのため、ここではRustの方法でその概念を説明します。"

#: src/functional/optics.md:83
#, fuzzy
msgid ""
"This will perhaps shed light on what those APIs are achieving: specific "
"properties of composability."
msgstr ""
"これはおそらく、それらのAPIが何を達成しているのか、つまりコンポーザビリティの"
"具体的な特性を明らかにするものだろう。"

#: src/functional/optics.md:86
#, fuzzy
msgid "Basic Optics"
msgstr "基本光学"

#: src/functional/optics.md:88
#, fuzzy
msgid "The Iso"
msgstr "磯"

#: src/functional/optics.md:90
#, fuzzy
msgid ""
"The Iso is a value transformer between two types. It is extremely simple, "
"but a conceptually important building block."
msgstr ""
"アイソは、2つのタイプの間の値変換器である。非常にシンプルだが、概念的に重要な"
"構成要素である。"

#: src/functional/optics.md:93
#, fuzzy
msgid ""
"As an example, suppose that we have a custom Hash table structure used as a "
"concordance for a document.[^2] It uses strings for keys (words) and a list "
"of indexes for values (file offsets, for instance)."
msgstr ""
"例として、文書のコンコーダンスとして使用されるカスタム・ハッシュ・テーブル構"
"造があるとする[^2]。キー（単語）には文字列を使用し、値（ファイル・オフセット"
"など）にはインデックスのリストを使用する。"

#: src/functional/optics.md:97
#, fuzzy
msgid ""
"A key feature is the ability to serialize this format to disk. A \"quick and "
"dirty\" approach would be to implement a conversion to and from a string in "
"JSON format. (Errors are ignored for the time being, they will be handled "
"later.)"
msgstr ""
"重要な特徴は、このフォーマットをディスクにシリアライズできることである。手っ"
"取り早く汚い」アプローチは、JSON形式の文字列との変換を実装することだろう。(エ"
"ラーは当面無視され、後で処理される）。"

#: src/functional/optics.md:101
#, fuzzy
msgid "To write it in a normal form expected by functional language users:"
msgstr "関数型言語のユーザーが期待する普通の形式で書くこと："

#: src/functional/optics.md:110
#, fuzzy
msgid ""
"The Iso is thus a pair of functions which convert values of different types: "
"`serialize` and `deserialize`."
msgstr ""
"Isoはこのように、異なる型の値を変換する関数のペアである：シリアライズ`とデシ"
"リアライズ`である。"

#: src/functional/optics.md:113
#, fuzzy
msgid "A straightforward implementation:"
msgstr "わかりやすい実装だ："

#: src/functional/optics.md:129
#, fuzzy
msgid "// invalid concordances are empty\n"
msgstr "// 無効なコンコーダンスが空になる\n"

#: src/functional/optics.md:136
#, fuzzy
msgid ""
"This may seem rather silly. In Rust, this type of behavior is typically done "
"with traits. After all, the standard library has `FromStr` and `ToString` in "
"it."
msgstr ""
"これはかなり馬鹿げていると思われるかもしれない。Rustでは、この種の動作は一般"
"的にtraitで行う。結局のところ、標準ライブラリには `FromStr` と `ToString` が"
"ある。"

#: src/functional/optics.md:139
#, fuzzy
msgid "But that is where our next subject comes in: Poly Isos."
msgstr "しかし、そこで次のテーマが登場する：ポリ・アイソスである。"

#: src/functional/optics.md:141
#, fuzzy
msgid "Poly Isos"
msgstr "ポリ・アイソス"

#: src/functional/optics.md:143
#, fuzzy
msgid ""
"The previous example was simply converting between values of two fixed "
"types. This next block builds upon it with generics, and is more interesting."
msgstr ""
"前の例では、単純に2つの固定型の値を変換しただけだった。この次のブロックは、"
"ジェネリックスを使ってそれをさらに発展させたもので、より興味深いものだ。"

#: src/functional/optics.md:146
#, fuzzy
msgid ""
"Poly Isos allow an operation to be generic over any type while returning a "
"single type."
msgstr ""
"ポリアイソは、単一の型を返しながら、どの型に対しても汎用的な操作を可能にす"
"る。"

#: src/functional/optics.md:149
#, fuzzy
msgid ""
"This brings us closer to parsing. Consider what a basic parser would do "
"ignoring error cases. Again, this is its normal form:"
msgstr ""
"これで構文解析に近づいた。基本的なパーサーがエラー・ケースを無視して何をする"
"か考えてみよう。繰り返すが、これが正規形である："

#: src/functional/optics.md:159
#, fuzzy
msgid "Here we have our first generic, the type `T` being converted."
msgstr "ここでは、最初のジェネリックである `T` 型が変換されている。"

#: src/functional/optics.md:161
#, fuzzy
msgid ""
"In Rust, this could be implemented with a pair of traits in the standard "
"library: `FromStr` and `ToString`. The Rust version even handles errors:"
msgstr ""
"Rustでは、これは標準ライブラリの2つのトレイトで実装できる：FromStr`と"
"`ToString`である。Rustバージョンはエラーも処理する："

#: src/functional/optics.md:176
#, fuzzy
msgid ""
"Unlike the Iso, the Poly Iso allows application of multiple types, and "
"returns them generically. This is what you would want for a basic string "
"parser."
msgstr ""
"Isoとは異なり、Poly Isoは複数の型を適用でき、それらを汎用的に返す。これは、基"
"本的な文字列パーサーに求められるものだ。"

#: src/functional/optics.md:179
#, fuzzy
msgid ""
"At first glance, this seems like a good option for writing a parser. Let's "
"see it in action:"
msgstr ""
"一見したところ、これはパーサーを書くのに良い選択肢のように思える。実際に使っ"
"てみよう："

#: src/functional/optics.md:208 src/functional/optics.md:282
#, fuzzy
msgid "\"hello\""
msgstr "「こんにちは"

#: src/functional/optics.md:210
#, fuzzy
msgid "\"Our Test Struct as JSON: {}\""
msgstr "\"JSONとしてのテスト構造：{}\""

#: src/functional/optics.md:214
#, fuzzy
msgid "That seems quite logical. However, there are two problems with this."
msgstr "それは極めて論理的に思える。しかし、これには2つの問題がある。"

#: src/functional/optics.md:216
#, fuzzy
msgid ""
"First, `to_string` does not indicate to API users, \"this is JSON.\" Every "
"type would need to agree on a JSON representation, and many of the types in "
"the Rust standard library already don't. Using this is a poor fit. This can "
"easily be resolved with our own trait."
msgstr ""
"まず、`to_string`はAPIユーザーに「これはJSONです」と示すことはできない。すべ"
"ての型がJSON表現に同意する必要があるが、Rust標準ライブラリの型の多くはすでに"
"同意していない。これを使用するのは適合性が低い。これは、独自のtraitで簡単に解"
"決できます。"

#: src/functional/optics.md:221
#, fuzzy
msgid "But there is a second, subtler problem: scaling."
msgstr "しかし、2つ目の微妙な問題がある。"

#: src/functional/optics.md:223
#, fuzzy
msgid ""
"When every type writes `to_string` by hand, this works. But if every single "
"person who wants their type to be serializable has to write a bunch of code "
"-- and possibly different JSON libraries -- to do it themselves, it will "
"turn into a mess very quickly!"
msgstr ""
"すべての型が手作業で `to_string` を書く場合、これはうまくいく。しかし、自分の"
"型をシリアライズ可能にしたいすべての人が、それを実現するためにたくさんのコー"
"ドを書かなければならないのであれば、そしておそらく異なるJSONライブラリを書か"
"なければならないのであれば、それはすぐに混乱に変わってしまうだろう！"

#: src/functional/optics.md:228
#, fuzzy
msgid ""
"The answer is one of Serde's two key innovations: an independent data model "
"to represent Rust data in structures common to data serialization languages. "
"The result is that it can use Rust's code generation abilities to create an "
"intermediary conversion type it calls a `Visitor`."
msgstr ""
"その答えは、Serdeの2つの重要なイノベーションの1つ、データ直列化言語に共通する"
"構造でRustデータを表現する独立したデータモデルにある。その結果、Rustのコード"
"生成能力を利用して、`Visitor`と呼ぶ中間的な変換型を作成することができる。"

#: src/functional/optics.md:233
#, fuzzy
msgid ""
"This means, in normal form (again, skipping error handling for simplicity):"
msgstr "つまり、通常の形式では（これも簡単のためにエラー処理は省略する）："

#: src/functional/optics.md:247
#, fuzzy
msgid ""
"The result is one Poly Iso and one Iso (respectively). Both of these can be "
"implemented with traits:"
msgstr ""
"その結果、ポリ・イソとイソがそれぞれ1つずつできる。この2つは、どちらも形質で"
"実装することができる："

#: src/functional/optics.md:263
#, fuzzy
msgid ""
"Because there is a uniform set of rules to transform Rust structures to the "
"independent form, it is even possible to have code generation creating the "
"`Visitor` associated with type `T`:"
msgstr ""
"Rust構造を独立した形に変換するための統一されたルールがあるため、タイプ`T`に関"
"連する`ビジター`を作成するコード生成も可能である："

#: src/functional/optics.md:268
#, fuzzy
msgid "// the \"Serde\" derive creates the trait impl block\n"
msgstr "// Serde \"ディライブはtrait implブロックを作成します。\n"

#: src/functional/optics.md:273
#, fuzzy
msgid "// user writes this macro to generate an associated visitor type\n"
msgstr ""
"// ユーザは、このマクロを記述して、関連するビジターのタイプを生成する。\n"

#: src/functional/optics.md:278
#, fuzzy
msgid "Or do they?"
msgstr ""
"ヒープ上に何もアロケートする必要がありません。\n"
"後で使わないものを初期化する必要もなく、 `File` と `Stdin` の両方で動作するよ"
"うに、続くコード全体を単相化する必要もありません。"

#: src/functional/optics.md:284
#, fuzzy
msgid "\"Our Test Struct as JSON: {a_data}\""
msgstr "\"JSONとしてのテスト構造：{a_data}\""

#: src/functional/optics.md:290
#, fuzzy
msgid ""
"It turns out that the conversion isn't symmetric after all! On paper it is, "
"but with the auto-generated code the name of the actual type necessary to "
"convert all the way from `String` is hidden. We'd need some kind of "
"`generated_visitor_for!` macro to obtain the type name."
msgstr ""
"結局、変換は対称ではないことがわかった！紙の上ではそうなのだが、自動生成され"
"たコードでは `String` からの変換に必要な実際の型名が隠されている。型名を得る"
"ためには、`generated_visitor_for!`マクロのようなものが必要だ。"

#: src/functional/optics.md:295
#, fuzzy
msgid "It's wonky, but it works... until we get to the elephant in the room."
msgstr ""
"この方法は奇妙だが、うまくいっている......部屋の中の象にたどり着くまでは。"

#: src/functional/optics.md:297
#, fuzzy
msgid ""
"The only format currently supported is JSON. How would we support more "
"formats?"
msgstr ""
"現在サポートされているフォーマットはJSONだけです。より多くのフォーマットをサ"
"ポートするにはどうすればよいでしょうか？"

#: src/functional/optics.md:299
#, fuzzy
msgid ""
"The current design requires completely re-writing all of the code generation "
"and creating a new Serde trait. That is quite terrible and not extensible at "
"all!"
msgstr ""
"現在の設計では、すべてのコード生成を完全に書き直し、新しいセルデの特徴を作成"
"する必要があります。これは非常にひどいことで、拡張性はまったくない！"

#: src/functional/optics.md:302
#, fuzzy
msgid "In order to solve that, we need something more powerful."
msgstr "それを解決するには、もっと強力なものが必要だ。"

#: src/functional/optics.md:304
#, fuzzy
msgid "Prism"
msgstr "プリズム"

#: src/functional/optics.md:306
#, fuzzy
msgid ""
"To take format into account, we need something in normal form like this:"
msgstr "形式を考慮するには、次のような正規形が必要だ："

#: src/functional/optics.md:315
#, fuzzy
msgid ""
"This construct is called a Prism. It is \"one level higher\" in generics "
"than Poly Isos (in this case, the \"intersecting\" type F is the key)."
msgstr ""
"この構成体はプリズムと呼ばれる。ジェネリックではポリ・アイソスより「一段上」"
"である（この場合、「交差する」型Fがキーとなる）。"

#: src/functional/optics.md:318
#, fuzzy
msgid ""
"Unfortunately because `Visitor` is a trait (since each incarnation requires "
"its own custom code), this would require a kind of generic type boundary "
"that Rust does not support."
msgstr ""
"残念ながら、`Visitor`は形質なので（それぞれの化身が独自のカスタムコードを必要"
"とするため）、Rustがサポートしていないジェネリックな型境界のようなものが必要"
"になる。"

#: src/functional/optics.md:322
#, fuzzy
msgid ""
"Fortunately, we still have that `Visitor` type from before. What is the "
"`Visitor` doing? It is attempting to allow each data structure to define the "
"way it is itself parsed."
msgstr ""
"幸いなことに、以前からある `Visitor` タイプがまだある。Visitor`は何をしている"
"のか？各データ構造がそれ自身をパースする方法を定義できるようにしようとしてい"
"るのだ。"

#: src/functional/optics.md:326
#, fuzzy
msgid ""
"Well what if we could add one more interface for the generic format? Then "
"the `Visitor` is just an implementation detail, and it would \"bridge\" the "
"two APIs."
msgstr ""
"では、ジェネリック・フォーマット用のインターフェースをもう一つ追加できるとし"
"たらどうだろう？そうすれば、`Visitor`は単なる実装のディテールに過ぎず、2つの"
"APIの「橋渡し」になるだろう。"

#: src/functional/optics.md:329
#, fuzzy
msgid "In normal form:"
msgstr "通常の形である："

#: src/functional/optics.md:348
#, fuzzy
msgid ""
"And what do you know, a pair of Poly Isos at the bottom which can be "
"implemented as traits!"
msgstr "そしてなんと、下部には形質として実装可能なポリアイソのペアがある！"

#: src/functional/optics.md:351
#, fuzzy
msgid "Thus we have the Serde API:"
msgstr "こうしてセルデAPIが完成した："

#: src/functional/optics.md:353
#, fuzzy
msgid ""
"Each type to be serialized implements `Deserialize` or `Serialize`, "
"equivalent to the `Serde` class"
msgstr ""
"シリアライズされる各型は `Deserialize` または `Serialize` を実装している。"

#: src/functional/optics.md:355
#, fuzzy
msgid ""
"They get a type (well two, one for each direction) implementing the "
"`Visitor` trait, which is usually (but not always) done through code "
"generated by a derive macro. This contains the logic to construct or "
"destruct between the data type and the format of the Serde data model."
msgstr ""
"これは通常、deriveマクロによって生成されるコードによって行われる（常に行われ"
"るわけではない）。これには、データ型とSerdeデータモデルのフォーマットとの間で"
"構築または破壊を行うロジックが含まれています。"

#: src/functional/optics.md:359
#, fuzzy
msgid ""
"The type implementing the `Deserializer` trait handles all details specific "
"to the format, being \"driven by\" the `Visitor`."
msgstr ""
"Deserializer`を実装した型は、`Visitor`によって \"駆動 \"されながら、フォー"
"マットに固有のすべての詳細を処理する。"

#: src/functional/optics.md:362
#, fuzzy
msgid ""
"This splitting and Rust type erasure is really to achieve a Prism through "
"indirection."
msgstr ""
"この分割とラスト型の消去は、まさにインダイレクトによってプリズムを実現するた"
"めのものだ。"

#: src/functional/optics.md:365
#, fuzzy
msgid "You can see it on the `Deserializer` trait"
msgstr "これは `Deserializer` 特性で見ることができる。"

#: src/functional/optics.md:383
#, fuzzy
msgid "And the visitor:"
msgstr "そしてお客さん："

#: src/functional/optics.md:405
#, fuzzy
msgid "And the trait `Deserialize` implemented by the macros:"
msgstr "そして、マクロによって実装された `Deserialize` 特性："

#: src/functional/optics.md:415
#, fuzzy
msgid "This has been abstract, so let's look at a concrete example."
msgstr "抽象的な話になったので、具体例を見てみよう。"

#: src/functional/optics.md:417
#, fuzzy
msgid ""
"How does actual Serde deserialize a bit of JSON into `struct Concordance` "
"from earlier?"
msgstr ""
"_Serde_ ライブラリはこのJSONをどのように `struct CreditRecord` にデシリアライ"
"ズするでしょうか？"

#: src/functional/optics.md:420
#, fuzzy
msgid ""
"The user would call a library function to deserialize the data. This would "
"create a `Deserializer` based on the JSON format."
msgstr ""
"ユーザーはライブラリ関数を呼び出してデータをデシリアライズする。これは、JSON"
"フォーマットに基づいて `Deserializer` を作成する。"

#: src/functional/optics.md:422
#, fuzzy
msgid ""
"Based on the fields in the struct, a `Visitor` would be created (more on "
"that in a moment) which knows how to create each type in a generic data "
"model that was needed to represent it: `Vec` (list), `u64` and `String`."
msgstr ""
"構造体のフィールドに基づいて、それを表現するために必要なジェネリックデータモ"
"デルの各タイプ（`Vec`（リスト）、`u64`、`String`）を作成する方法を知っている "
"`Visitor` が作成されます（詳細は後述します）。"

#: src/functional/optics.md:425
#, fuzzy
msgid "The deserializer would make calls to the `Visitor` as it parsed items."
msgstr "デシリアライザーはアイテムをパースするときに `Visitor` を呼び出す。"

#: src/functional/optics.md:426
#, fuzzy
msgid ""
"The `Visitor` would indicate if the items found were expected, and if not, "
"raise an error to indicate deserialization has failed."
msgstr ""
"Visitor`は、見つかったアイテムが期待されたものであるかどうかを示し、もしそう"
"でなければ、デシリアライズに失敗したことを示すエラーを発生させる。"

#: src/functional/optics.md:429
msgid "For our very simple structure above, the expected pattern would be:"
msgstr ""
"上記の非常に単純な構造体の場合、期待されるパターンは次のようになります："

#: src/functional/optics.md:431
#, fuzzy
msgid ""
"Begin visiting a map (_Serde_'s equivalent to `HashMap` or JSON's "
"dictionary)."
msgstr ""
"マップ（_Serde_の`HashMap`やJSONの辞書に相当するもの）にアクセスし始める。"

#: src/functional/optics.md:433
#, fuzzy
msgid "Visit a string key called \"keys\"."
msgstr "keys \"という文字列キーにアクセスする。"

#: src/functional/optics.md:434
#, fuzzy
msgid "Begin visiting a map value."
msgstr "マップの値を訪問し始める。"

#: src/functional/optics.md:435
#, fuzzy
msgid "For each item, visit a string key then an integer value."
msgstr "各項目について、文字列のキーと整数の値を入力する。"

#: src/functional/optics.md:436 src/functional/optics.md:443
#, fuzzy
msgid "Visit the end of the map."
msgstr "地図の最後をご覧ください。"

#: src/functional/optics.md:437
#, fuzzy
msgid "Store the map into the `keys` field of the data structure."
msgstr "マップをデータ構造の `keys` フィールドに格納する。"

#: src/functional/optics.md:438
#, fuzzy
msgid "Visit a string key called \"value_table\"."
msgstr "value_table \"という文字列キーにアクセスする。"

#: src/functional/optics.md:439
#, fuzzy
msgid "Begin visiting a list value."
msgstr "リスト値の訪問を開始する。"

#: src/functional/optics.md:440
#, fuzzy
msgid "For each item, visit an integer."
msgstr "各項目について、整数にアクセスする。"

#: src/functional/optics.md:441
#, fuzzy
msgid "Visit the end of the list"
msgstr "リストの最後へ"

#: src/functional/optics.md:442
#, fuzzy
msgid "Store the list into the `value_table` field."
msgstr "リストを `value_table` フィールドに格納する。"

#: src/functional/optics.md:445
msgid "But what determines which \"observation\" pattern is expected?"
msgstr ""
"しかし、どの「観察」パターンが期待されるかは、何によって決まるのでしょうか？"

#: src/functional/optics.md:447
#, fuzzy
msgid ""
"A functional programming language would be able to use currying to create "
"reflection of each type based on the type itself. Rust does not support "
"that, so every single type would need to have its own code written based on "
"its fields and their properties."
msgstr ""
"関数型プログラミング言語であれば、カリー化を使って、型自体に基づいた各型のリ"
"フレクションを作成できるでしょう。\n"
"Rustはそれをサポートしていないため、すべての型が、そのフィールドとプロパティ"
"に基づいて独自のコードを書く必要があります。"

#: src/functional/optics.md:452
msgid "_Serde_ solves this usability challenge with a derive macro:"
msgstr "_Serde_ はderiveマクロでこの使い勝手の問題を解決します："

#: src/functional/optics.md:464
#, fuzzy
msgid ""
"That macro simply generates an impl block causing the struct to implement a "
"trait called `Deserialize`."
msgstr ""
"このマクロは単に、構造体に `Deserialize` と呼ばれるトレイトを実装させる impl"
"ブロックを生成します。"

#: src/functional/optics.md:467
#, fuzzy
msgid ""
"This is the function that determines how to create the struct itself. Code "
"is generated based on the struct's fields. When the parsing library is "
"called - in our example, a JSON parsing library - it creates a "
"`Deserializer` and calls `Type::deserialize` with it as a parameter."
msgstr ""
"これは、構造体自体の作成方法を決定する関数です。\n"
"コードは構造体のフィールドに基づいて生成されます。\n"
"構文解析ライブラリが呼び出されると(この例では JSON 構文解析ライブラリ)、\n"
"`Deserializer` が作成され、それをパラメータとして `Type::deserialize` が呼び"
"出されます。"

#: src/functional/optics.md:472
#, fuzzy
msgid ""
"The `deserialize` code will then create a `Visitor` which will have its "
"calls \"refracted\" by the `Deserializer`. If everything goes well, "
"eventually that `Visitor` will construct a value corresponding to the type "
"being parsed and return it."
msgstr ""
"そして `deserialize` コードは `Visitor` を作成し、その呼び出しは "
"`Deserializer` によって 「屈折」 されます。\n"
"すべてがうまくいけば、最終的に `Visitor` はパースされた型に対応する値を構築"
"し、それを返します。"

#: src/functional/optics.md:477
msgid ""
"For a complete example, see the [_Serde_ documentation](https://serde.rs/"
"deserialize-struct.html)."
msgstr ""
"完全な例については、[_Serde_ documentation](https://serde.rs/deserialize-"
"struct.html) を参照してください。"

#: src/functional/optics.md:480
#, fuzzy
msgid ""
"The result is that types to be deserialized only implement the \"top layer\" "
"of the API, and file formats only need to implement the \"bottom layer\". "
"Each piece can then \"just work\" with the rest of the ecosystem, since "
"generic types will bridge them."
msgstr ""
"その結果、デシリアライズされる型はAPIの 「トップレイヤー」 のみを実装し、ファ"
"イルフォーマットは 「ボトムレイヤー」 のみを実装すればよいことになります。\n"
"各ピースは残りのエコシステムと、ジェネリック型がそれらの橋渡しをするために、"
"「ただそれだけで動作する」ことができる。"

#: src/functional/optics.md:485
#, fuzzy
msgid ""
"In conclusion, Rust's generic-inspired type system can bring it close to "
"these concepts and use their power, as shown in this API design. But it may "
"also need procedural macros to create bridges for its generics."
msgstr ""
"Rustのもつジェネリックにインスパイアされた型システムは、このAPI設計にて示され"
"ているように、これら概念に近づき、その力を利用することを可能にします\n"
"ただし、このジェネリックの橋渡しをするために、手続き型マクロも必要になる場合"
"があります。"

#: src/functional/optics.md:489
#, fuzzy
msgid ""
"If you are interested in learning more about this topic, please check the "
"following section."
msgstr ""
"このトピックについてもっと知りたい方は、以下のセクションをご覧ください。"

#: src/functional/optics.md:492
msgid "See Also"
msgstr "あわせて読みたい"

#: src/functional/optics.md:494
#, fuzzy
msgid ""
"[lens-rs crate](https://crates.io/crates/lens-rs) for a pre-built lenses "
"implementation, with a cleaner interface than these examples"
msgstr ""
"[lens-rs crate](https://crates.io/crates/lens-rs)には、これらの例よりもすっき"
"りとしたインターフェイスを持つ、あらかじめ組み込まれたレンズの実装がある。"

#: src/functional/optics.md:496
#, fuzzy
msgid ""
"[Serde](https://serde.rs) itself, which makes these concepts intuitive for "
"end users (i.e. defining the structs) without needing to understand the "
"details"
msgstr ""
"[Serde](https://serde.rs)自体が、これらのコンセプトをエンドユーザーにとって直"
"感的なものにしている（つまり、構造体を定義している）ので、詳細を理解する必要"
"はない。"

#: src/functional/optics.md:498
#, fuzzy
msgid ""
"[luminance](https://github.com/phaazon/luminance-rs) is a crate for drawing "
"computer graphics that uses similar API design, including procedural macros "
"to create full prisms for buffers of different pixel types that remain "
"generic"
msgstr ""
"[luminance](https://github.com/phaazon/luminance-rs)は、同様のAPI設計を使用す"
"るコンピュータ・グラフィックス描画用のクレートで、汎用的なまま、異なるピクセ"
"ル・タイプのバッファ用の完全なプリズムを作成する手続き型マクロを含みます。"

#: src/functional/optics.md:501
#, fuzzy
msgid ""
"[An Article about Lenses in Scala](https://web.archive.org/"
"web/20221128185849/https://medium.com/zyseme-technology/functional-"
"references-lens-and-other-optics-in-scala-e5f7e2fdafe) that is very readable "
"even without Scala expertise."
msgstr ""
"[Scalaのレンズに関する記事](https://web.archive.org/web/20221128185849/"
"https://medium.com/zyseme-technology/functional-references-lens-and-other-"
"optics-in-scala-e5f7e2fdafe)は、Scalaの専門知識がなくても非常に読みやすい。"

#: src/functional/optics.md:503
#, fuzzy
msgid ""
"[Paper: Profunctor Optics: Modular Data Accessors](https://web.archive.org/"
"web/20220701102832/https://arxiv.org/ftp/arxiv/papers/1703/1703.10857.pdf)"
msgstr ""
"[論文：プロファンクター・オプティクス：モジュラー・データ・アクセッサ]"
"(https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/arxiv/"
"papers/1703/1703.10857.pdf)"

#: src/functional/optics.md:505
#, fuzzy
msgid ""
"[Musli](https://github.com/udoprog/musli) is a library which attempts to use "
"a similar structure with a different approach, e.g. doing away with the "
"visitor"
msgstr ""
"[Musli](https://github.com/udoprog/musli)は、似たような構造を異なるアプローチ"
"で使おうとするライブラリである。"

#: src/functional/optics.md:508
msgid ""
"[School of Haskell: A Little Lens Starter Tutorial](https://web.archive.org/"
"web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-"
"beyond/pick-of-the-week/a-little-lens-starter-tutorial)"
msgstr ""
"(https://web.archive.org/web/20221128190041/https://www.schoolofhaskell.com/"
"school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-"
"tutorial)"

#: src/functional/optics.md:510
#, fuzzy
msgid ""
"[Concordance on Wikipedia](https://en.wikipedia.org/wiki/"
"Concordance_(publishing))"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/additional_resources/index.md:1
#, fuzzy
msgid "Additional resources"
msgstr "# 追加リソース"

#: src/additional_resources/index.md:3
msgid "A collection of complementary helpful content"
msgstr "補完的なお役立ちコンテンツ集"

#: src/additional_resources/index.md:5
#, fuzzy
msgid "Talks"
msgstr "## トーク"

#: src/additional_resources/index.md:7
#, fuzzy
msgid ""
"[Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by "
"Nicholas Cameron at the PDRust (2016)"
msgstr ""
"[Rustのデザインパターン](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by ニコ"
"ラス・キャメロン at PDRust (2016)"

#: src/additional_resources/index.md:9
#, fuzzy
msgid ""
"[Writing Idiomatic Libraries in Rust](https://www.youtube.com/watch?"
"v=0zOg8_B71gE) by Pascal Hertleif at RustFest (2017)"
msgstr ""
"[Rustでイディオマティックなライブラリを書く](https://www.youtube.com/watch?"
"v=0zOg8_B71gE) by Pascal Hertleif at RustFest (2017)"

#: src/additional_resources/index.md:11
#, fuzzy
msgid ""
"[Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4) "
"by Nicholas Cameron at LinuxConfAu (2018)"
msgstr ""
"[Rustプログラミングテクニック](https://www.youtube.com/watch?v=vqavdUGKeb4) "
"by ニコラス・キャメロン at LinuxConfAu (2018)"

#: src/additional_resources/index.md:14
#, fuzzy
msgid "Books (Online)"
msgstr "## 書籍（オンライン）"

#: src/additional_resources/index.md:16
#, fuzzy
msgid "[The Rust API Guidelines](https://rust-lang.github.io/api-guidelines)"
msgstr ""
"- [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines)"

#: src/additional_resources/design-principles.md:3
#, fuzzy
msgid "A brief overview over common design principles"
msgstr "## 一般的な設計原則の概要"

#: src/additional_resources/design-principles.md:7
#, fuzzy
msgid "[SOLID](https://en.wikipedia.org/wiki/SOLID)"
msgstr "## [SOLID](https://en.wikipedia.org/wiki/SOLID)"

#: src/additional_resources/design-principles.md:9
#, fuzzy
msgid ""
"[Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single-"
"responsibility_principle): A class should only have a single responsibility, "
"that is, only changes to one part of the software's specification should be "
"able to affect the specification of the class."
msgstr ""
"[単一責任原則(SRP)](https://en.wikipedia.org/wiki/Single-"
"responsibility_principle)：つまり、ソフトウェアの仕様の一部分の変更だけが、ク"
"ラスの仕様に影響を与えることができるようにする。"

#: src/additional_resources/design-principles.md:13
#, fuzzy
msgid ""
"[Open/Closed Principle (OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle): \"Software entities ... should be open for "
"extension, but closed for modification.\""
msgstr ""
"[オープン/クローズド原則(OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle)：「ソフトウェアの実体は......拡張に対しては"
"オープンであるべきだが、変更に対してはクローズであるべきである。"

#: src/additional_resources/design-principles.md:16
#, fuzzy
msgid ""
"[Liskov Substitution Principle (LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle): \"Objects in a program should be replaceable "
"with instances of their subtypes without altering the correctness of that "
"program.\""
msgstr ""
"[Liskov Substitution Principle (LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle)：「プログラム中のオブジェクトは、そのプログラ"
"ムの正しさを変えることなく、そのサブタイプのインスタンスに置き換え可能でなけ"
"ればならない。"

#: src/additional_resources/design-principles.md:19
#, fuzzy
msgid ""
"[Interface Segregation Principle (ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle): \"Many client-specific interfaces are "
"better than one general-purpose interface.\""
msgstr ""
"[インターフェース分離の原則(ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle)：\"1つの汎用インターフェースよりも、多くのク"
"ライアント固有のインターフェースの方が優れている\""

#: src/additional_resources/design-principles.md:22
#, fuzzy
msgid ""
"[Dependency Inversion Principle (DIP)](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle): One should \"depend upon abstractions, "
"\\[not\\] concretions.\""
msgstr ""
"[依存性逆転原理（DIP）](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)：人は \"抽象的なもの、具体的なものに依存する "
"\"べきである。"

#: src/additional_resources/design-principles.md:25
#, fuzzy
msgid ""
"[DRY (Don’t Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"
msgstr ""
"## [DRY (Don't Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"

#: src/additional_resources/design-principles.md:27
#, fuzzy
msgid ""
"\"Every piece of knowledge must have a single, unambiguous, authoritative "
"representation within a system\""
msgstr ""
"\"Every piece of knowledge must have a single, unambiguous, authoritative\n"
"representation within a system(すべての知識は、システム内で単一の、曖昧さのな"
"い、権威ある表現を持たなければなりません)\""

#: src/additional_resources/design-principles.md:30
#, fuzzy
msgid "[KISS principle](https://en.wikipedia.org/wiki/KISS_principle)"
msgstr "## [KISSの原則](https://en.wikipedia.org/wiki/KISS_principle)"

#: src/additional_resources/design-principles.md:32
#, fuzzy
msgid ""
"most systems work best if they are kept simple rather than made complicated; "
"therefore, simplicity should be a key goal in design, and unnecessary "
"complexity should be avoided"
msgstr ""
"ほとんどのシステムは、複雑にするよりもシンプルにした方がうまく機能します；\n"
"したがって、シンプルであることが設計の重要な目標であり、不必要な複雑さは避け"
"るべきです"

#: src/additional_resources/design-principles.md:36
#, fuzzy
msgid "[Law of Demeter (LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"
msgstr "## [デメテルの法則(LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"

#: src/additional_resources/design-principles.md:38
#, fuzzy
msgid ""
"a given object should assume as little as possible about the structure or "
"properties of anything else (including its subcomponents), in accordance "
"with the principle of \"information hiding\""
msgstr ""
"あるオブジェクトは、（そのサブコンポーネントを含む）他のものの構造や特性につ"
"いて、できる限り仮定を持たないようにすべきです。\n"
"「情報隠蔽」"

#: src/additional_resources/design-principles.md:42
#, fuzzy
msgid ""
"[Design by contract (DbC)](https://en.wikipedia.org/wiki/Design_by_contract)"
msgstr ""
"## [契約による設計（DbC）](https://en.wikipedia.org/wiki/Design_by_contract)"

#: src/additional_resources/design-principles.md:44
#, fuzzy
msgid ""
"software designers should define formal, precise and verifiable interface "
"specifications for software components, which extend the ordinary definition "
"of abstract data types with preconditions, postconditions and invariants"
msgstr ""
"ソフトウエア設計者は、ソフトウエア構成要素のインターフェイス仕様について、形"
"式的で正確かつ検証可能なものを定義する必要があります。これは抽象データ型の定"
"義を前提条件、後件条件、不変条件により拡張します。"

#: src/additional_resources/design-principles.md:48
#, fuzzy
msgid ""
"[Encapsulation](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"
msgstr ""
"## [カプセル化](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"

#: src/additional_resources/design-principles.md:50
#, fuzzy
msgid ""
"bundling of data with the methods that operate on that data, or the "
"restricting of direct access to some of an object's components. "
"Encapsulation is used to hide the values or state of a structured data "
"object inside a class, preventing unauthorized parties' direct access to "
"them."
msgstr ""
"データとそれを操作するメソッドをひとまとめにしたり、オブジェクトの構成要素へ"
"の直接的なアクセスを制限すること。\n"
"カプセル化はクラス内の構造化されたデータオブジェクトの値や状態を隠蔽し、許可"
"されないものが直接アクセスすることを防ぎます。"

#: src/additional_resources/design-principles.md:55
#, fuzzy
msgid ""
"[Command-Query-Separation(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"
msgstr ""
"## [コマンド-クエリの分離(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"

#: src/additional_resources/design-principles.md:57
#, fuzzy
msgid ""
"“Functions should not produce abstract side effects...only commands "
"(procedures) will be permitted to produce side effects.” - Bertrand Meyer: "
"Object-Oriented Software Construction"
msgstr ""
"“Functions should not produce abstract side effects...only commands\n"
"(procedures) will be permitted to produce side effects.\n"
"(関数は副作用を発生されてはいけません ... \n"
"コマンド(プロシージャ)だけが副作用を発生することを許容されます)”  - Bertrand "
"Meyer: Object-Oriented Software Construction"

#: src/additional_resources/design-principles.md:61
#, fuzzy
msgid ""
"[Principle of least astonishment (POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"
msgstr ""
"## [驚き最小の原則(POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"

#: src/additional_resources/design-principles.md:63
#, fuzzy
msgid ""
"a component of a system should behave in a way that most users will expect "
"it to behave. The behavior should not astonish or surprise users"
msgstr ""
"システムの構成要素はそのユーザが期待するように振舞わねばならず、\n"
"その振る舞いはユーザを驚かせるものであってはなりません"

#: src/additional_resources/design-principles.md:66
#, fuzzy
msgid "Linguistic-Modular-Units"
msgstr "## 言語モジュール単位(Linguistic-Modular-Units)"

#: src/additional_resources/design-principles.md:68
#, fuzzy
msgid ""
"“Modules must correspond to syntactic units in the language used.” - "
"Bertrand Meyer: Object-Oriented Software Construction"
msgstr ""
"\"Modules must correspond to syntactic units in the language used.\n"
"(モジュールは使用言語の構文単位に対応しなければならない)\" - Bertrand\n"
"Meyer: Object-Oriented Software Construction"

#: src/additional_resources/design-principles.md:71
#, fuzzy
msgid "Self-Documentation"
msgstr "##自己文書化(Self-Documentation)"

#: src/additional_resources/design-principles.md:73
#, fuzzy
msgid ""
"“The designer of a module should strive to make all information about the "
"module part of the module itself.” - Bertrand Meyer: Object-Oriented "
"Software Construction"
msgstr ""
"“The designer of a module should strive to make all information about the\n"
"module part of the module itself.\n"
"(モジュールの設計者は、そのモジュールに関するすべての\n"
"情報をモジュールの一部とするよう努めるべきです)” - Bertrand Meyer: Object-"
"Oriented Software Construction"

#: src/additional_resources/design-principles.md:77
#, fuzzy
msgid "Uniform-Access"
msgstr "## 統一的アクセス(Uniform-Access)"

#: src/additional_resources/design-principles.md:79
#, fuzzy
msgid ""
"“All services offered by a module should be available through a uniform "
"notation, which does not betray whether they are implemented through storage "
"or through computation.” - Bertrand Meyer: Object-Oriented Software "
"Construction"
msgstr ""
"“All services offered by a module should be available through a uniform\n"
"notation, which does not betray whether they are implemented through storage "
"or\n"
"through computation.\n"
"(モジュールにより提供されるすべてのサービスは、\n"
"統一された表記法により利用可能であるべきです。\n"
"それがストレージによって実装されるのか、計算により実装されるのかを裏切っては"
"いけません)” - Bertrand\n"
"Meyer: Object-Oriented Software Construction"

#: src/additional_resources/design-principles.md:83
#, fuzzy
msgid "Single-Choice"
msgstr "## 単一選択(Single-Choice)"

#: src/additional_resources/design-principles.md:85
#, fuzzy
msgid ""
"“Whenever a software system must support a set of alternatives, one and only "
"one module in the system should know their exhaustive list.” - Bertrand "
"Meyer: Object-Oriented Software Construction"
msgstr ""
"“Whenever a software system must support a set of alternatives, one and "
"only\n"
"one module in the system should know their exhaustive list.\n"
"(ソフトウェアシステムが複数の選択肢をサポートしなければならないときは常に、\n"
"その網羅的なリストを知っているのはシステム内の単一のモジュールのみであるべき"
"です)” - Bertrand Meyer:\n"
"Object-Oriented Software Construction"

#: src/additional_resources/design-principles.md:89
#, fuzzy
msgid "Persistence-Closure"
msgstr "## 永続的クロージャ(Persistence-Closure)"

#: src/additional_resources/design-principles.md:91
#, fuzzy
msgid ""
"“Whenever a storage mechanism stores an object, it must store with it the "
"dependents of that object. Whenever a retrieval mechanism retrieves a "
"previously stored object, it must also retrieve any dependent of that object "
"that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented Software "
"Construction"
msgstr ""
"“Whenever a storage mechanism stores an object, it must store with it the\n"
"dependents of that object. Whenever a retrieval mechanism retrieves a\n"
"previously stored object, it must also retrieve any dependent of that "
"object\n"
"that has not yet been retrieved.\n"
"(格納メカニズムがオブジェクトを格納するときは常に、\n"
"そのオブジェクトに従属するものを一緒に格納しなければなりません。\n"
"また、取出メカニズムが以前に格納されたオブジェクトを取り出すときは常に、\n"
"オブジェクトに従属する、また取り出されていないものを取り出さねばなりませ"
"ん。)” - Bertrand\n"
" Meyer: Object-Oriented Software Construction"

#~ msgid "Lenses and Prisms"
#~ msgstr "Lens と Prism"

#~ msgid "# Introduction"
#~ msgstr "# はじめに"

#~ msgid "## Design patterns"
#~ msgstr "## デザインパターン"

#~ msgid ""
#~ "- [Idioms](./idioms/index.md): guidelines to follow when coding.\n"
#~ "  They are the social norms of the community.\n"
#~ "  You should break them only if you have a good reason for it.\n"
#~ "- [Design patterns](./patterns/index.md): methods to solve common "
#~ "problems\n"
#~ "  when coding.\n"
#~ "- [Anti-patterns](./anti_patterns/index.md): methods to solve common "
#~ "problems\n"
#~ "  when coding.\n"
#~ "  However, while design patterns give us benefits,\n"
#~ "  anti-patterns create more problems."
#~ msgstr ""
#~ "- [イディオム](./idioms/index.md)：コーディングの際に従うべきガイドライ"
#~ "ン。\n"
#~ "  コミュニティの社会的規範です。正当な理由がある場合のみ、破るべきです。\n"
#~ "- [デザインパターン](./patterns/index.md): コーディングの際によくある問題"
#~ "を解決するための方法です。\n"
#~ "- [アンチパターン](./anti_patterns/index.md): コーディング時によくある問題"
#~ "を解決するための方法です。\n"
#~ "  ただし、デザインパターンが私たちに利益を与えてくれるのに対し、アンチパ"
#~ "ターンはより多くの問題を引き起こします。"

#~ msgid "# Translations"
#~ msgstr "# 翻訳"

#~ msgid "# Idioms"
#~ msgstr "# イディオム"

#~ msgid "# Use borrowed types for arguments"
#~ msgstr "# 引数には借用型（borrowed types）を使用する"

#~ msgid ""
#~ "```rust\n"
#~ "fn three_vowels(word: &String) -> bool {\n"
#~ "    let mut vowel_count = 0;\n"
#~ "    for c in word.chars() {\n"
#~ "        match c {\n"
#~ "            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
#~ "                vowel_count += 1;\n"
#~ "                if vowel_count >= 3 {\n"
#~ "                    return true\n"
#~ "                }\n"
#~ "            }\n"
#~ "            _ => vowel_count = 0\n"
#~ "        }\n"
#~ "    }\n"
#~ "    false\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let ferris = \"Ferris\".to_string();\n"
#~ "    let curious = \"Curious\".to_string();\n"
#~ "    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
#~ "    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
#~ "\n"
#~ "    // This works fine, but the following two lines would fail:\n"
#~ "    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
#~ "    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
#~ "\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn three_vowels(word: &String) -> bool {\n"
#~ "    let mut vowel_count = 0;\n"
#~ "    for c in word.chars() {\n"
#~ "        match c {\n"
#~ "            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
#~ "                vowel_count += 1;\n"
#~ "                if vowel_count >= 3 {\n"
#~ "                    return true\n"
#~ "                }\n"
#~ "            }\n"
#~ "            _ => vowel_count = 0\n"
#~ "        }\n"
#~ "    }\n"
#~ "    false\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let ferris = \"Ferris\".to_string();\n"
#~ "    let curious = \"Curious\".to_string();\n"
#~ "    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
#~ "    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
#~ "\n"
#~ "    // 以上はうまく動作する。しかし以下の2行は失敗する：\n"
#~ "    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
#~ "    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
#~ "\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust, ignore\n"
#~ "fn three_vowels(word: &str) -> bool {\n"
#~ "```"
#~ msgstr ""
#~ "```rust, ignore\n"
#~ "fn three_vowels(word: &str) -> bool {\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Ferris: false\n"
#~ "Curious: true\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Ferris: false\n"
#~ "Curious: true\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn three_vowels(word: &str) -> bool {\n"
#~ "    let mut vowel_count = 0;\n"
#~ "    for c in word.chars() {\n"
#~ "        match c {\n"
#~ "            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
#~ "                vowel_count += 1;\n"
#~ "                if vowel_count >= 3 {\n"
#~ "                    return true\n"
#~ "                }\n"
#~ "            }\n"
#~ "            _ => vowel_count = 0\n"
#~ "        }\n"
#~ "    }\n"
#~ "    false\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let sentence_string =\n"
#~ "        \"Once upon a time, there was a friendly curious crab named "
#~ "Ferris\".to_string();\n"
#~ "    for word in sentence_string.split(' ') {\n"
#~ "        if three_vowels(word) {\n"
#~ "            println!(\"{} has three consecutive vowels!\", word);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn three_vowels(word: &str) -> bool {\n"
#~ "    let mut vowel_count = 0;\n"
#~ "    for c in word.chars() {\n"
#~ "        match c {\n"
#~ "            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
#~ "                vowel_count += 1;\n"
#~ "                if vowel_count >= 3 {\n"
#~ "                    return true\n"
#~ "                }\n"
#~ "            }\n"
#~ "            _ => vowel_count = 0\n"
#~ "        }\n"
#~ "    }\n"
#~ "    false\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let sentence_string =\n"
#~ "        \"Once upon a time, there was a friendly curious crab named "
#~ "Ferris\".to_string();\n"
#~ "    for word in sentence_string.split(' ') {\n"
#~ "        if three_vowels(word) {\n"
#~ "            println!(\"{} has three consecutive vowels!\", word);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Constructors"
#~ msgstr "# コンストラクタ"

#~ msgid ""
#~ "````rust\n"
#~ "/// Time in seconds.\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::new(42);\n"
#~ "/// assert_eq!(42, s.value());\n"
#~ "/// ```\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    // Constructs a new instance of [`Second`].\n"
#~ "    // Note this is an associated function - no self.\n"
#~ "    pub fn new(value: u64) -> Self {\n"
#~ "        Self { value }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// Returns the value in seconds.\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "````"
#~ msgstr ""
#~ "````rust\n"
#~ "/// 秒単位の時間\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::new(42);\n"
#~ "/// assert_eq!(42, s.value());\n"
#~ "/// ```\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    // [`Second`] のインスタンスを生成する。\n"
#~ "    // 関連関数であることに注意： self が無い。 \n"
#~ "    pub fn new(value: u64) -> Self {\n"
#~ "        Self { value }\n"
#~ "    }\n"
#~ "\n"
#~ "    /// 秒として値を返す。\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "````"

#~ msgid ""
#~ "````rust\n"
#~ "/// Time in seconds.\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::default();\n"
#~ "/// assert_eq!(0, s.value());\n"
#~ "/// ```\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    /// Returns the value in seconds.\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Default for Second {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self { value: 0 }\n"
#~ "    }\n"
#~ "}\n"
#~ "````"
#~ msgstr ""
#~ "````rust\n"
#~ "/// 秒単位の時間。\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::default();\n"
#~ "/// assert_eq!(0, s.value());\n"
#~ "/// ```\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    /// 秒として値を返す。\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "impl Default for Second {\n"
#~ "    fn default() -> Self {\n"
#~ "        Self { value: 0 }\n"
#~ "    }\n"
#~ "}\n"
#~ "````"

#~ msgid ""
#~ "````rust\n"
#~ "/// Time in seconds.\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::default();\n"
#~ "/// assert_eq!(0, s.value());\n"
#~ "/// ```\n"
#~ "#[derive(Default)]\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    /// Returns the value in seconds.\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "````"
#~ msgstr ""
#~ "````rust\n"
#~ "/// 秒単位の時間。\n"
#~ "///\n"
#~ "/// # Example\n"
#~ "///\n"
#~ "/// ```\n"
#~ "/// let s = Second::default();\n"
#~ "/// assert_eq!(0, s.value());\n"
#~ "/// ```\n"
#~ "#[derive(Default)]\n"
#~ "pub struct Second {\n"
#~ "    value: u64\n"
#~ "}\n"
#~ "\n"
#~ "impl Second {\n"
#~ "    /// 秒として値を返す。\n"
#~ "    pub fn value(&self) -> u64 {\n"
#~ "        self.value\n"
#~ "    }\n"
#~ "}\n"
#~ "````"

#~ msgid ""
#~ "- The [default idiom](default.md) for a more in-depth description of the\n"
#~ "  `Default` trait.\n"
#~ "\n"
#~ "- The [builder pattern](../patterns/creational/builder.md) for "
#~ "constructing\n"
#~ "  objects where there are multiple configurations.\n"
#~ "\n"
#~ "- [API Guidelines/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS] for\n"
#~ "  implementing both, `Default` and `new`."
#~ msgstr ""
#~ "- `Default` トレイトについてのより詳細な記述は [default idiom](default.md)"
#~ "を参照してください。\n"
#~ "\n"
#~ "- 多数の設定項目を持つオブジェクトの構築については [builderパターン](../"
#~ "patterns/creational/builder.md)を参照してください。\n"
#~ "\n"
#~ "- [APIガイドライン/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS]を参照"
#~ "してください。\n"
#~ "  Default`と`new`の両方を実装します。"

#~ msgid ""
#~ "```rust\n"
#~ "use std::{path::PathBuf, time::Duration};\n"
#~ "\n"
#~ "// note that we can simply auto-derive Default here.\n"
#~ "#[derive(Default, Debug, PartialEq)]\n"
#~ "struct MyConfiguration {\n"
#~ "    // Option defaults to None\n"
#~ "    output: Option<PathBuf>,\n"
#~ "    // Vecs default to empty vector\n"
#~ "    search_path: Vec<PathBuf>,\n"
#~ "    // Duration defaults to zero time\n"
#~ "    timeout: Duration,\n"
#~ "    // bool defaults to false\n"
#~ "    check: bool,\n"
#~ "}\n"
#~ "\n"
#~ "impl MyConfiguration {\n"
#~ "    // add setters here\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // construct a new instance with default values\n"
#~ "    let mut conf = MyConfiguration::default();\n"
#~ "    // do something with conf here\n"
#~ "    conf.check = true;\n"
#~ "    println!(\"conf = {:#?}\", conf);\n"
#~ "        \n"
#~ "    // partial initialization with default values, creates the same "
#~ "instance\n"
#~ "    let conf1 = MyConfiguration {\n"
#~ "        check: true,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "    assert_eq!(conf, conf1);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::{path::PathBuf, time::Duration};\n"
#~ "\n"
#~ "// ここでは単にDefaultを自動派生できることに注目してください。\n"
#~ "#[derive(Default, Debug, PartialEq)]\n"
#~ "struct MyConfiguration {\n"
#~ "    // Option のデフォルトは None\n"
#~ "    output: Option<PathBuf>,\n"
#~ "    // Vecs のデフォルトは空のベクタr\n"
#~ "    search_path: Vec<PathBuf>,\n"
#~ "    // Duration のデフォルトは 0時間\n"
#~ "    timeout: Duration,\n"
#~ "    // bool のデフォルトは false\n"
#~ "    check: bool,\n"
#~ "}\n"
#~ "\n"
#~ "impl MyConfiguration {\n"
#~ "    // add setters here\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // デフォルト値で新しいインスタンスを構築します\n"
#~ "    let mut conf = MyConfiguration::default();\n"
#~ "    // ここで conf に何かをします\n"
#~ "    conf.check = true;\n"
#~ "    println!(\"conf = {:#?}\", conf);\n"
#~ "        \n"
#~ "    // デフォルト値を使い部分的に初期化し、同じインスタンスを作成しま"
#~ "す。\n"
#~ "    let conf1 = MyConfiguration {\n"
#~ "        check: true,\n"
#~ "        ..Default::default()\n"
#~ "    };\n"
#~ "    assert_eq!(conf, conf1);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- The [constructor] idiom is another way to generate instances that may "
#~ "or may\n"
#~ "  not be \"default\"\n"
#~ "- The [`Default`] documentation (scroll down for the list of "
#~ "implementors)\n"
#~ "- [`Option::unwrap_or_default()`]\n"
#~ "- [`derive(new)`]"
#~ msgstr ""
#~ "- [コンストラクタ][constructor] イディオムは、 \"default\" であるかどうか"
#~ "にかかわらずインスタンスを生成する別の方法です。\n"
#~ "- [`Default`]ドキュメント (実装する型の一覧は下にスクロールしてください)\n"
#~ "- [`Option::unwrap_or_default()`] \n"
#~ "- [`derive(new)`]"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Vec<T> {\n"
#~ "    data: RawVec<T>,\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> Deref for Vec<T> {\n"
#~ "    type Target = [T];\n"
#~ "\n"
#~ "    fn deref(&self) -> &[T] {\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Vec<T> {\n"
#~ "    data: RawVec<T>,\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl<T> Deref for Vec<T> {\n"
#~ "    type Target = [T];\n"
#~ "\n"
#~ "    fn deref(&self) -> &[T] {\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn bar() -> Result<(), ()> {\n"
#~ "    // These don't need to be defined inside the function.\n"
#~ "    struct Foo;\n"
#~ "\n"
#~ "    // Implement a destructor for Foo.\n"
#~ "    impl Drop for Foo {\n"
#~ "        fn drop(&mut self) {\n"
#~ "            println!(\"exit\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // The dtor of _exit will run however the function `bar` is exited.\n"
#~ "    let _exit = Foo;\n"
#~ "    // Implicit return with `?` operator.\n"
#~ "    baz()?;\n"
#~ "    // Normal return.\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn bar() -> Result<(), ()> {\n"
#~ "    // 関数内で定義する必要はありません。\n"
#~ "    struct Foo;\n"
#~ "\n"
#~ "    // Fooのデストラクタを実装。\n"
#~ "    impl Drop for Foo {\n"
#~ "        fn drop(&mut self) {\n"
#~ "            println!(\"exit\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // _exit のデストラクタは `bar` の抜け方にかかわらず実行されます。\n"
#~ "    let _exit = Foo;\n"
#~ "    // `?` による暗黙的な return。\n"
#~ "    baz()?;\n"
#~ "    // 通常の return。\n"
#~ "    Ok(())\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::mem;\n"
#~ "\n"
#~ "enum MultiVariateEnum {\n"
#~ "    A { name: String },\n"
#~ "    B { name: String },\n"
#~ "    C,\n"
#~ "    D\n"
#~ "}\n"
#~ "\n"
#~ "fn swizzle(e: &mut MultiVariateEnum) {\n"
#~ "    use MultiVariateEnum::*;\n"
#~ "    *e = match e {\n"
#~ "        // Ownership rules do not allow taking `name` by value, but we "
#~ "cannot\n"
#~ "        // take the value out of a mutable reference, unless we replace "
#~ "it:\n"
#~ "        A { name } => B { name: mem::take(name) },\n"
#~ "        B { name } => A { name: mem::take(name) },\n"
#~ "        C => D,\n"
#~ "        D => C\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::mem;\n"
#~ "\n"
#~ "enum MultiVariateEnum {\n"
#~ "    A { name: String },\n"
#~ "    B { name: String },\n"
#~ "    C,\n"
#~ "    D\n"
#~ "}\n"
#~ "\n"
#~ "fn swizzle(e: &mut MultiVariateEnum) {\n"
#~ "    use MultiVariateEnum::*;\n"
#~ "    *e = match e {\n"
#~ "        // 所有権のルールは `name` を値として取り出すことを禁じているた"
#~ "め、\n"
#~ "        // 置き換える形以外では、可変参照の外へ値を取り出せない。\n"
#~ "        A { name } => B { name: mem::take(name) },\n"
#~ "        B { name } => A { name: mem::take(name) },\n"
#~ "        C => D,\n"
#~ "        D => C\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# On-Stack Dynamic Dispatch"
#~ msgstr "# オンスタックの動的ディスパッチ"

#~ msgid ""
#~ "```rust\n"
#~ "use std::io;\n"
#~ "use std::fs;\n"
#~ "\n"
#~ "# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
#~ "# let arg = \"-\";\n"
#~ "\n"
#~ "// These must live longer than `readable`, and thus are declared first:\n"
#~ "let (mut stdin_read, mut file_read);\n"
#~ "\n"
#~ "// We need to ascribe the type to get dynamic dispatch.\n"
#~ "let readable: &mut dyn io::Read = if arg == \"-\" {\n"
#~ "    stdin_read = io::stdin();\n"
#~ "    &mut stdin_read\n"
#~ "} else {\n"
#~ "    file_read = fs::File::open(arg)?;\n"
#~ "    &mut file_read\n"
#~ "};\n"
#~ "\n"
#~ "// Read from `readable` here.\n"
#~ "\n"
#~ "# Ok(())\n"
#~ "# }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::io;\n"
#~ "use std::fs;\n"
#~ "\n"
#~ "# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
#~ "# let arg = \"-\";\n"
#~ "\n"
#~ "// These must live longer than `readable`, and thus are declared first:\n"
#~ "// これらは `readable` よりも長く存在しなければならないので、最初に宣言し"
#~ "ます：\n"
#~ "let (mut stdin_read, mut file_read);\n"
#~ "\n"
#~ "// We need to ascribe the type to get dynamic dispatch.\n"
#~ "// 動的なディスパッチを行うために、ディスパッチ先の型を指定する必要があり"
#~ "ます。\n"
#~ "let readable: &mut dyn io::Read = if arg == \"-\" {\n"
#~ "    stdin_read = io::stdin();\n"
#~ "    &mut stdin_read\n"
#~ "} else {\n"
#~ "    file_read = fs::File::open(arg)?;\n"
#~ "    &mut file_read\n"
#~ "};\n"
#~ "\n"
#~ "// ここで `readable` から読み出し。\n"
#~ "\n"
#~ "# Ok(())\n"
#~ "# }\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// We still need to ascribe the type for dynamic dispatch.\n"
#~ "let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
#~ "    Box::new(io::stdin())\n"
#~ "} else {\n"
#~ "    Box::new(fs::File::open(arg)?)\n"
#~ "};\n"
#~ "// Read from `readable` here.\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// We still need to ascribe the type for dynamic dispatch.\n"
#~ "// この場合でも、動的なディスパッチを行うために、ディスパッチ先の型を指定"
#~ "する必要があります。\n"
#~ "let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
#~ "    Box::new(io::stdin())\n"
#~ "} else {\n"
#~ "    Box::new(fs::File::open(arg)?)\n"
#~ "};\n"
#~ "// ここで `readable` から読み出し。\n"
#~ "```"

#~ msgid ""
#~ "1. Flat Enums should be converted to integers and returned as codes.\n"
#~ "2. Structured Enums should be converted to an integer code with a string "
#~ "error\n"
#~ "   message for detail.\n"
#~ "3. Custom Error Types should become \"transparent\", with a C "
#~ "representation."
#~ msgstr ""
#~ "1. フラットな Enum は整数に変換してコードとして返す必要があります。\n"
#~ "2. 構造化された Enum は、詳細の文字列のエラーメッセージとともに整数コード"
#~ "に変換されるべきです。\n"
#~ "3. カスタムエラー型は、C言語表現に \"透過的 \" にするべきです。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "enum DatabaseError {\n"
#~ "    IsReadOnly = 1, // user attempted a write operation\n"
#~ "    IOError = 2, // user should read the C errno() for what it was\n"
#~ "    FileCorrupted = 3, // user should run a repair tool to recover it\n"
#~ "}\n"
#~ "\n"
#~ "impl From<DatabaseError> for libc::c_int {\n"
#~ "    fn from(e: DatabaseError) -> libc::c_int {\n"
#~ "        (e as i8).into()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "enum DatabaseError {\n"
#~ "    IsReadOnly = 1, // ユーザが書き込みを試行しました。\n"
#~ "    IOError = 2, // ユーザは C の error() を読み、何があったか確認するべき"
#~ "です。\n"
#~ "    FileCorrupted = 3, // ユーザは復旧するために修復ツールを実行する必要が"
#~ "あります。\n"
#~ "}\n"
#~ "\n"
#~ "impl From<DatabaseError> for libc::c_int {\n"
#~ "    fn from(e: DatabaseError) -> libc::c_int {\n"
#~ "        (e as i8).into()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod errors {\n"
#~ "    enum DatabaseError {\n"
#~ "        IsReadOnly,\n"
#~ "        IOError(std::io::Error),\n"
#~ "        FileCorrupted(String), // message describing the issue\n"
#~ "    }\n"
#~ "\n"
#~ "    impl From<DatabaseError> for libc::c_int {\n"
#~ "        fn from(e: DatabaseError) -> libc::c_int {\n"
#~ "            match e {\n"
#~ "                DatabaseError::IsReadOnly => 1,\n"
#~ "                DatabaseError::IOError(_) => 2,\n"
#~ "                DatabaseError::FileCorrupted(_) => 3,\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub mod c_api {\n"
#~ "    use super::errors::DatabaseError;\n"
#~ "\n"
#~ "    #[no_mangle]\n"
#~ "    pub extern \"C\" fn db_error_description(\n"
#~ "        e: *const DatabaseError\n"
#~ "        ) -> *mut libc::c_char {\n"
#~ "\n"
#~ "        let error: &DatabaseError = unsafe {\n"
#~ "            // SAFETY: pointer lifetime is greater than the current stack "
#~ "frame\n"
#~ "            &*e\n"
#~ "        };\n"
#~ "\n"
#~ "        let error_str: String = match error {\n"
#~ "            DatabaseError::IsReadOnly => {\n"
#~ "                format!(\"cannot write to read-only database\");\n"
#~ "            }\n"
#~ "            DatabaseError::IOError(e) => {\n"
#~ "                format!(\"I/O Error: {}\", e);\n"
#~ "            }\n"
#~ "            DatabaseError::FileCorrupted(s) => {\n"
#~ "                format!(\"File corrupted, run repair: {}\", &s);\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        let c_error = unsafe {\n"
#~ "            // SAFETY: copying error_str to an allocated buffer with a "
#~ "NUL\n"
#~ "            // character at the end\n"
#~ "            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) "
#~ "as *mut _;\n"
#~ "\n"
#~ "            if malloc.is_null() {\n"
#~ "                return std::ptr::null_mut();\n"
#~ "            }\n"
#~ "\n"
#~ "            let src = error_str.as_bytes().as_ptr();\n"
#~ "\n"
#~ "            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
#~ "\n"
#~ "            std::ptr::write(malloc.add(error_str.len()), 0);\n"
#~ "\n"
#~ "            malloc as *mut libc::c_char\n"
#~ "        };\n"
#~ "\n"
#~ "        c_error\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod errors {\n"
#~ "    enum DatabaseError {\n"
#~ "        IsReadOnly,\n"
#~ "        IOError(std::io::Error),\n"
#~ "        FileCorrupted(String), // 問題を説明するメッセージ\n"
#~ "    }\n"
#~ "\n"
#~ "    impl From<DatabaseError> for libc::c_int {\n"
#~ "        fn from(e: DatabaseError) -> libc::c_int {\n"
#~ "            match e {\n"
#~ "                DatabaseError::IsReadOnly => 1,\n"
#~ "                DatabaseError::IOError(_) => 2,\n"
#~ "                DatabaseError::FileCorrupted(_) => 3,\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub mod c_api {\n"
#~ "    use super::errors::DatabaseError;\n"
#~ "\n"
#~ "    #[no_mangle]\n"
#~ "    pub extern \"C\" fn db_error_description(\n"
#~ "        e: *const DatabaseError\n"
#~ "        ) -> *mut libc::c_char {\n"
#~ "\n"
#~ "        let error: &DatabaseError = unsafe {\n"
#~ "            // SAFETY: ポインタの寿命が現在のスタックフレームより長い\n"
#~ "            &*e\n"
#~ "        };\n"
#~ "\n"
#~ "        let error_str: String = match error {\n"
#~ "            DatabaseError::IsReadOnly => {\n"
#~ "                format!(\"cannot write to read-only database\");\n"
#~ "            }\n"
#~ "            DatabaseError::IOError(e) => {\n"
#~ "                format!(\"I/O Error: {}\", e);\n"
#~ "            }\n"
#~ "            DatabaseError::FileCorrupted(s) => {\n"
#~ "                format!(\"File corrupted, run repair: {}\", &s);\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        let c_error = unsafe {\n"
#~ "            // SAFETY: error_str をNUL終端されたアロケートされたバッファに"
#~ "コピーします。\n"
#~ "            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) "
#~ "as *mut _;\n"
#~ "\n"
#~ "            if malloc.is_null() {\n"
#~ "                return std::ptr::null_mut();\n"
#~ "            }\n"
#~ "\n"
#~ "            let src = error_str.as_bytes().as_ptr();\n"
#~ "\n"
#~ "            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
#~ "\n"
#~ "            std::ptr::write(malloc.add(error_str.len()), 0);\n"
#~ "\n"
#~ "            malloc as *mut libc::c_char\n"
#~ "        };\n"
#~ "\n"
#~ "        c_error\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct ParseError {\n"
#~ "    expected: char,\n"
#~ "    line: u32,\n"
#~ "    ch: u16\n"
#~ "}\n"
#~ "\n"
#~ "impl ParseError { /* ... */ }\n"
#~ "\n"
#~ "/* Create a second version which is exposed as a C structure */\n"
#~ "#[repr(C)]\n"
#~ "pub struct parse_error {\n"
#~ "    pub expected: libc::c_char,\n"
#~ "    pub line: u32,\n"
#~ "    pub ch: u16\n"
#~ "}\n"
#~ "\n"
#~ "impl From<ParseError> for parse_error {\n"
#~ "    fn from(e: ParseError) -> parse_error {\n"
#~ "        let ParseError { expected, line, ch } = e;\n"
#~ "        parse_error { expected, line, ch }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct ParseError {\n"
#~ "    expected: char,\n"
#~ "    line: u32,\n"
#~ "    ch: u16\n"
#~ "}\n"
#~ "\n"
#~ "impl ParseError { /* ... */ }\n"
#~ "\n"
#~ "/* Cの構造体として公開する2つ目のバージョンを作成 */\n"
#~ "#[repr(C)]\n"
#~ "pub struct parse_error {\n"
#~ "    pub expected: libc::c_char,\n"
#~ "    pub line: u32,\n"
#~ "    pub ch: u16\n"
#~ "}\n"
#~ "\n"
#~ "impl From<ParseError> for parse_error {\n"
#~ "    fn from(e: ParseError) -> parse_error {\n"
#~ "        let ParseError { expected, line, ch } = e;\n"
#~ "        parse_error { expected, line, ch }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Accepting Strings"
#~ msgstr "# 文字列の受け入れ"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // other module content\n"
#~ "\n"
#~ "    /// Log a message at the specified level.\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// It is the caller's guarantee to ensure `msg`:\n"
#~ "    ///\n"
#~ "    /// - is not a null pointer\n"
#~ "    /// - points to valid, initialized data\n"
#~ "    /// - points to memory ending in a null byte\n"
#~ "    /// - won't be mutated for the duration of this function call\n"
#~ "    #[no_mangle]\n"
#~ "    pub unsafe extern \"C\" fn mylib_log(\n"
#~ "        msg: *const libc::c_char,\n"
#~ "        level: libc::c_int\n"
#~ "    ) {\n"
#~ "        let level: crate::LogLevel = match level { /* ... */ };\n"
#~ "\n"
#~ "        // SAFETY: The caller has already guaranteed this is okay (see "
#~ "the\n"
#~ "        // `# Safety` section of the doc-comment).\n"
#~ "        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() "
#~ "{\n"
#~ "            Ok(s) => s,\n"
#~ "            Err(e) => {\n"
#~ "                crate::log_error(\"FFI string conversion failed\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        crate::log(msg_str, level);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // モジュールのその他の内容・・・\n"
#~ "\n"
#~ "    /// 指定されたレベルのメッセージをログに記録します。\n"
#~ "    ///\n"
#~ "    /// # Safety\n"
#~ "    ///\n"
#~ "    /// `msg` について次のことを保証するのは呼び出し側です :\n"
#~ "    ///\n"
#~ "    /// - nullポインタでない\n"
#~ "    /// - 有効かつ初期化済みのデータを指す\n"
#~ "    /// - null バイトで終端されたメモリを指す\n"
#~ "    /// - この関数呼び出し中変更されない\n"
#~ "    #[no_mangle]\n"
#~ "    pub unsafe extern \"C\" fn mylib_log(\n"
#~ "        msg: *const libc::c_char,\n"
#~ "        level: libc::c_int\n"
#~ "    ) {\n"
#~ "        let level: crate::LogLevel = match level { /* ... */ };\n"
#~ "\n"
#~ "        // SAFETY: 呼び出し元はこれが問題ないことを既に保証しています\n"
#~ "        // ( docコメントの `# Safety` を参照 )\n"
#~ "        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() "
#~ "{\n"
#~ "            Ok(s) => s,\n"
#~ "            Err(e) => {\n"
#~ "                crate::log_error(\"FFI string conversion failed\");\n"
#~ "                return;\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        crate::log(msg_str, level);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // other module content\n"
#~ "\n"
#~ "    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
#~ "c_int) {\n"
#~ "        // DO NOT USE THIS CODE.\n"
#~ "        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.\n"
#~ "\n"
#~ "        let level: crate::LogLevel = match level { /* ... */ };\n"
#~ "\n"
#~ "        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? "
#~ "*/\n"
#~ "            libc::strlen(msg)\n"
#~ "        };\n"
#~ "\n"
#~ "        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
#~ "\n"
#~ "        let msg_cstr: std::ffi::CString = unsafe {\n"
#~ "            // SAFETY: copying from a foreign pointer expected to live\n"
#~ "            // for the entire stack frame into owned memory\n"
#~ "            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), "
#~ "msg_len);\n"
#~ "\n"
#~ "            msg_data.set_len(msg_len + 1);\n"
#~ "\n"
#~ "            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
#~ "        }\n"
#~ "\n"
#~ "        let msg_str: String = unsafe {\n"
#~ "            match msg_cstr.into_string() {\n"
#~ "                Ok(s) => s,\n"
#~ "                Err(e) => {\n"
#~ "                    crate::log_error(\"FFI string conversion failed\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        crate::log(&msg_str, level);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // モジュールのその他の内容・・・\n"
#~ "\n"
#~ "    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
#~ "c_int) {\n"
#~ "        // このコードは使用しないでください！\n"
#~ "        // このコードは醜く、冗長で、微妙なバグを含んでいます！\n"
#~ "\n"
#~ "        let level: crate::LogLevel = match level { /* ... */ };\n"
#~ "\n"
#~ "        let msg_len = unsafe { /* SAFETY: strlen って何だろう？ */\n"
#~ "            libc::strlen(msg)\n"
#~ "        };\n"
#~ "\n"
#~ "        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
#~ "\n"
#~ "        let msg_cstr: std::ffi::CString = unsafe {\n"
#~ "            // SAFETY: スタックフレーム全体が生存していると期待される外部"
#~ "のポインタから、所有メモリへコピー。\n"
#~ "            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), "
#~ "msg_len);\n"
#~ "\n"
#~ "            msg_data.set_len(msg_len + 1);\n"
#~ "\n"
#~ "            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
#~ "        }\n"
#~ "\n"
#~ "        let msg_str: String = unsafe {\n"
#~ "            match msg_cstr.into_string() {\n"
#~ "                Ok(s) => s,\n"
#~ "                Err(e) => {\n"
#~ "                    crate::log_error(\"FFI string conversion failed\");\n"
#~ "                    return;\n"
#~ "                }\n"
#~ "            }\n"
#~ "        };\n"
#~ "\n"
#~ "        crate::log(&msg_str, level);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Passing Strings"
#~ msgstr "# 文字列の受け渡し"

#~ msgid ""
#~ "1. Make the lifetime of owned strings as long as possible.\n"
#~ "2. Minimize `unsafe` code during the conversion.\n"
#~ "3. If the C code can modify the string data, use `Vec` instead of "
#~ "`CString`.\n"
#~ "4. Unless the Foreign Function API requires it, the ownership of the "
#~ "string\n"
#~ "   should not transfer to the callee."
#~ msgstr ""
#~ "1. 所有している文字列のライフタイムは可能な限り長くしてください。\n"
#~ "2. 変換中の `unsafe` コードを最小限にします。\n"
#~ "3. C言語のコードが文字列データを変更する可能性がある場合は、 `CString` の"
#~ "代わりに `Vec` を使用してください。\n"
#~ "4. 外部関数のAPIが必要としない限り、文字列の所有権を着呼側に移さないように"
#~ "します。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // other module content\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        fn seterr(message: *const libc::c_char);\n"
#~ "        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> libc::"
#~ "c_int;\n"
#~ "    }\n"
#~ "\n"
#~ "    fn report_error_to_ffi<S: Into<String>>(\n"
#~ "        err: S\n"
#~ "    ) -> Result<(), std::ffi::NulError>{\n"
#~ "        let c_err = std::ffi::CString::new(err.into())?;\n"
#~ "\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: calling an FFI whose documentation says the "
#~ "pointer is\n"
#~ "            // const, so no modification should occur\n"
#~ "            seterr(c_err.as_ptr());\n"
#~ "        }\n"
#~ "\n"
#~ "        Ok(())\n"
#~ "        // The lifetime of c_err continues until here\n"
#~ "    }\n"
#~ "\n"
#~ "    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> "
#~ "{\n"
#~ "        let mut buffer = vec![0u8; 1024];\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: calling an FFI whose documentation implies\n"
#~ "            // that the input need only live as long as the call\n"
#~ "            let written: usize = geterr(buffer.as_mut_ptr(), 1023)."
#~ "into();\n"
#~ "\n"
#~ "            buffer.truncate(written + 1);\n"
#~ "        }\n"
#~ "\n"
#~ "        std::ffi::CString::new(buffer).unwrap().into_string()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // モジュールのその他の内容\n"
#~ "\n"
#~ "    extern \"C\" {\n"
#~ "        fn seterr(message: *const libc::c_char);\n"
#~ "        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> libc::"
#~ "c_int;\n"
#~ "    }\n"
#~ "\n"
#~ "    fn report_error_to_ffi<S: Into<String>>(\n"
#~ "        err: S\n"
#~ "    ) -> Result<(), std::ffi::NulError>{\n"
#~ "        let c_err = std::ffi::CString::new(err.into())?;\n"
#~ "\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: FFIのドキュメントにはポインタが const である記載さ"
#~ "れているため、\n"
#~ "            // 呼び出しにより変更が行われることはない\n"
#~ "            seterr(c_err.as_ptr());\n"
#~ "        }\n"
#~ "\n"
#~ "        Ok(())\n"
#~ "        // The lifetime of c_err continues until here\n"
#~ "    }\n"
#~ "\n"
#~ "    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> "
#~ "{\n"
#~ "        let mut buffer = vec![0u8; 1024];\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: FFIのドキュメントによると、入力値は呼び出しの間だけ"
#~ "生存していればよい\n"
#~ "            let written: usize = geterr(buffer.as_mut_ptr(), 1023)."
#~ "into();\n"
#~ "\n"
#~ "            buffer.truncate(written + 1);\n"
#~ "        }\n"
#~ "\n"
#~ "        std::ffi::CString::new(buffer).unwrap().into_string()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. The `unsafe` block is as small as possible.\n"
#~ "2. The `CString` lives long enough.\n"
#~ "3. Errors with typecasts are always propagated when possible."
#~ msgstr ""
#~ "1. `unsafe` ブロックは可能な限り小さくします。\n"
#~ "2. `CString` は十分生存します。\n"
#~ "3. 型キャストによるエラーは可能であれば常に伝播されます。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // other module content\n"
#~ "\n"
#~ "    fn report_error<S: Into<String>>(err: S) -> Result<(), std::ffi::"
#~ "NulError> {\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: whoops, this contains a dangling pointer!\n"
#~ "            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
#~ "        }\n"
#~ "        Ok(())\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // モジュールのその他の内容\n"
#~ "\n"
#~ "    fn report_error<S: Into<String>>(err: S) -> Result<(), std::ffi::"
#~ "NulError> {\n"
#~ "        unsafe {\n"
#~ "            // SAFETY: おおっと, ここにはダングリングポインタがあります!\n"
#~ "            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
#~ "        }\n"
#~ "        Ok(())\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let turing = Some(\"Turing\");\n"
#~ "let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
#~ "\n"
#~ "logicians.extend(turing);\n"
#~ "\n"
#~ "// equivalent to\n"
#~ "if let Some(turing_inner) = turing {\n"
#~ "    logicians.push(turing_inner);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let turing = Some(\"Turing\");\n"
#~ "let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
#~ "\n"
#~ "logicians.extend(turing);\n"
#~ "\n"
#~ "// 以下と等価\n"
#~ "if let Some(turing_inner) = turing {\n"
#~ "    logicians.push(turing_inner);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "let turing = Some(\"Turing\");\n"
#~ "let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
#~ "\n"
#~ "for logician in logicians.iter().chain(turing.iter()) {\n"
#~ "    println!(\"{} is a logician\", logician);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let turing = Some(\"Turing\");\n"
#~ "let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
#~ "\n"
#~ "for logician in logicians.iter().chain(turing.iter()) {\n"
#~ "    println!(\"{} is a logician\", logician);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) is "
#~ "an\n"
#~ "  iterator which yields exactly one element. It's a more readable "
#~ "alternative to\n"
#~ "  `Some(foo).into_iter()`.\n"
#~ "\n"
#~ "- [`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait."
#~ "Iterator.html#method.filter_map)\n"
#~ "  is a version of [`Iterator::map`](https://doc.rust-lang.org/std/iter/"
#~ "trait.Iterator.html#method.map),\n"
#~ "  specialized to mapping functions which return `Option`.\n"
#~ "\n"
#~ "- The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
#~ "functions\n"
#~ "  for converting an `Option` to a zero- or one-element slice.\n"
#~ "\n"
#~ "- [Documentation for `Option<T>`](https://doc.rust-lang.org/std/option/"
#~ "enum.Option.html)"
#~ msgstr ""
#~ "- [std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html)は"
#~ "ちょうど1つの要素を返すイテレータです。\n"
#~ "  これは `Some(foo).into_iter()` に対するよりわかりやすい代案です。\n"
#~ "\n"
#~ "- [`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait."
#~ "Iterator.html#method.filter_map)\n"
#~ "  は `Option` を返す関数のマッピングに特化した [`Iterator::map`](https://"
#~ "doc.rust-lang.org/std/iter/trait.Iterator.html#method.map) のバージョンで"
#~ "す。\n"
#~ "\n"
#~ "- [`ref_slice`](https://crates.io/crates/ref_slice) は `Option` を 0 要素"
#~ "または 1 要素のスライスに変換する関数を提供する crate です。\n"
#~ "\n"
#~ "- [`Option<T>` のドキュメント](https://doc.rust-lang.org/std/option/enum."
#~ "Option.html)"

#~ msgid ""
#~ "```rust\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "let num1 = Rc::new(1);\n"
#~ "let num2 = Rc::new(2);\n"
#~ "let num3 = Rc::new(3);\n"
#~ "let closure = {\n"
#~ "    // `num1` is moved\n"
#~ "    let num2 = num2.clone();  // `num2` is cloned\n"
#~ "    let num3 = num3.as_ref();  // `num3` is borrowed\n"
#~ "    move || {\n"
#~ "        *num1 + *num2 + *num3;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "let num1 = Rc::new(1);\n"
#~ "let num2 = Rc::new(2);\n"
#~ "let num3 = Rc::new(3);\n"
#~ "let closure = {\n"
#~ "    // `num1` はムーブされます\n"
#~ "    let num2 = num2.clone();  // `num2` はクローンされます\n"
#~ "    let num3 = num3.as_ref();  // `num3` は借用されます\n"
#~ "    move || {\n"
#~ "        *num1 + *num2 + *num3;\n"
#~ "    }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "let num1 = Rc::new(1);\n"
#~ "let num2 = Rc::new(2);\n"
#~ "let num3 = Rc::new(3);\n"
#~ "\n"
#~ "let num2_cloned = num2.clone();\n"
#~ "let num3_borrowed = num3.as_ref();\n"
#~ "let closure = move || {\n"
#~ "    *num1 + *num2_cloned + *num3_borrowed;\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::rc::Rc;\n"
#~ "\n"
#~ "let num1 = Rc::new(1);\n"
#~ "let num2 = Rc::new(2);\n"
#~ "let num3 = Rc::new(3);\n"
#~ "\n"
#~ "let num2_cloned = num2.clone();\n"
#~ "let num3_borrowed = num3.as_ref();\n"
#~ "let closure = move || {\n"
#~ "    *num1 + *num2_cloned + *num3_borrowed;\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "mod a {\n"
#~ "    // Public struct.\n"
#~ "    #[non_exhaustive]\n"
#~ "    pub struct S {\n"
#~ "        pub foo: i32,\n"
#~ "    }\n"
#~ "    \n"
#~ "    #[non_exhaustive]\n"
#~ "    pub enum AdmitMoreVariants {\n"
#~ "        VariantA,\n"
#~ "        VariantB,\n"
#~ "        #[non_exhaustive]\n"
#~ "        VariantC { a: String }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn print_matched_variants(s: a::S) {\n"
#~ "    // Because S is `#[non_exhaustive]`, it cannot be named here and\n"
#~ "    // we must use `..` in the pattern.\n"
#~ "    let a::S { foo: _, ..} = s;\n"
#~ "    \n"
#~ "    let some_enum = a::AdmitMoreVariants::VariantA;\n"
#~ "    match some_enum {\n"
#~ "        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
#~ "        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
#~ "\n"
#~ "        // .. required because this variant is non-exhaustive as well\n"
#~ "        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a "
#~ "c\"),\n"
#~ "\n"
#~ "        // The wildcard match is required because more variants may be\n"
#~ "        // added in the future\n"
#~ "        _ => println!(\"it's a new variant\")\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod a {\n"
#~ "    // Public な構造体\n"
#~ "    #[non_exhaustive]\n"
#~ "    pub struct S {\n"
#~ "        pub foo: i32,\n"
#~ "    }\n"
#~ "    \n"
#~ "    #[non_exhaustive]\n"
#~ "    pub enum AdmitMoreVariants {\n"
#~ "        VariantA,\n"
#~ "        VariantB,\n"
#~ "        #[non_exhaustive]\n"
#~ "        VariantC { a: String }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn print_matched_variants(s: a::S) {\n"
#~ "    // S は `#[non_exhaustive]` でないため、ここではすべてに名前を付けるこ"
#~ "とができず、\n"
#~ "    // パターンに `..` を使用する必要があります。\n"
#~ "    let a::S { foo: _, ..} = s;\n"
#~ "    \n"
#~ "    let some_enum = a::AdmitMoreVariants::VariantA;\n"
#~ "    match some_enum {\n"
#~ "        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
#~ "        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
#~ "\n"
#~ "        // このバリアントも `#[non_exhaustive]` であるため、 `..` が必要で"
#~ "す。 \n"
#~ "        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a "
#~ "c\"),\n"
#~ "\n"
#~ "        // 将来的にバリアントが追加される可能性があるため、\n"
#~ "        // ワイルドカードのマッチが必要です。\n"
#~ "        _ => println!(\"it's a new variant\")\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "### Disadvantages"
#~ msgstr "### デメリット"

#~ msgid "# Easy doc initialization"
#~ msgstr "# docコメント内の簡易な初期化"

#~ msgid "# Temporary mutability"
#~ msgstr "# 一時的なミュータビリティ"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let data = {\n"
#~ "    let mut data = get_vec();\n"
#~ "    data.sort();\n"
#~ "    data\n"
#~ "};\n"
#~ "\n"
#~ "// Here `data` is immutable.\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let data = {\n"
#~ "    let mut data = get_vec();\n"
#~ "    data.sort();\n"
#~ "    data\n"
#~ "};\n"
#~ "\n"
#~ "// ここで `data` は不変です。\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let mut data = get_vec();\n"
#~ "data.sort();\n"
#~ "let data = data;\n"
#~ "\n"
#~ "// Here `data` is immutable.\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let mut data = get_vec();\n"
#~ "data.sort();\n"
#~ "let data = data;\n"
#~ "\n"
#~ "// ここで `data` は不変です。\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "pub fn send(value: String) -> Result<(), SendError> {\n"
#~ "    println!(\"using {value} in a meaningful way\");\n"
#~ "    // Simulate non-deterministic fallible action.\n"
#~ "    use std::time::SystemTime;\n"
#~ "    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
#~ "unwrap();\n"
#~ "    if period.subsec_nanos() % 2 == 1 {\n"
#~ "        Ok(())\n"
#~ "    } else {\n"
#~ "        Err(SendError(value))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct SendError(String);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut value = \"imagine this is very long string\".to_string();\n"
#~ "\n"
#~ "    let success = 's: {\n"
#~ "        // Try to send value two times.\n"
#~ "        for _ in 0..2 {\n"
#~ "            value = match send(value) {\n"
#~ "                Ok(()) => break 's true,\n"
#~ "                Err(SendError(value)) => value,\n"
#~ "            }\n"
#~ "        }\n"
#~ "        false\n"
#~ "    };\n"
#~ "\n"
#~ "    println!(\"success: {}\", success);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub fn send(value: String) -> Result<(), SendError> {\n"
#~ "    println!(\"using {value} in a meaningful way\");\n"
#~ "    // 非決定的に失敗し得る操作をシミュレート\n"
#~ "    use std::time::SystemTime;\n"
#~ "    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
#~ "unwrap();\n"
#~ "    if period.subsec_nanos() % 2 == 1 {\n"
#~ "        Ok(())\n"
#~ "    } else {\n"
#~ "        Err(SendError(value))\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct SendError(String);\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut value = \"この文字列がとても長いと考えてください\"."
#~ "to_string();\n"
#~ "\n"
#~ "    let success = 's: {\n"
#~ "        // value の send を2回まで試行\n"
#~ "        for _ in 0..2 {\n"
#~ "            value = match send(value) {\n"
#~ "                Ok(()) => break 's true,\n"
#~ "                Err(SendError(value)) => value,\n"
#~ "            }\n"
#~ "        }\n"
#~ "        false\n"
#~ "    };\n"
#~ "\n"
#~ "    println!(\"success: {}\", success);\n"
#~ "}\n"
#~ "```"

#~ msgid "# Design Patterns"
#~ msgstr "# デザインパターン"

#~ msgid "# Command"
#~ msgstr "# Command"

#~ msgid ""
#~ "```rust\n"
#~ "pub trait Migration {\n"
#~ "    fn execute(&self) -> &str;\n"
#~ "    fn rollback(&self) -> &str;\n"
#~ "}\n"
#~ "\n"
#~ "pub struct CreateTable;\n"
#~ "impl Migration for CreateTable {\n"
#~ "    fn execute(&self) -> &str {\n"
#~ "        \"create table\"\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> &str {\n"
#~ "        \"drop table\"\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct AddField;\n"
#~ "impl Migration for AddField {\n"
#~ "    fn execute(&self) -> &str {\n"
#~ "        \"add field\"\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> &str {\n"
#~ "        \"remove field\"\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Schema {\n"
#~ "    commands: Vec<Box<dyn Migration>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Schema {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self { commands: vec![] }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
#~ "        self.commands.push(cmd);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute(&self) -> Vec<&str> {\n"
#~ "        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<&str> {\n"
#~ "        self.commands\n"
#~ "            .iter()\n"
#~ "            .rev() // reverse iterator's direction\n"
#~ "            .map(|cmd| cmd.rollback())\n"
#~ "            .collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "\n"
#~ "    let cmd = Box::new(CreateTable);\n"
#~ "    schema.add_migration(cmd);\n"
#~ "    let cmd = Box::new(AddField);\n"
#~ "    schema.add_migration(cmd);\n"
#~ "\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub trait Migration {\n"
#~ "    fn execute(&self) -> &str;\n"
#~ "    fn rollback(&self) -> &str;\n"
#~ "}\n"
#~ "\n"
#~ "pub struct CreateTable;\n"
#~ "impl Migration for CreateTable {\n"
#~ "    fn execute(&self) -> &str {\n"
#~ "        \"create table\"\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> &str {\n"
#~ "        \"drop table\"\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct AddField;\n"
#~ "impl Migration for AddField {\n"
#~ "    fn execute(&self) -> &str {\n"
#~ "        \"add field\"\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> &str {\n"
#~ "        \"remove field\"\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Schema {\n"
#~ "    commands: Vec<Box<dyn Migration>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Schema {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self { commands: vec![] }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
#~ "        self.commands.push(cmd);\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute(&self) -> Vec<&str> {\n"
#~ "        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<&str> {\n"
#~ "        self.commands\n"
#~ "            .iter()\n"
#~ "            .rev() // イテレータを逆順に\n"
#~ "            .map(|cmd| cmd.rollback())\n"
#~ "            .collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "\n"
#~ "    let cmd = Box::new(CreateTable);\n"
#~ "    schema.add_migration(cmd);\n"
#~ "    let cmd = Box::new(AddField);\n"
#~ "    schema.add_migration(cmd);\n"
#~ "\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "type FnPtr = fn() -> String;\n"
#~ "struct Command {\n"
#~ "    execute: FnPtr,\n"
#~ "    rollback: FnPtr,\n"
#~ "}\n"
#~ "\n"
#~ "struct Schema {\n"
#~ "    commands: Vec<Command>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Schema {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self { commands: vec![] }\n"
#~ "    }\n"
#~ "    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
#~ "        self.commands.push(Command { execute, rollback });\n"
#~ "    }\n"
#~ "    fn execute(&self) -> Vec<String> {\n"
#~ "        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<String> {\n"
#~ "        self.commands\n"
#~ "            .iter()\n"
#~ "            .rev()\n"
#~ "            .map(|cmd| (cmd.rollback)())\n"
#~ "            .collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn add_field() -> String {\n"
#~ "    \"add field\".to_string()\n"
#~ "}\n"
#~ "\n"
#~ "fn remove_field() -> String {\n"
#~ "    \"remove field\".to_string()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "    schema.add_migration(|| \"create table\".to_string(), || \"drop "
#~ "table\".to_string());\n"
#~ "    schema.add_migration(add_field, remove_field);\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "type FnPtr = fn() -> String;\n"
#~ "struct Command {\n"
#~ "    execute: FnPtr,\n"
#~ "    rollback: FnPtr,\n"
#~ "}\n"
#~ "\n"
#~ "struct Schema {\n"
#~ "    commands: Vec<Command>,\n"
#~ "}\n"
#~ "\n"
#~ "impl Schema {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self { commands: vec![] }\n"
#~ "    }\n"
#~ "    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
#~ "        self.commands.push(Command { execute, rollback });\n"
#~ "    }\n"
#~ "    fn execute(&self) -> Vec<String> {\n"
#~ "        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<String> {\n"
#~ "        self.commands\n"
#~ "            .iter()\n"
#~ "            .rev()\n"
#~ "            .map(|cmd| (cmd.rollback)())\n"
#~ "            .collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn add_field() -> String {\n"
#~ "    \"add field\".to_string()\n"
#~ "}\n"
#~ "\n"
#~ "fn remove_field() -> String {\n"
#~ "    \"remove field\".to_string()\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "    schema.add_migration(|| \"create table\".to_string(), || \"drop "
#~ "table\".to_string());\n"
#~ "    schema.add_migration(add_field, remove_field);\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
#~ "\n"
#~ "struct Schema<'a> {\n"
#~ "    executes: Vec<Migration<'a>>,\n"
#~ "    rollbacks: Vec<Migration<'a>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Schema<'a> {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self {\n"
#~ "            executes: vec![],\n"
#~ "            rollbacks: vec![],\n"
#~ "        }\n"
#~ "    }\n"
#~ "    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
#~ "    where\n"
#~ "        E: Fn() -> &'a str + 'static,\n"
#~ "        R: Fn() -> &'a str + 'static,\n"
#~ "    {\n"
#~ "        self.executes.push(Box::new(execute));\n"
#~ "        self.rollbacks.push(Box::new(rollback));\n"
#~ "    }\n"
#~ "    fn execute(&self) -> Vec<&str> {\n"
#~ "        self.executes.iter().map(|cmd| cmd()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<&str> {\n"
#~ "        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn add_field() -> &'static str {\n"
#~ "    \"add field\"\n"
#~ "}\n"
#~ "\n"
#~ "fn remove_field() -> &'static str {\n"
#~ "    \"remove field\"\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "    schema.add_migration(|| \"create table\", || \"drop table\");\n"
#~ "    schema.add_migration(add_field, remove_field);\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
#~ "\n"
#~ "struct Schema<'a> {\n"
#~ "    executes: Vec<Migration<'a>>,\n"
#~ "    rollbacks: Vec<Migration<'a>>,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Schema<'a> {\n"
#~ "    fn new() -> Self {\n"
#~ "        Self {\n"
#~ "            executes: vec![],\n"
#~ "            rollbacks: vec![],\n"
#~ "        }\n"
#~ "    }\n"
#~ "    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
#~ "    where\n"
#~ "        E: Fn() -> &'a str + 'static,\n"
#~ "        R: Fn() -> &'a str + 'static,\n"
#~ "    {\n"
#~ "        self.executes.push(Box::new(execute));\n"
#~ "        self.rollbacks.push(Box::new(rollback));\n"
#~ "    }\n"
#~ "    fn execute(&self) -> Vec<&str> {\n"
#~ "        self.executes.iter().map(|cmd| cmd()).collect()\n"
#~ "    }\n"
#~ "    fn rollback(&self) -> Vec<&str> {\n"
#~ "        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn add_field() -> &'static str {\n"
#~ "    \"add field\"\n"
#~ "}\n"
#~ "\n"
#~ "fn remove_field() -> &'static str {\n"
#~ "    \"remove field\"\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut schema = Schema::new();\n"
#~ "    schema.add_migration(|| \"create table\", || \"drop table\");\n"
#~ "    schema.add_migration(add_field, remove_field);\n"
#~ "    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
#~ "    assert_eq!(vec![\"remove field\", \"drop table\"], schema."
#~ "rollback());\n"
#~ "}\n"
#~ "```"

#~ msgid "# Interpreter"
#~ msgstr "# Interpreter"

#~ msgid ""
#~ "- Terminal symbols: `0`, `...`, `9`, `+`, `-`\n"
#~ "- Non-terminal symbols: `exp`, `term`\n"
#~ "- Start symbol is `exp`\n"
#~ "- And the following are production rules"
#~ msgstr ""
#~ "- 終端記号：`0`, `...`, `9`, `+`, `-`\n"
#~ "- 非終端記号：exp`, `term`\n"
#~ "- 開始記号は `exp` です\n"
#~ "- そして以下がプロダクションルールです"

#~ msgid ""
#~ "```ignore\n"
#~ "exp -> exp + term\n"
#~ "exp -> exp - term\n"
#~ "exp -> term\n"
#~ "term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
#~ "```"
#~ msgstr ""
#~ "```ignore\n"
#~ "exp -> exp + term\n"
#~ "exp -> exp - term\n"
#~ "exp -> term\n"
#~ "term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "pub struct Interpreter<'a> {\n"
#~ "    it: std::str::Chars<'a>,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Interpreter<'a> {\n"
#~ "\n"
#~ "    pub fn new(infix: &'a str) -> Self {\n"
#~ "        Self { it: infix.chars() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn next_char(&mut self) -> Option<char> {\n"
#~ "        self.it.next()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn interpret(&mut self, out: &mut String) {\n"
#~ "        self.term(out);\n"
#~ "\n"
#~ "        while let Some(op) = self.next_char() {\n"
#~ "            if op == '+' || op == '-' {\n"
#~ "                self.term(out);\n"
#~ "                out.push(op);\n"
#~ "            } else {\n"
#~ "                panic!(\"Unexpected symbol '{}'\", op);\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn term(&mut self, out: &mut String) {\n"
#~ "        match self.next_char() {\n"
#~ "            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
#~ "            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
#~ "            None => panic!(\"Unexpected end of string\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let mut intr = Interpreter::new(\"2+3\");\n"
#~ "    let mut postfix = String::new();\n"
#~ "    intr.interpret(&mut postfix);\n"
#~ "    assert_eq!(postfix, \"23+\");\n"
#~ "\n"
#~ "    intr = Interpreter::new(\"1-2+3-4\");\n"
#~ "    postfix.clear();\n"
#~ "    intr.interpret(&mut postfix);\n"
#~ "    assert_eq!(postfix, \"12-3+4-\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "pub struct Interpreter<'a> {\n"
#~ "    it: std::str::Chars<'a>,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'a> Interpreter<'a> {\n"
#~ "\n"
#~ "    pub fn new(infix: &'a str) -> Self {\n"
#~ "        Self { it: infix.chars() }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn next_char(&mut self) -> Option<char> {\n"
#~ "        self.it.next()\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn interpret(&mut self, out: &mut String) {\n"
#~ "        self.term(out);\n"
#~ "\n"
#~ "        while let Some(op) = self.next_char() {\n"
#~ "            if op == '+' || op == '-' {\n"
#~ "                self.term(out);\n"
#~ "                out.push(op);\n"
#~ "            } else {\n"
#~ "                panic!(\"Unexpected symbol '{}'\", op);\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn term(&mut self, out: &mut String) {\n"
#~ "        match self.next_char() {\n"
#~ "            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
#~ "            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
#~ "            None => panic!(\"Unexpected end of string\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub fn main() {\n"
#~ "    let mut intr = Interpreter::new(\"2+3\");\n"
#~ "    let mut postfix = String::new();\n"
#~ "    intr.interpret(&mut postfix);\n"
#~ "    assert_eq!(postfix, \"23+\");\n"
#~ "\n"
#~ "    intr = Interpreter::new(\"1-2+3-4\");\n"
#~ "    postfix.clear();\n"
#~ "    intr.interpret(&mut postfix);\n"
#~ "    assert_eq!(postfix, \"12-3+4-\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "macro_rules! norm {\n"
#~ "    ($($element:expr),*) => {\n"
#~ "        {\n"
#~ "            let mut n = 0.0;\n"
#~ "            $(\n"
#~ "                n += ($element as f64)*($element as f64);\n"
#~ "            )*\n"
#~ "            n.sqrt()\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -3f64;\n"
#~ "    let y = 4f64;\n"
#~ "\n"
#~ "    assert_eq!(3f64, norm!(x));\n"
#~ "    assert_eq!(5f64, norm!(x, y));\n"
#~ "    assert_eq!(0f64, norm!(0, 0, 0)); \n"
#~ "    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "macro_rules! norm {\n"
#~ "    ($($element:expr),*) => {\n"
#~ "        {\n"
#~ "            let mut n = 0.0;\n"
#~ "            $(\n"
#~ "                n += ($element as f64)*($element as f64);\n"
#~ "            )*\n"
#~ "            n.sqrt()\n"
#~ "        }\n"
#~ "    };\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let x = -3f64;\n"
#~ "    let y = 4f64;\n"
#~ "\n"
#~ "    assert_eq!(3f64, norm!(x));\n"
#~ "    assert_eq!(5f64, norm!(x, y));\n"
#~ "    assert_eq!(0f64, norm!(0, 0, 0)); \n"
#~ "    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- [Interpreter pattern](https://en.wikipedia.org/wiki/"
#~ "Interpreter_pattern)\n"
#~ "- [Context free grammar](https://en.wikipedia.org/wiki/Context-"
#~ "free_grammar)\n"
#~ "- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"
#~ msgstr ""
#~ "- [Interpreter パターン](https://en.wikipedia.org/wiki/"
#~ "Interpreter_pattern)\n"
#~ "- [文脈自由文法](https://en.wikipedia.org/wiki/Context-free_grammar)\n"
#~ "- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"

#~ msgid "# Newtype"
#~ msgstr "# Newtype"

#~ msgid ""
#~ "```rust\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "// Create Newtype Password to override the Display trait for String\n"
#~ "struct Password(String);\n"
#~ "\n"
#~ "impl Display for Password {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"****************\")\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let unsecured_password: String = \"ThisIsMyPassword\".to_string();\n"
#~ "    let secured_password: Password = Password(unsecured_password."
#~ "clone());\n"
#~ "    println!(\"unsecured_password: {unsecured_password}\");\n"
#~ "    println!(\"secured_password: {secured_password}\");\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::fmt::Display;\n"
#~ "\n"
#~ "// String の Display トレイト をオーバライドするため、新しい型の Password "
#~ "を作成\n"
#~ "struct Password(String);\n"
#~ "\n"
#~ "impl Display for Password {\n"
#~ "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
#~ "        write!(f, \"****************\")\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let unsecured_password: String = \"ThisIsMyPassword\".to_string();\n"
#~ "    let secured_password: Password = Password(unsecured_password."
#~ "clone());\n"
#~ "    println!(\"unsecured_password: {unsecured_password}\");\n"
#~ "    println!(\"secured_password: {secured_password}\");\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "unsecured_password: ThisIsMyPassword\n"
#~ "secured_password: ****************\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "unsecured_password: ThisIsMyPassword\n"
#~ "secured_password: ****************\n"
#~ "```"

#~ msgid ""
#~ "- restricting functionality (reduce the functions exposed or traits "
#~ "implemented),\n"
#~ "- making a type with copy semantics have move semantics,\n"
#~ "- abstraction by providing a more concrete type and thus hiding internal "
#~ "types,\n"
#~ "  e.g.,"
#~ msgstr ""
#~ "- 機能の制限(公開される関数や実装されるトレイトを減らす)、\n"
#~ "- コピー・セマンティクスを持つ型にムーブ・セマンティクスを持たせること、\n"
#~ "- より具象的な型を提供することで内部型を隠すことによる抽象化、\n"
#~ "  例えば、"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub struct Foo(Bar<T1, T2>);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub struct Foo(Bar<T1, T2>);\n"
#~ "```"

#~ msgid ""
#~ "- [Advanced Types in the book](https://doc.rust-lang.org/book/ch19-04-"
#~ "advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-"
#~ "safety-and-abstraction)\n"
#~ "- [Newtypes in Haskell](https://wiki.haskell.org/Newtype)\n"
#~ "- [Type aliases](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
#~ "types.html#creating-type-synonyms-with-type-aliases)\n"
#~ "- [derive_more](https://crates.io/crates/derive_more), a crate for "
#~ "deriving many\n"
#~ "  builtin traits on newtypes.\n"
#~ "- [The Newtype Pattern In Rust](https://web.archive.org/"
#~ "web/20230519162111/https://www.worthe-it.co.za/blog/2020-10-31-newtype-"
#~ "pattern-in-rust.html)"
#~ msgstr ""
#~ "- [Book 内の Advanced Types](https://doc.rust-lang.org/book/ch19-04-"
#~ "advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-"
#~ "safety-and-abstraction)\n"
#~ "- [Haskell における newtype](https://wiki.haskell.org/Newtype)\n"
#~ "- [型のエイリアス](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
#~ "types.html#creating-type-synonyms-with-type-aliases)\n"
#~ "- [derive_more](https://crates.io/crates/derive_more)。\n"
#~ "  newtype に多くのビルドインのトレイトを派生させる crate。\n"
#~ "- [The Newtype Pattern in Rust](https://www.worthe-it.co.za/"
#~ "blog/2020-10-31-newtype-pattern-in-rust.html)"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Foo {}\n"
#~ "\n"
#~ "struct Mutex<T> {\n"
#~ "    // We keep a reference to our data: T here.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "struct MutexGuard<'a, T: 'a> {\n"
#~ "    data: &'a T,\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// Locking the mutex is explicit.\n"
#~ "impl<T> Mutex<T> {\n"
#~ "    fn lock(&self) -> MutexGuard<T> {\n"
#~ "        // Lock the underlying OS mutex.\n"
#~ "        //..\n"
#~ "\n"
#~ "        // MutexGuard keeps a reference to self\n"
#~ "        MutexGuard {\n"
#~ "            data: self,\n"
#~ "            //..\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Destructor for unlocking the mutex.\n"
#~ "impl<'a, T> Drop for MutexGuard<'a, T> {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Unlock the underlying OS mutex.\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Implementing Deref means we can treat MutexGuard like a pointer to T.\n"
#~ "impl<'a, T> Deref for MutexGuard<'a, T> {\n"
#~ "    type Target = T;\n"
#~ "\n"
#~ "    fn deref(&self) -> &T {\n"
#~ "        self.data\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn baz(x: Mutex<Foo>) {\n"
#~ "    let xx = x.lock();\n"
#~ "    xx.foo(); // foo is a method on Foo.\n"
#~ "    // The borrow checker ensures we can't store a reference to the "
#~ "underlying\n"
#~ "    // Foo which will outlive the guard xx.\n"
#~ "\n"
#~ "    // x is unlocked when we exit this function and xx's destructor is "
#~ "executed.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Foo {}\n"
#~ "\n"
#~ "struct Mutex<T> {\n"
#~ "    // ここでデータ T への参照を保持します\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "struct MutexGuard<'a, T: 'a> {\n"
#~ "    data: &'a T,\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// ミューテックスのロックは明示的です\n"
#~ "impl<T> Mutex<T> {\n"
#~ "    fn lock(&self) -> MutexGuard<T> {\n"
#~ "        // OSのミューテックスをロックします\n"
#~ "        //..\n"
#~ "\n"
#~ "        // MutexGuard は self の参照を保持します\n"
#~ "        MutexGuard {\n"
#~ "            data: self,\n"
#~ "            //..\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// ミューテックスをアンロックするためのデストラクタ\n"
#~ "impl<'a, T> Drop for MutexGuard<'a, T> {\n"
#~ "    fn drop(&mut self) {\n"
#~ "        // Unlock the underlying OS mutex.\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// Deref を MutexGuard に実装し T へのポインタのように扱えるようにします\n"
#~ "impl<'a, T> Deref for MutexGuard<'a, T> {\n"
#~ "    type Target = T;\n"
#~ "\n"
#~ "    fn deref(&self) -> &T {\n"
#~ "        self.data\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn baz(x: Mutex<Foo>) {\n"
#~ "    let xx = x.lock();\n"
#~ "    xx.foo(); // foo は Foo のメソッドです\n"
#~ "    // 借用チェッカーは、ガードの xx よりも生存期間が長い Foo への参照を保"
#~ "持できないことを保証します\n"
#~ "\n"
#~ "    // 関数が終了し、 xx のデストラクタが実行されると、 x がアンロックされ"
#~ "ます\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn deref<'a>(&'a self) -> &'a T {\n"
#~ "    //..\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn deref<'a>(&'a self) -> &'a T {\n"
#~ "    //..\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "type Data = HashMap<String, u32>;\n"
#~ "\n"
#~ "trait Formatter {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String);\n"
#~ "}\n"
#~ "\n"
#~ "struct Report;\n"
#~ "\n"
#~ "impl Report {\n"
#~ "    // Write should be used but we kept it as String to ignore error "
#~ "handling\n"
#~ "    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
#~ "        // backend operations...\n"
#~ "        let mut data = HashMap::new();\n"
#~ "        data.insert(\"one\".to_string(), 1);\n"
#~ "        data.insert(\"two\".to_string(), 2);\n"
#~ "        // generate report\n"
#~ "        g.format(&data, s);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Text;\n"
#~ "impl Formatter for Text {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String) {\n"
#~ "        for (k, v) in data {\n"
#~ "            let entry = format!(\"{} {}\\n\", k, v);\n"
#~ "            buf.push_str(&entry);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Json;\n"
#~ "impl Formatter for Json {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String) {\n"
#~ "        buf.push('[');\n"
#~ "        for (k, v) in data.into_iter() {\n"
#~ "            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
#~ "            buf.push_str(&entry);\n"
#~ "            buf.push(',');\n"
#~ "        }\n"
#~ "        if !data.is_empty() {\n"
#~ "            buf.pop(); // remove extra , at the end\n"
#~ "        }\n"
#~ "        buf.push(']');\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut s = String::from(\"\");\n"
#~ "    Report::generate(Text, &mut s);\n"
#~ "    assert!(s.contains(\"one 1\"));\n"
#~ "    assert!(s.contains(\"two 2\"));\n"
#~ "\n"
#~ "    s.clear(); // reuse the same buffer\n"
#~ "    Report::generate(Json, &mut s);\n"
#~ "    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
#~ "    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::collections::HashMap;\n"
#~ "\n"
#~ "type Data = HashMap<String, u32>;\n"
#~ "\n"
#~ "trait Formatter {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String);\n"
#~ "}\n"
#~ "\n"
#~ "struct Report;\n"
#~ "\n"
#~ "impl Report {\n"
#~ "    // Write を使用すべきですが、エラーハンドリングを無視するため String "
#~ "のままとしています\n"
#~ "    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
#~ "        // バックエンド処理...\n"
#~ "        let mut data = HashMap::new();\n"
#~ "        data.insert(\"one\".to_string(), 1);\n"
#~ "        data.insert(\"two\".to_string(), 2);\n"
#~ "        // レポート生成\n"
#~ "        g.format(&data, s);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Text;\n"
#~ "impl Formatter for Text {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String) {\n"
#~ "        for (k, v) in data {\n"
#~ "            let entry = format!(\"{} {}\\n\", k, v);\n"
#~ "            buf.push_str(&entry);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Json;\n"
#~ "impl Formatter for Json {\n"
#~ "    fn format(&self, data: &Data, buf: &mut String) {\n"
#~ "        buf.push('[');\n"
#~ "        for (k, v) in data.into_iter() {\n"
#~ "            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
#~ "            buf.push_str(&entry);\n"
#~ "            buf.push(',');\n"
#~ "        }\n"
#~ "        if !data.is_empty() {\n"
#~ "            buf.pop(); // 最後の余分な , を削除\n"
#~ "        }\n"
#~ "        buf.push(']');\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut s = String::from(\"\");\n"
#~ "    Report::generate(Text, &mut s);\n"
#~ "    assert!(s.contains(\"one 1\"));\n"
#~ "    assert!(s.contains(\"two 2\"));\n"
#~ "\n"
#~ "    s.clear(); // バッファ再利用\n"
#~ "    Report::generate(Json, &mut s);\n"
#~ "    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
#~ "    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- All in one file (as shown in this example, similar to being separated "
#~ "as modules)\n"
#~ "- Separated as modules, E.g. `formatter::json` module, `formatter::text` "
#~ "module\n"
#~ "- Use compiler feature flags, E.g. `json` feature, `text` feature\n"
#~ "- Separated as crates, E.g. `json` crate, `text` crate"
#~ msgstr ""
#~ "- 一つのファイルにまとめたもの (例で示すように。モジュールとして分離したも"
#~ "のと似ています)\n"
#~ "- モジュールとして分離 (例えば `formatter::json` モジュール、 `formatter::"
#~ "text` モジュール)\n"
#~ "- コンパイラの feature フラグを使う (例えば `json` feature、 `text` "
#~ "feature)\n"
#~ "- crate として分離 (例えば `json` crate、 `text` crate)"

#~ msgid ""
#~ "```rust\n"
#~ "struct Adder;\n"
#~ "impl Adder {\n"
#~ "    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
#~ "    where\n"
#~ "        F: Fn(u8, u8) -> u8,\n"
#~ "    {\n"
#~ "        f(x, y)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let arith_adder = |x, y| x + y;\n"
#~ "    let bool_adder = |x, y| {\n"
#~ "        if x == 1 || y == 1 {\n"
#~ "            1\n"
#~ "        } else {\n"
#~ "            0\n"
#~ "        }\n"
#~ "    };\n"
#~ "    let custom_adder = |x, y| 2 * x + y;\n"
#~ "\n"
#~ "    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
#~ "    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
#~ "    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Adder;\n"
#~ "impl Adder {\n"
#~ "    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
#~ "    where\n"
#~ "        F: Fn(u8, u8) -> u8,\n"
#~ "    {\n"
#~ "        f(x, y)\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let arith_adder = |x, y| x + y;\n"
#~ "    let bool_adder = |x, y| {\n"
#~ "        if x == 1 || y == 1 {\n"
#~ "            1\n"
#~ "        } else {\n"
#~ "            0\n"
#~ "        }\n"
#~ "    };\n"
#~ "    let custom_adder = |x, y| 2 * x + y;\n"
#~ "\n"
#~ "    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
#~ "    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
#~ "    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let val = Some(\"Rust\");\n"
#~ "\n"
#~ "    let len_strategy = |s: &str| s.len();\n"
#~ "    assert_eq!(4, val.map(len_strategy).unwrap());\n"
#~ "\n"
#~ "    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
#~ "    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "fn main() {\n"
#~ "    let val = Some(\"Rust\");\n"
#~ "\n"
#~ "    let len_strategy = |s: &str| s.len();\n"
#~ "    assert_eq!(4, val.map(len_strategy).unwrap());\n"
#~ "\n"
#~ "    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
#~ "    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
#~ "- [Dependency Injection](https://en.wikipedia.org/wiki/"
#~ "Dependency_injection)\n"
#~ "- [Policy Based Design](https://en.wikipedia.org/wiki/Modern_C+"
#~ "+_Design#Policy-based_design)"
#~ msgstr ""
#~ "- [Strategy パターン](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
#~ "- [依存性の注入](https://en.wikipedia.org/wiki/Dependency_injection)\n"
#~ "- [Policy Based Design](https://en.wikipedia.org/wiki/Modern_C+"
#~ "+_Design#Policy-based_design)"

#~ msgid "# Visitor"
#~ msgstr "# Visitor"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// The data we will visit\n"
#~ "mod ast {\n"
#~ "    pub enum Stmt {\n"
#~ "        Expr(Expr),\n"
#~ "        Let(Name, Expr),\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Name {\n"
#~ "        value: String,\n"
#~ "    }\n"
#~ "\n"
#~ "    pub enum Expr {\n"
#~ "        IntLit(i64),\n"
#~ "        Add(Box<Expr>, Box<Expr>),\n"
#~ "        Sub(Box<Expr>, Box<Expr>),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// The abstract visitor\n"
#~ "mod visit {\n"
#~ "    use ast::*;\n"
#~ "\n"
#~ "    pub trait Visitor<T> {\n"
#~ "        fn visit_name(&mut self, n: &Name) -> T;\n"
#~ "        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
#~ "        fn visit_expr(&mut self, e: &Expr) -> T;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use visit::*;\n"
#~ "use ast::*;\n"
#~ "\n"
#~ "// An example concrete implementation - walks the AST interpreting it as "
#~ "code.\n"
#~ "struct Interpreter;\n"
#~ "impl Visitor<i64> for Interpreter {\n"
#~ "    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
#~ "    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
#~ "        match *s {\n"
#~ "            Stmt::Expr(ref e) => self.visit_expr(e),\n"
#~ "            Stmt::Let(..) => unimplemented!(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
#~ "        match *e {\n"
#~ "            Expr::IntLit(n) => n,\n"
#~ "            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + self."
#~ "visit_expr(rhs),\n"
#~ "            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - self."
#~ "visit_expr(rhs),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// visitor が処理することになるデータ\n"
#~ "mod ast {\n"
#~ "    pub enum Stmt {\n"
#~ "        Expr(Expr),\n"
#~ "        Let(Name, Expr),\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Name {\n"
#~ "        value: String,\n"
#~ "    }\n"
#~ "\n"
#~ "    pub enum Expr {\n"
#~ "        IntLit(i64),\n"
#~ "        Add(Box<Expr>, Box<Expr>),\n"
#~ "        Sub(Box<Expr>, Box<Expr>),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// visitor の抽象\n"
#~ "mod visit {\n"
#~ "    use ast::*;\n"
#~ "\n"
#~ "    pub trait Visitor<T> {\n"
#~ "        fn visit_name(&mut self, n: &Name) -> T;\n"
#~ "        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
#~ "        fn visit_expr(&mut self, e: &Expr) -> T;\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use visit::*;\n"
#~ "use ast::*;\n"
#~ "\n"
#~ "// 具体的な実装例 - ASTをコードとして解釈して回る\n"
#~ "struct Interpreter;\n"
#~ "impl Visitor<i64> for Interpreter {\n"
#~ "    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
#~ "    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
#~ "        match *s {\n"
#~ "            Stmt::Expr(ref e) => self.visit_expr(e),\n"
#~ "            Stmt::Let(..) => unimplemented!(),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
#~ "        match *e {\n"
#~ "            Expr::IntLit(n) => n,\n"
#~ "            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + self."
#~ "visit_expr(rhs),\n"
#~ "            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - self."
#~ "visit_expr(rhs),\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
#~ "    match *e {\n"
#~ "        Expr::IntLit(_) => {},\n"
#~ "        Expr::Add(ref lhs, ref rhs) => {\n"
#~ "            visitor.visit_expr(lhs);\n"
#~ "            visitor.visit_expr(rhs);\n"
#~ "        }\n"
#~ "        Expr::Sub(ref lhs, ref rhs) => {\n"
#~ "            visitor.visit_expr(lhs);\n"
#~ "            visitor.visit_expr(rhs);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
#~ "    match *e {\n"
#~ "        Expr::IntLit(_) => {},\n"
#~ "        Expr::Add(ref lhs, ref rhs) => {\n"
#~ "            visitor.visit_expr(lhs);\n"
#~ "            visitor.visit_expr(rhs);\n"
#~ "        }\n"
#~ "        Expr::Sub(ref lhs, ref rhs) => {\n"
#~ "            visitor.visit_expr(lhs);\n"
#~ "            visitor.visit_expr(rhs);\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Builder"
#~ msgstr "# Builder"

#~ msgid ""
#~ "```rust\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "pub struct Foo {\n"
#~ "    // Lots of complicated fields.\n"
#~ "    bar: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // This method will help users to discover the builder\n"
#~ "    pub fn builder() -> FooBuilder {\n"
#~ "        FooBuilder::default()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Default)]\n"
#~ "pub struct FooBuilder {\n"
#~ "    // Probably lots of optional fields.\n"
#~ "    bar: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl FooBuilder {\n"
#~ "    pub fn new(/* ... */) -> FooBuilder {\n"
#~ "        // Set the minimally required fields of Foo.\n"
#~ "        FooBuilder {\n"
#~ "            bar: String::from(\"X\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(mut self, bar: String) -> FooBuilder {\n"
#~ "        // Set the name on the builder itself, and return the builder by "
#~ "value.\n"
#~ "        self.bar = bar;\n"
#~ "        self\n"
#~ "    }\n"
#~ "\n"
#~ "    // If we can get away with not consuming the Builder here, that is "
#~ "an\n"
#~ "    // advantage. It means we can use the FooBuilder as a template for "
#~ "constructing\n"
#~ "    // many Foos.\n"
#~ "    pub fn build(self) -> Foo {\n"
#~ "        // Create a Foo from the FooBuilder, applying all settings in "
#~ "FooBuilder\n"
#~ "        // to Foo.\n"
#~ "        Foo { bar: self.bar }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn builder_test() {\n"
#~ "    let foo = Foo {\n"
#~ "        bar: String::from(\"Y\"),\n"
#~ "    };\n"
#~ "    let foo_from_builder: Foo = FooBuilder::new().name(String::"
#~ "from(\"Y\")).build();\n"
#~ "    assert_eq!(foo, foo_from_builder);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[derive(Debug, PartialEq)]\n"
#~ "pub struct Foo {\n"
#~ "    // たくさんの複雑なフィールド。\n"
#~ "    bar: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // このメソッドは、ユーザが builder を見つけるために有用です。\n"
#~ "    pub fn builder() -> FooBuilder {\n"
#~ "        FooBuilder::default()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Default)]\n"
#~ "pub struct FooBuilder {\n"
#~ "    // おそらくたくさんの Option フィールド。\n"
#~ "    bar: String,\n"
#~ "}\n"
#~ "\n"
#~ "impl FooBuilder {\n"
#~ "    pub fn new(/* ... */) -> FooBuilder {\n"
#~ "        // Foo の最小限必須なフィールドを設定します。\n"
#~ "        FooBuilder {\n"
#~ "            bar: String::from(\"X\"),\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    pub fn name(mut self, bar: String) -> FooBuilder {\n"
#~ "        // builder 自身の name を設定し、builderを値として返します。\n"
#~ "        self.bar = bar;\n"
#~ "        self\n"
#~ "    }\n"
#~ "\n"
#~ "    // ここでBuilderを消費せずに済む場合、そこにはメリットがあります。\n"
#~ "    // それは、複数の Foo を構築するためのテンプレートとして、FooBuilder "
#~ "を利用できることです。\n"
#~ "    pub fn build(self) -> Foo {\n"
#~ "        // FooBuilder の全設定を反映して Foo を構築します。\n"
#~ "        Foo { bar: self.bar }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn builder_test() {\n"
#~ "    let foo = Foo {\n"
#~ "        bar: String::from(\"Y\"),\n"
#~ "    };\n"
#~ "    let foo_from_builder: Foo = FooBuilder::new().name(String::"
#~ "from(\"Y\")).build();\n"
#~ "    assert_eq!(foo, foo_from_builder);\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let mut fb = FooBuilder::new();\n"
#~ "fb.a();\n"
#~ "fb.b();\n"
#~ "let f = fb.build();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let mut fb = FooBuilder::new();\n"
#~ "fb.a();\n"
#~ "fb.b();\n"
#~ "let f = fb.build();\n"
#~ "```"

#~ msgid ""
#~ "- [Description in the style guide](https://web.archive.org/"
#~ "web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/"
#~ "builders.html)\n"
#~ "- [derive_builder](https://crates.io/crates/derive_builder), a crate for "
#~ "automatically\n"
#~ "  implementing this pattern while avoiding the boilerplate.\n"
#~ "- [Constructor pattern](../../idioms/ctor.md) for when construction is "
#~ "simpler.\n"
#~ "- [Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/"
#~ "Builder_pattern)\n"
#~ "- [Construction of complex values](https://web.archive.org/"
#~ "web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety."
#~ "html#c-builder)"
#~ msgstr ""
#~ "- [スタイルガイドの記述](https://web.archive.org/web/20210104103100/"
#~ "https://doc.rust-lang.org/1.12.0/style/ownership/builders.html)\n"
#~ "- [derive_builder](https://crates.io/crates/derive_builder)は、このパター"
#~ "ンを自動的に実装するための crate です。\n"
#~ "- [Constructor パターン](../../idioms/ctor.md) は、より単純な構築のための"
#~ "ものです。\n"
#~ "- [Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/"
#~ "Builder_pattern)\n"
#~ "- [複雑な値の構築](https://web.archive.org/web/20210104103000/https://"
#~ "rust-lang.github.io/api-guidelines/type-safety.html#c-builder)"

#~ msgid "# Fold"
#~ msgstr "# Fold"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// The data we will fold, a simple AST.\n"
#~ "mod ast {\n"
#~ "    pub enum Stmt {\n"
#~ "        Expr(Box<Expr>),\n"
#~ "        Let(Box<Name>, Box<Expr>),\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Name {\n"
#~ "        value: String,\n"
#~ "    }\n"
#~ "\n"
#~ "    pub enum Expr {\n"
#~ "        IntLit(i64),\n"
#~ "        Add(Box<Expr>, Box<Expr>),\n"
#~ "        Sub(Box<Expr>, Box<Expr>),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// The abstract folder\n"
#~ "mod fold {\n"
#~ "    use ast::*;\n"
#~ "\n"
#~ "    pub trait Folder {\n"
#~ "        // A leaf node just returns the node itself. In some cases, we "
#~ "can do this\n"
#~ "        // to inner nodes too.\n"
#~ "        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
#~ "        // Create a new inner node by folding its children.\n"
#~ "        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
#~ "            match *s {\n"
#~ "                Stmt::Expr(e) => Box::new(Stmt::Expr(self."
#~ "fold_expr(e))),\n"
#~ "                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
#~ "self.fold_expr(e))),\n"
#~ "            }\n"
#~ "        }\n"
#~ "        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use fold::*;\n"
#~ "use ast::*;\n"
#~ "\n"
#~ "// An example concrete implementation - renames every name to 'foo'.\n"
#~ "struct Renamer;\n"
#~ "impl Folder for Renamer {\n"
#~ "    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
#~ "        Box::new(Name { value: \"foo\".to_owned() })\n"
#~ "    }\n"
#~ "    // Use the default methods for the other nodes.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// foldされるデータ。単純なAST。\n"
#~ "mod ast {\n"
#~ "    pub enum Stmt {\n"
#~ "        Expr(Box<Expr>),\n"
#~ "        Let(Box<Name>, Box<Expr>),\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Name {\n"
#~ "        value: String,\n"
#~ "    }\n"
#~ "\n"
#~ "    pub enum Expr {\n"
#~ "        IntLit(i64),\n"
#~ "        Add(Box<Expr>, Box<Expr>),\n"
#~ "        Sub(Box<Expr>, Box<Expr>),\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// folderの抽象\n"
#~ "mod fold {\n"
#~ "    use ast::*;\n"
#~ "\n"
#~ "    pub trait Folder {\n"
#~ "        // リーフノードは単にノード自身を返します。多くの状況では、内部"
#~ "ノードについても同様にすることが可能です。\n"
#~ "        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
#~ "        // 子ノードを fold し新たな内部ノードを作成します。\n"
#~ "        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
#~ "            match *s {\n"
#~ "                Stmt::Expr(e) => Box::new(Stmt::Expr(self."
#~ "fold_expr(e))),\n"
#~ "                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
#~ "self.fold_expr(e))),\n"
#~ "            }\n"
#~ "        }\n"
#~ "        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use fold::*;\n"
#~ "use ast::*;\n"
#~ "\n"
#~ "// 具体的な実装例 - すべての名前を 'foo' にリネームします。\n"
#~ "struct Renamer;\n"
#~ "impl Folder for Renamer {\n"
#~ "    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
#~ "        Box::new(Name { value: \"foo\".to_owned() })\n"
#~ "    }\n"
#~ "    // 他のノードに対してはデフォルト実装を使用します。\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Database {\n"
#~ "    connection_string: String,\n"
#~ "    timeout: u32,\n"
#~ "    pool_size: u32,\n"
#~ "}\n"
#~ "\n"
#~ "fn print_database(database: &Database) {\n"
#~ "    println!(\"Connection string: {}\", database.connection_string);\n"
#~ "    println!(\"Timeout: {}\", database.timeout);\n"
#~ "    println!(\"Pool size: {}\", database.pool_size);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut db = Database {\n"
#~ "        connection_string: \"initial string\".to_string(),\n"
#~ "        timeout: 30,\n"
#~ "        pool_size: 100,\n"
#~ "    };\n"
#~ "\n"
#~ "    let connection_string = &mut db.connection_string;\n"
#~ "    print_database(&db);  // Immutable borrow of `db` happens here\n"
#~ "    // *connection_string = \"new string\".to_string();  // Mutable "
#~ "borrow is used\n"
#~ "                                                       // here\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Database {\n"
#~ "    connection_string: String,\n"
#~ "    timeout: u32,\n"
#~ "    pool_size: u32,\n"
#~ "}\n"
#~ "\n"
#~ "fn print_database(database: &Database) {\n"
#~ "    println!(\"Connection string: {}\", database.connection_string);\n"
#~ "    println!(\"Timeout: {}\", database.timeout);\n"
#~ "    println!(\"Pool size: {}\", database.pool_size);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let mut db = Database {\n"
#~ "        connection_string: \"initial string\".to_string(),\n"
#~ "        timeout: 30,\n"
#~ "        pool_size: 100,\n"
#~ "    };\n"
#~ "\n"
#~ "    let connection_string = &mut db.connection_string;\n"
#~ "    print_database(&db);  // `db` の不変借用が発生\n"
#~ "    // *connection_string = \"new string\".to_string();  // ここで可変借用"
#~ "を使用\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// Database is now composed of three structs - ConnectionString, Timeout "
#~ "and PoolSize.\n"
#~ "// Let's decompose it into smaller structs\n"
#~ "#[derive(Debug, Clone)]\n"
#~ "struct ConnectionString(String);\n"
#~ "\n"
#~ "#[derive(Debug, Clone, Copy)]\n"
#~ "struct Timeout(u32);\n"
#~ "\n"
#~ "#[derive(Debug, Clone, Copy)]\n"
#~ "struct PoolSize(u32);\n"
#~ "\n"
#~ "// We then compose these smaller structs back into `Database`\n"
#~ "struct Database {\n"
#~ "    connection_string: ConnectionString,\n"
#~ "    timeout: Timeout,\n"
#~ "    pool_size: PoolSize,\n"
#~ "}\n"
#~ "\n"
#~ "// print_database can then take ConnectionString, Timeout and Poolsize "
#~ "struct instead\n"
#~ "fn print_database(connection_str: ConnectionString, \n"
#~ "                  timeout: Timeout, \n"
#~ "                  pool_size: PoolSize) {\n"
#~ "    println!(\"Connection string: {:?}\", connection_str);\n"
#~ "    println!(\"Timeout: {:?}\", timeout);\n"
#~ "    println!(\"Pool size: {:?}\", pool_size);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // Initialize the Database with the three structs\n"
#~ "    let mut db = Database {\n"
#~ "        connection_string: ConnectionString(\"localhost\".to_string()),\n"
#~ "        timeout: Timeout(30),\n"
#~ "        pool_size: PoolSize(100),\n"
#~ "    };\n"
#~ "\n"
#~ "    let connection_string = &mut db.connection_string;\n"
#~ "    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
#~ "    *connection_string = ConnectionString(\"new string\".to_string());\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// Databaseを3つの構造体 ConnectionStringとTimeout、PoolSize として構成し"
#~ "ます。\n"
#~ "// まず、より小さな構造体へ分解します。\n"
#~ "#[derive(Debug, Clone)]\n"
#~ "struct ConnectionString(String);\n"
#~ "\n"
#~ "#[derive(Debug, Clone, Copy)]\n"
#~ "struct Timeout(u32);\n"
#~ "\n"
#~ "#[derive(Debug, Clone, Copy)]\n"
#~ "struct PoolSize(u32);\n"
#~ "\n"
#~ "// そして `Database` を 3つのより小さな構造体により構成し直します。\n"
#~ "struct Database {\n"
#~ "    connection_string: ConnectionString,\n"
#~ "    timeout: Timeout,\n"
#~ "    pool_size: PoolSize,\n"
#~ "}\n"
#~ "\n"
#~ "// print_database は ConnectionString と Timeout 、 Poolsize を代わりに引"
#~ "き受けることが可能になります。\n"
#~ "fn print_database(connection_str: ConnectionString, \n"
#~ "                  timeout: Timeout, \n"
#~ "                  pool_size: PoolSize) {\n"
#~ "    println!(\"Connection string: {:?}\", connection_str);\n"
#~ "    println!(\"Timeout: {:?}\", timeout);\n"
#~ "    println!(\"Pool size: {:?}\", pool_size);\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // Database を 3つの構造体にて初期化します。\n"
#~ "    let mut db = Database {\n"
#~ "        connection_string: ConnectionString(\"localhost\".to_string()),\n"
#~ "        timeout: Timeout(30),\n"
#~ "        pool_size: PoolSize(100),\n"
#~ "    };\n"
#~ "\n"
#~ "    let connection_string = &mut db.connection_string;\n"
#~ "    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
#~ "    *connection_string = ConnectionString(\"new string\".to_string());\n"
#~ "}\n"
#~ "```"

#~ msgid "# Contain unsafety in small modules"
#~ msgstr "# 安全でないものを小さなモジュールに閉じ込める"

#~ msgid ""
#~ "1. [Object-Based API](./export.md) design that has good memory safety "
#~ "characteristics,\n"
#~ "   and a clean boundary of what is safe and what is unsafe\n"
#~ "\n"
#~ "2. [Type Consolidation into Wrappers](./wrappers.md) - group multiple "
#~ "Rust types\n"
#~ "   together into an opaque \"object\""
#~ msgstr ""
#~ "1.[オブジェクトベースのAPI](./export.md) は優れたメモリ安全性を設計し、\n"
#~ "   何が安全で何が安全でないかの境界を明確にします。\n"
#~ "\n"
#~ "2.[型のラッパーへの統合](./wrappers.md) - 複数のRust型を不透明な「オブジェ"
#~ "クト」にまとめます。"

#~ msgid "# Object-Based APIs"
#~ msgstr "# オブジェクトベースのAPI"

# 8/8もう一度訳すこと。読んだ後に。
#~ msgid ""
#~ "1. All Encapsulated types should be _owned_ by Rust, _managed_ by the "
#~ "user,\n"
#~ "   and _opaque_.\n"
#~ "2. All Transactional data types should be _owned_ by the user, and "
#~ "_transparent_.\n"
#~ "3. All library behavior should be functions acting upon Encapsulated "
#~ "types.\n"
#~ "4. All library behavior should be encapsulated into types not based on "
#~ "structure,\n"
#~ "   but _provenance/lifetime_."
#~ msgstr ""
#~ "1. カプセル化された型はすべて、Rustが _所有_ し、ユーザーが _管理_ し、\n"
#~ "   また _不透過的_ であるべきです。\n"
#~ "2. すべてのトランザクションデータ型は、ユーザが _所有_ し、 _透過的_ であ"
#~ "るべきです。\n"
#~ "3. すべてのライブラリの操作は、カプセル化された型に作用する関数であるべき"
#~ "です。\n"
#~ "4. すべてのライブラリの操作は、構造に基づく型ではなく、_provenance/ライフ"
#~ "タイム_ に基づく型にカプセル化されるべきです。"

#~ msgid ""
#~ "1. Make it easy to use in the target language.\n"
#~ "2. Avoid the API dictating internal unsafety on the Rust side as much as "
#~ "possible.\n"
#~ "3. Keep the potential for memory unsafety and Rust `undefined behaviour` "
#~ "as small\n"
#~ "   as possible."
#~ msgstr ""
#~ "1. ターゲット言語にて使いやすいようにしましょう。\n"
#~ "2. APIが、Rust側での内部的な不安定性を左右することは可能な限り避けましょ"
#~ "う。\n"
#~ "3. メモリの不安定性やRustの `undefined behavior` の可能性をできるだけ小さ"
#~ "く保ちましょう。"

#~ msgid ""
#~ "```C\n"
#~ "struct DBM;\n"
#~ "typedef struct { void *dptr, size_t dsize } datum;\n"
#~ "\n"
#~ "int     dbm_clearerr(DBM *);\n"
#~ "void    dbm_close(DBM *);\n"
#~ "int     dbm_delete(DBM *, datum);\n"
#~ "int     dbm_error(DBM *);\n"
#~ "datum   dbm_fetch(DBM *, datum);\n"
#~ "datum   dbm_firstkey(DBM *);\n"
#~ "datum   dbm_nextkey(DBM *);\n"
#~ "DBM    *dbm_open(const char *, int, mode_t);\n"
#~ "int     dbm_store(DBM *, datum, datum, int);\n"
#~ "```"
#~ msgstr ""
#~ "```C\n"
#~ "struct DBM;\n"
#~ "typedef struct { void *dptr, size_t dsize } datum;\n"
#~ "\n"
#~ "int     dbm_clearerr(DBM *);\n"
#~ "void    dbm_close(DBM *);\n"
#~ "int     dbm_delete(DBM *, datum);\n"
#~ "int     dbm_error(DBM *);\n"
#~ "datum   dbm_fetch(DBM *, datum);\n"
#~ "datum   dbm_firstkey(DBM *);\n"
#~ "datum   dbm_nextkey(DBM *);\n"
#~ "DBM    *dbm_open(const char *, int, mode_t);\n"
#~ "int     dbm_store(DBM *, datum, datum, int);\n"
#~ "```"

#~ msgid ""
#~ "1. Do not call any function with a pointer not returned by `dbm_open` "
#~ "(invalid\n"
#~ "   access or corruption).\n"
#~ "2. Do not call any function on a pointer after close (use after free).\n"
#~ "3. The `dptr` on any `datum` must be `NULL`, or point to a valid slice of "
#~ "memory\n"
#~ "   at the advertised length."
#~ msgstr ""
#~ "1. `dbm_open`が返していないポインタを使って関数を呼び出さないでください "
#~ "(無効なアクセスや破損)。\n"
#~ "2. close後のポインタを使って関数を呼び出さないでください（free の後に使用"
#~ "してください）。\n"
#~ "3. `datum` の `dptr` は `NULL` であるか、または適切な長さの有効なメモリス"
#~ "ライスを指している必要があります。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct Dbm { ... }\n"
#~ "\n"
#~ "impl Dbm {\n"
#~ "    /* ... */\n"
#~ "    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
#~ "    /* ... */\n"
#~ "}\n"
#~ "\n"
#~ "struct DbmKeysIter<'it> {\n"
#~ "    owner: &'it Dbm,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct Dbm { ... }\n"
#~ "\n"
#~ "impl Dbm {\n"
#~ "    /* ... */\n"
#~ "    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
#~ "    /* ... */\n"
#~ "}\n"
#~ "\n"
#~ "struct DbmKeysIter<'it> {\n"
#~ "    owner: &'it Dbm,\n"
#~ "}\n"
#~ "\n"
#~ "impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter "
#~ "{\n"
#~ "    // THIS API IS A BAD IDEA! For real applications, use object-based "
#~ "design instead.\n"
#~ "}\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_next(\n"
#~ "    iter: *mut DbmKeysIter,\n"
#~ "    key_out: *const datum\n"
#~ ") -> libc::c_int {\n"
#~ "    // THIS API IS A BAD IDEA! For real applications, use object-based "
#~ "design instead.\n"
#~ "}\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
#~ "    // THIS API IS A BAD IDEA! For real applications, use object-based "
#~ "design instead.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter "
#~ "{\n"
#~ "    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの"
#~ "設計を使用してください。\n"
#~ "}\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_next(\n"
#~ "    iter: *mut DbmKeysIter,\n"
#~ "    key_out: *const datum\n"
#~ ") -> libc::c_int {\n"
#~ "    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの"
#~ "設計を使用してください。\n"
#~ "}\n"
#~ "#[no_mangle]\n"
#~ "pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
#~ "    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの"
#~ "設計を使用してください。\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```C\n"
#~ "int count_key_sizes(DBM *db) {\n"
#~ "    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!\n"
#~ "    datum key;\n"
#~ "    int len = 0;\n"
#~ "\n"
#~ "    if (!dbm_iter_new(db)) {\n"
#~ "        dbm_close(db);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "\n"
#~ "    int l;\n"
#~ "    while ((l = dbm_iter_next(owner, &key)) >= 0) { // an error is "
#~ "indicated by -1\n"
#~ "        free(key.dptr);\n"
#~ "        len += key.dsize;\n"
#~ "        if (l == 0) { // end of the iterator\n"
#~ "            dbm_close(owner);\n"
#~ "        }\n"
#~ "    }\n"
#~ "    if l >= 0 {\n"
#~ "        return -1;\n"
#~ "    } else {\n"
#~ "        return len;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```C\n"
#~ "int count_key_sizes(DBM *db) {\n"
#~ "    // この関数は使わないでください。微妙な、しかし重大なバグがあります!\n"
#~ "    datum key;\n"
#~ "    int len = 0;\n"
#~ "\n"
#~ "    if (!dbm_iter_new(db)) {\n"
#~ "        dbm_close(db);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "\n"
#~ "    int l;\n"
#~ "    while ((l = dbm_iter_next(owner, &key)) >= 0) { // エラーを -1 で示し"
#~ "ます\n"
#~ "        free(key.dptr);\n"
#~ "        len += key.dsize;\n"
#~ "        if (l == 0) { // 反復終了\n"
#~ "            dbm_close(owner);\n"
#~ "        }\n"
#~ "    }\n"
#~ "    if l >= 0 {\n"
#~ "        return -1;\n"
#~ "    } else {\n"
#~ "        return len;\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. The loop condition sets `l` to zero, and enters the loop because `0 >= "
#~ "0`.\n"
#~ "2. The length is incremented, in this case by zero.\n"
#~ "3. The if statement is true, so the database is closed. There should be a "
#~ "break\n"
#~ "   statement here.\n"
#~ "4. The loop condition executes again, causing a `next` call on the closed "
#~ "object."
#~ msgstr ""
#~ "1. ループの条件式は `l` を 0 に設定し、`0 >= 0` なのでループに入ります。\n"
#~ "2. len が計上されます。この場合 0 です。\n"
#~ "3. if文は真なので、データベースは閉じられます。ここで break文があるはずで"
#~ "した。\n"
#~ "4. ループの条件式が再度実行され、closeされたオブジェクトに対して `next` が"
#~ "呼び出されます。"

#~ msgid ""
#~ "```C\n"
#~ "datum   dbm_firstkey(DBM *);\n"
#~ "datum   dbm_nextkey(DBM *);\n"
#~ "```"
#~ msgstr ""
#~ "```C\n"
#~ "datum   dbm_firstkey(DBM *);\n"
#~ "datum   dbm_nextkey(DBM *);\n"
#~ "```"

#~ msgid "# Type Consolidation into Wrappers"
#~ msgstr "# ラッパーへの型の統合"

#~ msgid ""
#~ "1. The iterator is initialized with `first_key`.\n"
#~ "2. Each call to `next_key` will advance the iterator.\n"
#~ "3. Calls to `next_key` if the iterator is at the end will do nothing.\n"
#~ "4. As noted above, the iterator is \"wrapped into\" the collection "
#~ "(unlike the native\n"
#~ "   Rust API)."
#~ msgstr ""
#~ "1. イテレータは `first_key` で初期化されます。\n"
#~ "2. `next_key` を呼び出すたびにイテレータが進みます。\n"
#~ "3. イテレータが末尾にある場合に `next_key` を呼び出しても何も起こりませ"
#~ "ん。\n"
#~ "4. 上述の通り、イテレータはコレクションに「ラップ」されます(Rust ネイティ"
#~ "ブ のAPI とは異なる部分です)。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct MySetWrapper {\n"
#~ "    myset: MySet,\n"
#~ "    iter_next: usize,\n"
#~ "}\n"
#~ "\n"
#~ "impl MySetWrapper {\n"
#~ "    pub fn first_key(&mut self) -> Option<&Key> {\n"
#~ "        self.iter_next = 0;\n"
#~ "        self.next_key()\n"
#~ "    }\n"
#~ "    pub fn next_key(&mut self) -> Option<&Key> {\n"
#~ "        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
#~ "            self.iter_next += 1;\n"
#~ "            Some(next)\n"
#~ "        } else {\n"
#~ "            None\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct MySetWrapper {\n"
#~ "    myset: MySet,\n"
#~ "    iter_next: usize,\n"
#~ "}\n"
#~ "\n"
#~ "impl MySetWrapper {\n"
#~ "    pub fn first_key(&mut self) -> Option<&Key> {\n"
#~ "        self.iter_next = 0;\n"
#~ "        self.next_key()\n"
#~ "    }\n"
#~ "    pub fn next_key(&mut self) -> Option<&Key> {\n"
#~ "        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
#~ "            self.iter_next += 1;\n"
#~ "            Some(next)\n"
#~ "        } else {\n"
#~ "            None\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct MySetWrapper {\n"
#~ "    myset: MySet,\n"
#~ "    iter_next: usize,\n"
#~ "    // created from a transmuted Box<KeysIter + 'self>\n"
#~ "    iterator: Option<NonNull<KeysIter<'static>>>,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct MySetWrapper {\n"
#~ "    myset: MySet,\n"
#~ "    iter_next: usize,\n"
#~ "    // Box<KeysIter + 'self> を transmute して作成\n"
#~ "    iterator: Option<NonNull<KeysIter<'static>>>,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // other module content\n"
#~ "\n"
#~ "    pub fn myset_store(\n"
#~ "        myset: *mut MySetWrapper,\n"
#~ "        key: datum,\n"
#~ "        value: datum) -> libc::c_int {\n"
#~ "\n"
#~ "        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.\n"
#~ "\n"
#~ "        let myset: &mut MySet = unsafe { // SAFETY: whoops, UB occurs in "
#~ "here!\n"
#~ "            &mut (*myset).myset\n"
#~ "        };\n"
#~ "\n"
#~ "        /* ...check and cast key and value data... */\n"
#~ "\n"
#~ "        match myset.store(casted_key, casted_value) {\n"
#~ "            Ok(_) => 0,\n"
#~ "            Err(e) => e.into()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub mod unsafe_module {\n"
#~ "\n"
#~ "    // モジュールの他のコンテンツ\n"
#~ "\n"
#~ "    pub fn myset_store(\n"
#~ "        myset: *mut MySetWrapper,\n"
#~ "        key: datum,\n"
#~ "        value: datum) -> libc::c_int {\n"
#~ "\n"
#~ "        // このコードを使用しないでください。不具合を実証することは危険で"
#~ "す。\n"
#~ "\n"
#~ "        let myset: &mut MySet = unsafe { // SAFETY: あぁ・・・ここで UB が"
#~ "発生します！\n"
#~ "            &mut (*myset).myset\n"
#~ "        };\n"
#~ "\n"
#~ "        /* ...キーと値のデータをチェックし、キャスト... */\n"
#~ "\n"
#~ "        match myset.store(casted_key, casted_value) {\n"
#~ "            Ok(_) => 0,\n"
#~ "            Err(e) => e.into()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Anti-patterns"
#~ msgstr "# アンチパターン"

#~ msgid "# Clone to satisfy the borrow checker"
#~ msgstr "# 借用チェッカーを満足させるためのクローン"

#~ msgid ""
#~ "```rust\n"
#~ "// define any variable\n"
#~ "let mut x = 5;\n"
#~ "\n"
#~ "// Borrow `x` -- but clone it first\n"
#~ "let y = &mut (x.clone());\n"
#~ "\n"
#~ "// without the x.clone() two lines prior, this line would fail on compile "
#~ "as\n"
#~ "// x has been borrowed\n"
#~ "// thanks to x.clone(), x was never borrowed, and this line will run.\n"
#~ "println!(\"{}\", x);\n"
#~ "\n"
#~ "// perform some action on the borrow to prevent rust from optimizing "
#~ "this\n"
#~ "//out of existence\n"
#~ "*y += 1;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// 変数を定義\n"
#~ "let mut x = 5;\n"
#~ "\n"
#~ "// `x` を借用 -- ただし、先だってクローンする\n"
#~ "let y = &mut (x.clone());\n"
#~ "\n"
#~ "// 2行前の x.clone() 無しでは、xが借用されているためこの行がコンパイルエ"
#~ "ラーになります。\n"
#~ "// x.clone() により、 x は借用されていないため、この行が動作します。\n"
#~ "println!(\"{}\", x);\n"
#~ "\n"
#~ "// Rust がこれを消去する形の最適化を防ぐため、何らかの操作をします。\n"
#~ "*y += 1;\n"
#~ "```"

#~ msgid ""
#~ "- the developer is still new to ownership\n"
#~ "- the code doesn't have great speed or memory constraints\n"
#~ "  (like hackathon projects or prototypes)\n"
#~ "- satisfying the borrow checker is really complicated, and you prefer to\n"
#~ "  optimize readability over performance"
#~ msgstr ""
#~ "- 開発者が所有権に慣れていない\n"
#~ "- コードの速度やメモリに大きな制約がない場合\n"
#~ "  (ハッカソンプロジェクトやプロトタイプなど)\n"
#~ "- 借用チェッカーを満足させることが本当に複雑で難しく、\n"
#~ "  パフォーマンスよりも読みやすさを最適化したい"

#~ msgid ""
#~ "- [`mem::{take(_), replace(_)}` to keep owned values in changed enums](../"
#~ "idioms/mem-replace.md)\n"
#~ "- [`Rc<T>` documentation, which handles .clone() intelligently](http://"
#~ "doc.rust-lang.org/std/rc/)\n"
#~ "- [`Arc<T>` documentation, a thread-safe reference-counting pointer]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html)\n"
#~ "- [Tricks with ownership in Rust](https://web.archive.org/"
#~ "web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)"
#~ msgstr ""
#~ "- [変更するenum値の所有された値を維持する `mem::{take(_), replace(_)}`]"
#~ "(../idioms/mem-replace.md)\n"
#~ "- [`Rc<T>` のドキュメント ( .clone() をインテリジェントに扱う)](http://"
#~ "doc.rust-lang.org/std/rc/)\n"
#~ "- [`Arc<T>` のドキュメント (スレッドセーフな参照カウンタ付きポインタ)]"
#~ "(https://doc.rust-lang.org/std/sync/struct.Arc.html)\n"
#~ "- [Rust における所有権のトリック](https://web.archive.org/"
#~ "web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)"

#~ msgid ""
#~ "```rust\n"
#~ "#![deny(warnings)]\n"
#~ "\n"
#~ "// All is well.\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#![deny(warnings)]\n"
#~ "\n"
#~ "// すべて問題なし\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#![deny(bad_style,\n"
#~ "       const_err,\n"
#~ "       dead_code,\n"
#~ "       improper_ctypes,\n"
#~ "       non_shorthand_field_patterns,\n"
#~ "       no_mangle_generic_items,\n"
#~ "       overflowing_literals,\n"
#~ "       path_statements,\n"
#~ "       patterns_in_fns_without_body,\n"
#~ "       private_in_public,\n"
#~ "       unconditional_recursion,\n"
#~ "       unused,\n"
#~ "       unused_allocation,\n"
#~ "       unused_comparisons,\n"
#~ "       unused_parens,\n"
#~ "       while_true)]\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#![deny(bad_style,\n"
#~ "       const_err,\n"
#~ "       dead_code,\n"
#~ "       improper_ctypes,\n"
#~ "       non_shorthand_field_patterns,\n"
#~ "       no_mangle_generic_items,\n"
#~ "       overflowing_literals,\n"
#~ "       path_statements,\n"
#~ "       patterns_in_fns_without_body,\n"
#~ "       private_in_public,\n"
#~ "       unconditional_recursion,\n"
#~ "       unused,\n"
#~ "       unused_allocation,\n"
#~ "       unused_comparisons,\n"
#~ "       unused_parens,\n"
#~ "       while_true)]\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#![deny(missing_debug_implementations,\n"
#~ "       missing_docs,\n"
#~ "       trivial_casts,\n"
#~ "       trivial_numeric_casts,\n"
#~ "       unused_extern_crates,\n"
#~ "       unused_import_braces,\n"
#~ "       unused_qualifications,\n"
#~ "       unused_results)]\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#![deny(missing_debug_implementations,\n"
#~ "       missing_docs,\n"
#~ "       trivial_casts,\n"
#~ "       trivial_numeric_casts,\n"
#~ "       unused_extern_crates,\n"
#~ "       unused_import_braces,\n"
#~ "       unused_qualifications,\n"
#~ "       unused_results)]\n"
#~ "```"

#~ msgid ""
#~ "- [A collection of all clippy lints](https://rust-lang.github.io/rust-"
#~ "clippy/master)\n"
#~ "- [deprecate attribute] documentation\n"
#~ "- Type `rustc -W help` for a list of lints on your system. Also type\n"
#~ "  `rustc --help` for a general list of options\n"
#~ "- [rust-clippy] is a collection of lints for better Rust code"
#~ msgstr ""
#~ "- [すべての crippy lint](https://rust-lang.github.io/rust-clippy/master)\n"
#~ "- [deprecated属性] のドキュメント\n"
#~ "- `rustc -W help` と入力するとあなたのシステム上の lint のリストが表示され"
#~ "ます。\n"
#~ "  また`rustc --help` と入力すると一般的なオプションのリストが表示されま"
#~ "す\n"
#~ "- [rust-clippy] はより良い Rust コードのための lint のコレクションです"

#~ msgid ""
#~ "```java\n"
#~ "class Foo {\n"
#~ "    void m() { ... }\n"
#~ "}\n"
#~ "\n"
#~ "class Bar extends Foo {}\n"
#~ "\n"
#~ "public static void main(String[] args) {\n"
#~ "    Bar b = new Bar();\n"
#~ "    b.m();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```java\n"
#~ "class Foo {\n"
#~ "    void m() { ... }\n"
#~ "}\n"
#~ "\n"
#~ "class Bar extends Foo {}\n"
#~ "\n"
#~ "public static void main(String[] args) {\n"
#~ "    Bar b = new Bar();\n"
#~ "    b.m();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Foo {}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    fn m(&self) {\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Bar {\n"
#~ "    f: Foo,\n"
#~ "}\n"
#~ "\n"
#~ "impl Deref for Bar {\n"
#~ "    type Target = Foo;\n"
#~ "    fn deref(&self) -> &Foo {\n"
#~ "        &self.f\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar { f: Foo {} };\n"
#~ "    b.m();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::ops::Deref;\n"
#~ "\n"
#~ "struct Foo {}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    fn m(&self) {\n"
#~ "        //..\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "struct Bar {\n"
#~ "    f: Foo,\n"
#~ "}\n"
#~ "\n"
#~ "impl Deref for Bar {\n"
#~ "    type Target = Foo;\n"
#~ "    fn deref(&self) -> &Foo {\n"
#~ "        &self.f\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar { f: Foo {} };\n"
#~ "    b.m();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "impl Bar {\n"
#~ "    fn m(&self) {\n"
#~ "        self.f.m()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "impl Bar {\n"
#~ "    fn m(&self) {\n"
#~ "        self.f.m()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "# Programming paradigms"
#~ msgstr "# プログラミングパラダイム"

#~ msgid ""
#~ "```rust\n"
#~ "let mut sum = 0;\n"
#~ "for i in 1..11 {\n"
#~ "    sum += i;\n"
#~ "}\n"
#~ "println!(\"{}\", sum);\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "let mut sum = 0;\n"
#~ "for i in 1..11 {\n"
#~ "    sum += i;\n"
#~ "}\n"
#~ "println!(\"{}\", sum);\n"
#~ "```"

#~ msgid ""
#~ "| `i` | `sum` |\n"
#~ "| :-: | :---: |\n"
#~ "|  1  |   1   |\n"
#~ "|  2  |   3   |\n"
#~ "|  3  |   6   |\n"
#~ "|  4  |  10   |\n"
#~ "|  5  |  15   |\n"
#~ "|  6  |  21   |\n"
#~ "|  7  |  28   |\n"
#~ "|  8  |  36   |\n"
#~ "|  9  |  45   |\n"
#~ "| 10  |  55   |"
#~ msgstr ""
#~ "| `i` | `sum` |\n"
#~ "| :-: | :---: |\n"
#~ "|  1  |   1   |\n"
#~ "|  2  |   3   |\n"
#~ "|  3  |   6   |\n"
#~ "|  4  |  10   |\n"
#~ "|  5  |  15   |\n"
#~ "|  6  |  21   |\n"
#~ "|  7  |  28   |\n"
#~ "|  8  |  36   |\n"
#~ "|  9  |  45   |\n"
#~ "| 10  |  55   |"

#~ msgid ""
#~ "```rust\n"
#~ "println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
#~ "```"

#~ msgid ""
#~ "| `a` | `b` | result |\n"
#~ "| :-: | :-: | :----: |\n"
#~ "|  0  |  1  |   1    |\n"
#~ "|  1  |  2  |   3    |\n"
#~ "|  3  |  3  |   6    |\n"
#~ "|  6  |  4  |   10   |\n"
#~ "| 10  |  5  |   15   |\n"
#~ "| 15  |  6  |   21   |\n"
#~ "| 21  |  7  |   28   |\n"
#~ "| 28  |  8  |   36   |\n"
#~ "| 36  |  9  |   45   |\n"
#~ "| 45  | 10  |   55   |"
#~ msgstr ""
#~ "| `a` | `b` | result |\n"
#~ "| :-: | :-: | :----: |\n"
#~ "|  0  |  1  |   1    |\n"
#~ "|  1  |  2  |   3    |\n"
#~ "|  3  |  3  |   6    |\n"
#~ "|  6  |  4  |   10   |\n"
#~ "| 10  |  5  |   15   |\n"
#~ "| 15  |  6  |   21   |\n"
#~ "| 21  |  7  |   28   |\n"
#~ "| 28  |  8  |   36   |\n"
#~ "| 36  |  9  |   45   |\n"
#~ "| 45  | 10  |   55   |"

#~ msgid "# Generics as Type Classes"
#~ msgstr "# 型クラスとしてのジェネリック"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "enum AuthInfo {\n"
#~ "    Nfs(crate::nfs::AuthInfo),\n"
#~ "    Bootp(crate::bootp::AuthInfo),\n"
#~ "}\n"
#~ "\n"
#~ "struct FileDownloadRequest {\n"
#~ "    file_name: PathBuf,\n"
#~ "    authentication: AuthInfo,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "enum AuthInfo {\n"
#~ "    Nfs(crate::nfs::AuthInfo),\n"
#~ "    Bootp(crate::bootp::AuthInfo),\n"
#~ "}\n"
#~ "\n"
#~ "struct FileDownloadRequest {\n"
#~ "    file_name: PathBuf,\n"
#~ "    authentication: AuthInfo,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "struct FileDownloadRequest {\n"
#~ "    file_name: PathBuf,\n"
#~ "    authentication: AuthInfo,\n"
#~ "    mount_point: Option<PathBuf>,\n"
#~ "}\n"
#~ "\n"
#~ "impl FileDownloadRequest {\n"
#~ "    // ... other methods ...\n"
#~ "\n"
#~ "    /// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
#~ "    /// return None.\n"
#~ "    pub fn mount_point(&self) -> Option<&Path> {\n"
#~ "        self.mount_point.as_ref()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "struct FileDownloadRequest {\n"
#~ "    file_name: PathBuf,\n"
#~ "    authentication: AuthInfo,\n"
#~ "    mount_point: Option<PathBuf>,\n"
#~ "}\n"
#~ "\n"
#~ "impl FileDownloadRequest {\n"
#~ "    // ... ほかのメソッド ...\n"
#~ "\n"
#~ "    /// NFSリクエストであれば、NFSマウントポイントを取得する。そうでなけれ"
#~ "ば None を返す。\n"
#~ "    pub fn mount_point(&self) -> Option<&Path> {\n"
#~ "        self.mount_point.as_ref()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use std::path::{Path, PathBuf};\n"
#~ "\n"
#~ "mod nfs {\n"
#~ "    #[derive(Clone)]\n"
#~ "    pub(crate) struct AuthInfo(String); // NFS session management "
#~ "omitted\n"
#~ "}\n"
#~ "\n"
#~ "mod bootp {\n"
#~ "    pub(crate) struct AuthInfo(); // no authentication in bootp\n"
#~ "}\n"
#~ "\n"
#~ "// private module, lest outside users invent their own protocol kinds!\n"
#~ "mod proto_trait {\n"
#~ "    use std::path::{Path, PathBuf};\n"
#~ "    use super::{bootp, nfs};\n"
#~ "\n"
#~ "    pub(crate) trait ProtoKind {\n"
#~ "        type AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo;\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Nfs {\n"
#~ "        auth: nfs::AuthInfo,\n"
#~ "        mount_point: PathBuf,\n"
#~ "    }\n"
#~ "\n"
#~ "    impl Nfs {\n"
#~ "        pub(crate) fn mount_point(&self) -> &Path {\n"
#~ "            &self.mount_point\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    impl ProtoKind for Nfs {\n"
#~ "        type AuthInfo = nfs::AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo {\n"
#~ "            self.auth.clone()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Bootp(); // no additional metadata\n"
#~ "\n"
#~ "    impl ProtoKind for Bootp {\n"
#~ "        type AuthInfo = bootp::AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo {\n"
#~ "            bootp::AuthInfo()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use proto_trait::ProtoKind; // keep internal to prevent impls\n"
#~ "pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them\n"
#~ "\n"
#~ "struct FileDownloadRequest<P: ProtoKind> {\n"
#~ "    file_name: PathBuf,\n"
#~ "    protocol: P,\n"
#~ "}\n"
#~ "\n"
#~ "// all common API parts go into a generic impl block\n"
#~ "impl<P: ProtoKind> FileDownloadRequest<P> {\n"
#~ "    fn file_path(&self) -> &Path {\n"
#~ "        &self.file_name\n"
#~ "    }\n"
#~ "\n"
#~ "    fn auth_info(&self) -> P::AuthInfo {\n"
#~ "        self.protocol.auth_info()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// all protocol-specific impls go into their own block\n"
#~ "impl FileDownloadRequest<Nfs> {\n"
#~ "    fn mount_point(&self) -> &Path {\n"
#~ "        self.protocol.mount_point()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // your code here\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::path::{Path, PathBuf};\n"
#~ "\n"
#~ "mod nfs {\n"
#~ "    #[derive(Clone)]\n"
#~ "    pub(crate) struct AuthInfo(String); // NFSセッション管理は省略\n"
#~ "}\n"
#~ "\n"
#~ "mod bootp {\n"
#~ "    pub(crate) struct AuthInfo(); // bootpでは認証なし\n"
#~ "}\n"
#~ "\n"
#~ "// 外部のユーザが独自のプロトコルを作れないようにするため、 private なモ"
#~ "ジュールです！\n"
#~ "mod proto_trait {\n"
#~ "    use std::path::{Path, PathBuf};\n"
#~ "    use super::{bootp, nfs};\n"
#~ "\n"
#~ "    pub(crate) trait ProtoKind {\n"
#~ "        type AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo;\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Nfs {\n"
#~ "        auth: nfs::AuthInfo,\n"
#~ "        mount_point: PathBuf,\n"
#~ "    }\n"
#~ "\n"
#~ "    impl Nfs {\n"
#~ "        pub(crate) fn mount_point(&self) -> &Path {\n"
#~ "            &self.mount_point\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    impl ProtoKind for Nfs {\n"
#~ "        type AuthInfo = nfs::AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo {\n"
#~ "            self.auth.clone()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    pub struct Bootp(); // 追加のメタデータなし\n"
#~ "\n"
#~ "    impl ProtoKind for Bootp {\n"
#~ "        type AuthInfo = bootp::AuthInfo;\n"
#~ "        fn auth_info(&self) -> Self::AuthInfo {\n"
#~ "            bootp::AuthInfo()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "use proto_trait::ProtoKind; // impl を防ぐため、非publicを維持\n"
#~ "pub use proto_trait::{Nfs, Bootp}; // 呼び出し元に見えるよう再エクスポー"
#~ "ト\n"
#~ "\n"
#~ "struct FileDownloadRequest<P: ProtoKind> {\n"
#~ "    file_name: PathBuf,\n"
#~ "    protocol: P,\n"
#~ "}\n"
#~ "\n"
#~ "// すべての共通のAPIは、ジェネリックの impl ブロックに入れます\n"
#~ "impl<P: ProtoKind> FileDownloadRequest<P> {\n"
#~ "    fn file_path(&self) -> &Path {\n"
#~ "        &self.file_name\n"
#~ "    }\n"
#~ "\n"
#~ "    fn auth_info(&self) -> P::AuthInfo {\n"
#~ "        self.protocol.auth_info()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// すべてのプロトコル固有の実装は、それぞれのブロックに入れます\n"
#~ "impl FileDownloadRequest<Nfs> {\n"
#~ "    fn mount_point(&self) -> &Path {\n"
#~ "        self.protocol.mount_point()\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    // ここにあなたのコード\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn main() {\n"
#~ "    let mut socket = crate::bootp::listen()?;\n"
#~ "    while let Some(request) = socket.next_request()? {\n"
#~ "        match request.mount_point().as_ref()\n"
#~ "            \"/secure\" => socket.send(\"Access denied\"),\n"
#~ "            _ => {} // continue on...\n"
#~ "        }\n"
#~ "        // Rest of the code here\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn main() {\n"
#~ "    let mut socket = crate::bootp::listen()?;\n"
#~ "    while let Some(request) = socket.next_request()? {\n"
#~ "        match request.mount_point().as_ref()\n"
#~ "            \"/secure\" => socket.send(\"Access denied\"),\n"
#~ "            _ => {} // 続く...\n"
#~ "        }\n"
#~ "        // ここに残りのコード\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- `Vec<u8>` can be cast from a String, unlike every other type of "
#~ "`Vec<T>`.[^1]\n"
#~ "- They can also be cast into a binary heap, but only if they contain a "
#~ "type\n"
#~ "  that implements the `Ord` trait.[^2]\n"
#~ "- The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
#~ msgstr ""
#~ "- `Vec<u8>` は、他の全ての `Vec<T>` の型とは異なり、Stringからキャストする"
#~ "ことができます。[^1]\n"
#~ "- また、バイナリヒープにキャストすることもできます。\n"
#~ "  ただしそれが `Ord` トレイトを実装している場合に限ります。[^2]\n"
#~ "- `to_string` メソッドは、 `str` 型に対しての `Cow` について特殊化されてい"
#~ "ます。[^3]"

#~ msgid "# Lenses and Prisms"
#~ msgstr "# Lens と Prism"

#~ msgid "## Lenses: Uniform Access Across Types"
#~ msgstr "## Lenses: 型を問わない統一的なアクセス"

#~ msgid ""
#~ "A lens is a concept from functional programming languages that allows\n"
#~ "accessing parts of a data type in an abstract, unified way.[^1]\n"
#~ "In basic concept, it is similar to the way Rust traits work with type "
#~ "erasure,\n"
#~ "but it has a bit more power and flexibility."
#~ msgstr ""
#~ "Lens は関数型プログラミング言語の概念で、データ型の一部に抽象的かつ統一的"
#~ "な方法でアクセスすることを可能にします。[^1]\n"
#~ "基本的な概念としては、Rust の trait が型消去を行うのと似ていますが、もう少"
#~ "し強力で柔軟性があります。"

#~ msgid ""
#~ "For example, suppose a bank contains several JSON formats for customer\n"
#~ "data.\n"
#~ "This is because they come from different databases or legacy systems.\n"
#~ "One database contains the data needed to perform credit checks:"
#~ msgstr ""
#~ "たとえば、ある銀行が顧客データ用に複数のJSON形式を持っているとします。\n"
#~ "これは、それらが異なるデータベースまたはレガシーシステムから来たものだから"
#~ "です。\n"
#~ "あるデータベースには、信用調査を実行するために必要なデータが含まれていま"
#~ "す："

#~ msgid ""
#~ "```json\n"
#~ "{ \"name\": \"Jane Doe\",\n"
#~ "  \"dob\": \"2002-02-24\",\n"
#~ "  [...]\n"
#~ "  \"customer_id\": 1048576332,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{ \"name\": \"Jane Doe\",\n"
#~ "  \"dob\": \"2002-02-24\",\n"
#~ "  [...]\n"
#~ "  \"customer_id\": 1048576332,\n"
#~ "}\n"
#~ "```"

#~ msgid "Another one contains the account information:"
#~ msgstr "他の1つは口座情報を含んでいます："

#~ msgid ""
#~ "```json\n"
#~ "{ \"customer_id\": 1048576332,\n"
#~ "  \"accounts\": [\n"
#~ "      { \"account_id\": 2121,\n"
#~ "        \"account_type: \"savings\",\n"
#~ "        \"joint_customer_ids\": [],\n"
#~ "        [...]\n"
#~ "      },\n"
#~ "      { \"account_id\": 2122,\n"
#~ "        \"account_type: \"checking\",\n"
#~ "        \"joint_customer_ids\": [1048576333],\n"
#~ "        [...]\n"
#~ "      },\n"
#~ "  ]\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{ \"customer_id\": 1048576332,\n"
#~ "  \"accounts\": [\n"
#~ "      { \"account_id\": 2121,\n"
#~ "        \"account_type: \"savings\",\n"
#~ "        \"joint_customer_ids\": [],\n"
#~ "        [...]\n"
#~ "      },\n"
#~ "      { \"account_id\": 2122,\n"
#~ "        \"account_type: \"checking\",\n"
#~ "        \"joint_customer_ids\": [1048576333],\n"
#~ "        [...]\n"
#~ "      },\n"
#~ "  ]\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Notice that both types have a customer ID number which corresponds to a "
#~ "person.\n"
#~ "How would a single function handle both records of different types?"
#~ msgstr ""
#~ "どちらの型も、個人に対応する顧客ID番号を持っていることに注目してくださ"
#~ "い。\n"
#~ "1つの関数が、異なる型である両レコードを処理するには、どうすればよいでしょ"
#~ "うか？"

#~ msgid ""
#~ "In Rust, a `struct` could represent each of these types, and a trait "
#~ "would have\n"
#~ "a `get_customer_id` function they would implement:"
#~ msgstr ""
#~ "Rust では、 `struct` はこれらの型を表現することが可能です。\n"
#~ "それらが実装する `get_customer_id` 関数をトレイトが持ちます："

#~ msgid ""
#~ "```rust\n"
#~ "use std::collections::HashSet;\n"
#~ "\n"
#~ "pub struct Account {\n"
#~ "    account_id: u32,\n"
#~ "    account_type: String,\n"
#~ "    // other fields omitted\n"
#~ "}\n"
#~ "\n"
#~ "pub trait CustomerId {\n"
#~ "    fn get_customer_id(&self) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "pub struct CreditRecord {\n"
#~ "    customer_id: u64,\n"
#~ "    name: String,\n"
#~ "    dob: String,\n"
#~ "    // other fields omitted\n"
#~ "}\n"
#~ "\n"
#~ "impl CustomerId for CreditRecord {\n"
#~ "    fn get_customer_id(&self) -> u64 {\n"
#~ "        self.customer_id\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct AccountRecord {\n"
#~ "    customer_id: u64,\n"
#~ "    accounts: Vec<Account>,\n"
#~ "}\n"
#~ "\n"
#~ "impl CustomerId for AccountRecord {\n"
#~ "    fn get_customer_id(&self) -> u64 {\n"
#~ "        self.customer_id\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// static polymorphism: only one type, but each function call can choose "
#~ "it\n"
#~ "fn unique_ids_set<R: CustomerId>(records: &[R]) -> HashSet<u64> {\n"
#~ "    records.iter().map(|r| r.get_customer_id()).collect()\n"
#~ "}\n"
#~ "\n"
#~ "// dynamic dispatch: iterates over any type with a customer ID, "
#~ "collecting all\n"
#~ "// values together\n"
#~ "fn unique_ids_iter<I>(iterator: I) -> HashSet<u64>\n"
#~ "    where I: Iterator<Item=Box<dyn CustomerId>>\n"
#~ "{\n"
#~ "    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use std::collections::HashSet;\n"
#~ "\n"
#~ "pub struct Account {\n"
#~ "    account_id: u32,\n"
#~ "    account_type: String,\n"
#~ "    // 他のフィールドは省略\n"
#~ "}\n"
#~ "\n"
#~ "pub trait CustomerId {\n"
#~ "    fn get_customer_id(&self) -> u64;\n"
#~ "}\n"
#~ "\n"
#~ "pub struct CreditRecord {\n"
#~ "    customer_id: u64,\n"
#~ "    name: String,\n"
#~ "    dob: String,\n"
#~ "    // 他のフィールドは省略\n"
#~ "}\n"
#~ "\n"
#~ "impl CustomerId for CreditRecord {\n"
#~ "    fn get_customer_id(&self) -> u64 {\n"
#~ "        self.customer_id\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "pub struct AccountRecord {\n"
#~ "    customer_id: u64,\n"
#~ "    accounts: Vec<Account>,\n"
#~ "}\n"
#~ "\n"
#~ "impl CustomerId for AccountRecord {\n"
#~ "    fn get_customer_id(&self) -> u64 {\n"
#~ "        self.customer_id\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "// 静的ポリモーフィズム： 型は1つのみ、しかし各関数呼び出しはそれを指定可"
#~ "能です\n"
#~ "fn unique_ids_set<R: CustomerId>(records: &[R]) -> HashSet<u64> {\n"
#~ "    records.iter().map(|r| r.get_customer_id()).collect()\n"
#~ "}\n"
#~ "\n"
#~ "// 動的ディスパッチ： 顧客IDを持つ任意の型を反復処理し、すべての値を収集し"
#~ "ます\n"
#~ "fn unique_ids_iter<I>(iterator: I) -> HashSet<u64>\n"
#~ "    where I: Iterator<Item=Box<dyn CustomerId>>\n"
#~ "{\n"
#~ "    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "Lenses, however, allow the code supporting customer ID to be moved from "
#~ "the\n"
#~ "_type_ to the _accessor function_.\n"
#~ "Rather than implementing a trait on each type, all matching structures "
#~ "can\n"
#~ "simply be accessed the same way."
#~ msgstr ""
#~ "しかし、Lens は、顧客IDをサポートするコードを、_型_ から _アクセッサ関数_ "
#~ "に移すことを可能にします。\n"
#~ "それぞれの型に trait を実装するのではなく、すべてのマッチする構造体に同じ"
#~ "方法でアクセスすることができるようになります。"

#~ msgid ""
#~ "While the Rust language itself does not support this (type erasure is "
#~ "the\n"
#~ "preferred solution to this problem), the [lens-rs crate](https://github."
#~ "com/TOETOE55/lens-rs/blob/master/guide.md) allows code\n"
#~ "that feels like this to be written with macros:"
#~ msgstr ""
#~ "Rust言語自体はこれをサポートしていません(型消去がこの問題の推奨される解決"
#~ "策です)が\n"
#~ "、[lens-rs crate](https://github.com/TOETOE55/lens-rs/blob/master/guide."
#~ "md)では、\n"
#~ "マクロを使ってこのようなコードを書くことができます："

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use std::collections::HashSet;\n"
#~ "\n"
#~ "use lens_rs::{optics, Lens, LensRef, Optics};\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Lens /* derive to allow lenses to work */)]\n"
#~ "pub struct CreditRecord {\n"
#~ "    #[optic(ref)] // macro attribute to allow viewing this field\n"
#~ "    customer_id: u64,\n"
#~ "    name: String,\n"
#~ "    dob: String,\n"
#~ "    // other fields omitted\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Clone, Debug)]\n"
#~ "pub struct Account {\n"
#~ "    account_id: u32,\n"
#~ "    account_type: String,\n"
#~ "    // other fields omitted\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Lens)]\n"
#~ "pub struct AccountRecord {\n"
#~ "    #[optic(ref)]\n"
#~ "    customer_id: u64,\n"
#~ "    accounts: Vec<Account>,\n"
#~ "}\n"
#~ "\n"
#~ "fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -> HashSet<u64>\n"
#~ "where\n"
#~ "    T: LensRef<Optics![customer_id], u64>, // any type with this field\n"
#~ "{\n"
#~ "    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use std::collections::HashSet;\n"
#~ "\n"
#~ "use lens_rs::{optics, Lens, LensRef, Optics};\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Lens /* lensが動作するようにderive */)]\n"
#~ "pub struct CreditRecord {\n"
#~ "    #[optic(ref)] // このフィールドを可視とするためのマクロ属性\n"
#~ "    customer_id: u64,\n"
#~ "    name: String,\n"
#~ "    dob: String,\n"
#~ "    // other fields omitted\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Clone, Debug)]\n"
#~ "pub struct Account {\n"
#~ "    account_id: u32,\n"
#~ "    account_type: String,\n"
#~ "    // 他のフィールドは省略\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Clone, Debug, Lens)]\n"
#~ "pub struct AccountRecord {\n"
#~ "    #[optic(ref)]\n"
#~ "    customer_id: u64,\n"
#~ "    accounts: Vec<Account>,\n"
#~ "}\n"
#~ "\n"
#~ "fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -> HashSet<u64>\n"
#~ "where\n"
#~ "    T: LensRef<Optics![customer_id], u64>, // このフィールドを持つあらゆる"
#~ "型\n"
#~ "{\n"
#~ "    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The version of `unique_ids_lens` shown here allows any type to be in the "
#~ "iterator,\n"
#~ "so long as it has an attribute called `customer_id` which can be accessed "
#~ "by\n"
#~ "the function.\n"
#~ "This is how most functional programming languages operate on lenses."
#~ msgstr ""
#~ "ここで紹介する `unique_ids_lens` のバージョンは、イテレータの中の型が\n"
#~ "関数からアクセス可能な `customer_id` という属性を持っている限り、どんな型"
#~ "あっても許容します。\n"
#~ "ほとんどの関数型プログラミング言語はこのようにLensを操作します。"

#~ msgid ""
#~ "Rather than macros, they achieve this with a technique known as "
#~ "\"currying\".\n"
#~ "That is, they \"partially construct\" the function, leaving the type of "
#~ "the\n"
#~ "final parameter (the value being operated on) unfilled until the function "
#~ "is\n"
#~ "called.\n"
#~ "Thus it can be called with different types dynamically even from one "
#~ "place in\n"
#~ "the code.\n"
#~ "That is what the `optics!` and `view_ref` in the example above simulates."
#~ msgstr ""
#~ "それらは、これをマクロではなく、「カリー化」と呼ばれるテクニックで実現しま"
#~ "す。\n"
#~ "つまり、関数を「部分的に構築」し、関数が呼び出されるまで、最終パラメータ"
#~ "（操作される値）の型は未記入のままにしておくのです。\n"
#~ "そのため、コード内の一か所に定義されたものであっても、様々な型に対して動的"
#~ "に呼び出すことが可能になります。\n"
#~ "上の例の `optics!` と `view_ref` はそれをシミュレートしています。"

#~ msgid ""
#~ "The functional approach need not be restricted to accessing members.\n"
#~ "More powerful lenses can be created which both _set_ and _get_ data in a\n"
#~ "structure.\n"
#~ "But the concept really becomes interesting when used as a building block "
#~ "for\n"
#~ "composition.\n"
#~ "That is where the concept appears more clearly in Rust."
#~ msgstr ""
#~ "関数的アプローチは、メンバーへのアクセスに限定される必要はありません。\n"
#~ "構造体のデータの _get_ と _set_ 両方を扱うより強力なレンズを作成することが"
#~ "できます。\n"
#~ "しかし、このコンセプトが本当に面白いものとなるのは、コンポジションの構成要"
#~ "素として使用されるときです。\n"
#~ "Rustでは、このコンセプトがより明確に現れます。"

#~ msgid "## Prisms: A Higher-Order form of \"Optics\""
#~ msgstr "## Prism : 「光学」の高次形式"

#~ msgid ""
#~ "A simple function such as `unique_ids_lens` above operates on a single "
#~ "lens.\n"
#~ "A _prism_ is a function that operates on a _family_ of lenses.\n"
#~ "It is one conceptual level higher, using lenses as a building block, and\n"
#~ "continuing the metaphor, is part of a family of \"optics\".\n"
#~ "It is the main one that is useful in understanding Rust APIs, so will be "
#~ "the\n"
#~ "focus here."
#~ msgstr ""
#~ "上記の`unique_ids_lens`のような単純な関数は1つの lens を扱います。\n"
#~ "_prism_ は lens の _ファミリー_ を扱う関数です。\n"
#~ "これは、lens を構成要素として使用する、1つ上の概念的なレベルであり、メタ"
#~ "ファーに則って言えば、「光学」のファミリーの一部です。\n"
#~ "RustのAPIを理解する上で有用なものとして、主要なものであるため、ここで取り"
#~ "上げます。"

#~ msgid ""
#~ "The same way that traits allow \"lens-like\" design with static "
#~ "polymorphism and\n"
#~ "dynamic dispatch, prism-like designs appear in Rust APIs which split "
#~ "problems\n"
#~ "into multiple associated types to be composed.\n"
#~ "A good example of this is the traits in the parsing crate _Serde_."
#~ msgstr ""
#~ "静的なポリモーフィズムと動的なディスパッチで「lens のような」設計が可能と"
#~ "なることと同じように、 \n"
#~ "問題を複数の関連型に分割して構成するという prism のような設計がRust APIに"
#~ "登場します。\n"
#~ "この良い例が、構文解析クレート _Serde_ のトレイトです。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub trait Deserializer<'de>: Sized {\n"
#~ "    type Error: Error;\n"
#~ "\n"
#~ "    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
#~ "Error>\n"
#~ "    where\n"
#~ "        V: Visitor<'de>;\n"
#~ "\n"
#~ "    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::"
#~ "Error>\n"
#~ "    where\n"
#~ "        V: Visitor<'de>;\n"
#~ "\n"
#~ "    // remainder ommitted\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub trait Deserializer<'de>: Sized {\n"
#~ "    type Error: Error;\n"
#~ "\n"
#~ "    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
#~ "Error>\n"
#~ "    where\n"
#~ "        V: Visitor<'de>;\n"
#~ "\n"
#~ "    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::"
#~ "Error>\n"
#~ "    where\n"
#~ "        V: Visitor<'de>;\n"
#~ "\n"
#~ "    // あとは省略\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "For a trait that is just supposed to parse data from a format and return "
#~ "a\n"
#~ "value, this looks odd."
#~ msgstr ""
#~ "トレイトがフォーマット中のデータをパースして値を返すものであると考えると、"
#~ "これは奇妙なものに見えます。"

#~ msgid "Why are all the return types type erased?"
#~ msgstr "なぜ戻り値の型はすべて消去されるのでしょうか？"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub trait Visitor<'de>: Sized {\n"
#~ "    type Value;\n"
#~ "\n"
#~ "    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    // remainder omitted\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub trait Visitor<'de>: Sized {\n"
#~ "    type Value;\n"
#~ "\n"
#~ "    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n"
#~ "    where\n"
#~ "        E: Error;\n"
#~ "\n"
#~ "    // あとは省略\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "The job of the `Visitor` type is to construct values in the _Serde_ data "
#~ "model,\n"
#~ "which are represented by its associated `Value` type."
#~ msgstr ""
#~ "`Visitor` 型の仕事は _Serde_ データモデルの中に、関連付けられた `Value` 型"
#~ "によって表現される値を構築することです。"

#~ msgid ""
#~ "These values represent parts of the Rust value being deserialized.\n"
#~ "If this fails, it returns an `Error` type - an error type determined by "
#~ "the\n"
#~ "`Deserializer` when its methods were called."
#~ msgstr ""
#~ "これらの値は、デシリアライズされる Rust の値の一部を表します。\n"
#~ "失敗した場合は `Error` 型を返します。\n"
#~ "`Deserializer` によって、メソッドが呼び出されたときに決定されたエラー型で"
#~ "す。"

# 最後の `Value` トレイトって、 `Visitor` トレイトの誤記じゃない？ `Value` はトレイトじゃない・・・よね？
# うーん保留。
#~ msgid ""
#~ "This highlights that `Deserializer` is similar to `CustomerId` from "
#~ "earlier,\n"
#~ "allowing any format parser which implements it to create `Value`s based "
#~ "on what\n"
#~ "it parsed.\n"
#~ "The `Value` trait is acting like a lens in functional programming "
#~ "languages."
#~ msgstr ""
#~ "これは `Deserializer` が先ほどの `CustomerId` と似ていることを強調していま"
#~ "す。\n"
#~ "つまり、このトレイトを実装するあらゆるフォーマットのパーサは、それが何を"
#~ "パースするかに基づいて `Value` を作成することが可能です。\n"
#~ "`Value` トレイトは関数型プログラミング言語における lens のように振舞いま"
#~ "す。"

#~ msgid ""
#~ "But unlike the `CustomerId` trait, the return types of `Visitor` methods "
#~ "are\n"
#~ "_generic_, and the concrete `Value` type is _determined by the Visitor "
#~ "itself_."
#~ msgstr ""
#~ "しかし、 `CustomerId` トレイトと異なり、 `Visitor` メソッドの戻り値の型は "
#~ "_generic_ です。\n"
#~ "そして、具体的な `Value` の型は _Visitor 自身によって決定_ します。"

#~ msgid ""
#~ "Instead of acting as one lens, it effectively acts as a family of\n"
#~ "lenses, one for each concrete type of `Visitor`."
#~ msgstr ""
#~ "1つの lens として機能するのではなく、 `Visitor` の具体的な型すべてのため"
#~ "の、lens のファミリーとして実質的には機能します。"

#~ msgid ""
#~ "The `Deserializer` API is based on having a generic set of \"lenses\" "
#~ "work across\n"
#~ "a set of other generic types for \"observation\".\n"
#~ "It is a _prism_."
#~ msgstr ""
#~ "`Deserializer` のAPIは、「観察」のために、ジェネリックな「lens」の集合を\n"
#~ "他のジェネリックな型の集合に対して動作させることに基づいています。\n"
#~ "これが _prism_ です。"

#~ msgid ""
#~ "For example, consider the identity record from earlier but simplified:"
#~ msgstr "例えば、先ほどのIDレコードを単純化して考えてみましょう："

#~ msgid ""
#~ "```json\n"
#~ "{ \"name\": \"Jane Doe\",\n"
#~ "  \"customer_id\": 1048576332,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{ \"name\": \"Jane Doe\",\n"
#~ "  \"customer_id\": 1048576332,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. The user would call a library function to deserialize the data. This "
#~ "would\n"
#~ "   create a `Deserializer` based on the JSON format.\n"
#~ "1. Based on the fields in the struct, a `Visitor` would be created (more "
#~ "on\n"
#~ "   that in a moment) which knows how to create each type in a generic "
#~ "data\n"
#~ "   model that was needed to represent it: `u64` and `String`.\n"
#~ "1. The deserializer would make calls to the `Visitor` as it parsed "
#~ "items.\n"
#~ "1. The `Visitor` would indicate if the items found were expected, and if "
#~ "not,\n"
#~ "   raise an error to indicate deserialization has failed."
#~ msgstr ""
#~ "1. ユーザーはライブラリ関数を呼び出してデータをデシリアライズします。これ"
#~ "は\n"
#~ "   JSON のフォーマットに基づいた `Deserializer` を作成します。\n"
#~ "1. 構造体のフィールドに基づいてそれを表現するのに必要となる汎用データモデ"
#~ "ルの各型(`u64` と `String`)の作成方法を知っている `Visitor` が作成(詳細は"
#~ "後述)されます。\n"
#~ "1. デシリアライザはアイテムをパースする際に `Visitor` を呼び出します。\n"
#~ "1. `Visitor` は見つかったアイテムが期待されたものであるかどうかを判定"
#~ "し、\n"
#~ "   期待されたものでない場合はデシリアライズに失敗したことを示すエラーを発"
#~ "生させます。"

#~ msgid ""
#~ "1. Visit a map (_Serde_'s equvialent to `HashMap` or JSON's dictionary).\n"
#~ "1. Visit a string key called \"name\".\n"
#~ "1. Visit a string value, which will go into the `name` field.\n"
#~ "1. Visit a string key called \"customer_id\".\n"
#~ "1. Visit a string value, which will go into the `customer_id` field.\n"
#~ "1. Visit the end of the map."
#~ msgstr ""
#~ "1. map（ _Serde_ の `HashMap` や JSON のディクショナリに相当するもの）を訪"
#~ "問します。\n"
#~ "1. \"name\" という文字列キーを訪問します。\n"
#~ "1. `name` フィールドに入る文字列の値を訪問します。\n"
#~ "1. \"customer_id\" という文字列キーを訪問します。\n"
#~ "1. `customer_id` フィールドに入る文字列の値を訪問します。\n"
#~ "1. map の終端を訪問します。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "use serde::Deserialize;\n"
#~ "\n"
#~ "#[derive(Deserialize)]\n"
#~ "struct IdRecord {\n"
#~ "    name: String,\n"
#~ "    customer_id: String,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "use serde::Deserialize;\n"
#~ "\n"
#~ "#[derive(Deserialize)]\n"
#~ "struct IdRecord {\n"
#~ "    name: String,\n"
#~ "    customer_id: String,\n"
#~ "}\n"
#~ "```"

#~ msgid "It is defined this way:"
#~ msgstr "それはこのように定義されています："

#~ msgid ""
#~ "```rust,ignore\n"
#~ "pub trait Deserialize<'de>: Sized {\n"
#~ "    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
#~ "    where\n"
#~ "        D: Deserializer<'de>;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "pub trait Deserialize<'de>: Sized {\n"
#~ "    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
#~ "    where\n"
#~ "        D: Deserializer<'de>;\n"
#~ "}\n"
#~ "```"

#~ msgid "To wrap up, this is the power of _Serde_:"
#~ msgstr "最後に、これが _Serde_ の力です："

#~ msgid ""
#~ "1. The structure being parsed is represented by an `impl` block for "
#~ "`Deserialize`\n"
#~ "1. The input data format (e.g. JSON) is represented by a `Deserializer` "
#~ "called\n"
#~ "   by `Deserialize`\n"
#~ "1. The `Deserializer` acts like a prism which \"refracts\" lens-like "
#~ "`Visitor`\n"
#~ "   calls which actually build the data value"
#~ msgstr ""
#~ "1. パースされる構造体は `Deserialize` 用の `impl` ブロックで表現されま"
#~ "す。\n"
#~ "1. 入力データのフォーマット (例えば JSON) は、`Deserialize` によって呼び出"
#~ "される `Deserializer` によって表現されます。\n"
#~ "1. `Deserializer` は prism のように動作します。これは lens ライクな "
#~ "`Visitor` 呼び出しを \"屈折\" させます。これが実際にデータ値を構築します。"

#~ msgid ""
#~ "To emphasize, the only reason this model works on any format and any type "
#~ "is\n"
#~ "because the `Deserializer` trait's output type **is specified by the\n"
#~ "implementor of `Visitor` it is passed**, rather than being tied to one "
#~ "specific\n"
#~ "type.\n"
#~ "This was not true in the account example earlier."
#~ msgstr ""
#~ "強調しておきますが、このモデルがどのようなフォーマットでもどのような型でも"
#~ "動作する唯一の理由は、\n"
#~ "`Deserializer` トレイトのアウトプット型が、\n"
#~ "ある特定の型に縛れれるのではなく、\n"
#~ " **渡される `Visitor` の実装によって特定される** からです。\n"
#~ "これは前述の口座の例では当てはまりませんでした。"

#~ msgid ""
#~ "- [lens-rs crate](https://crates.io/crates/lens-rs) for a pre-built "
#~ "lenses\n"
#~ "  implementation, with a cleaner interface than these examples\n"
#~ "- [serde](https://serde.rs) itself, which makes these concepts intuitive "
#~ "for\n"
#~ "  end users (i.e. defining the structs) without needing to undestand the\n"
#~ "  details\n"
#~ "- [luminance](https://github.com/phaazon/luminance-rs) is a crate for "
#~ "drawing\n"
#~ "  computer graphics that uses lens API design, including proceducal "
#~ "macros to\n"
#~ "  create full prisms for buffers of different pixel types that remain "
#~ "generic\n"
#~ "- [An Article about Lenses in Scala](https://web.archive.org/"
#~ "web/20221128185849/https://medium.com/zyseme-technology/functional-"
#~ "references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
#~ "  that is very readable even without Scala expertise.\n"
#~ "- [Paper: Profunctor Optics: Modular Data\n"
#~ "  Accessors](https://web.archive.org/web/20220701102832/https://arxiv.org/"
#~ "ftp/arxiv/papers/1703/1703.10857.pdf)"
#~ msgstr ""
#~ "- [lens-rs クレート](https://crates.io/crates/lens-rs)は、これらの例よりも"
#~ "すっきりとしたインターフェイスを持つ、プレビルドなlensの実装です。\n"
#~ "- [serde](https://serde.rs)、これらのコンセプトをエンドユーザが、詳細を知"
#~ "ることなく、直感的に理解可能にします(構造体の定義など)。\n"
#~ "- [luminance](https://github.com/phaazon/luminance-rs)は、レンズAPIの設計"
#~ "を使用した、コンピュータグラフィックスを描画するためのクレートです。手続き"
#~ "型マクロを持ちます。マクロは、汎用的なまま、異なるピクセルタイプのバッファ"
#~ "に対して、完全なprismを作成します。\n"
#~ "- [Scala における lens についての記事](https://web.archive.org/"
#~ "web/20221128185849/https://medium.com/zyseme-technology/functional-"
#~ "references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
#~ "  はScalaの専門知識がなくても非常に読みやすいものです。\n"
#~ "- [論文： Profunctor Optics: Modular Data\n"
#~ "  Accessors](https://web.archive.org/web/20220701102832/https://arxiv.org/"
#~ "ftp/arxiv/papers/1703/1703.10857.pdf)"

#~ msgid ""
#~ "- [Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) "
#~ "by\n"
#~ "  Nicholas Cameron at the PDRust (2016)\n"
#~ "- [Writing Idiomatic Libraries in Rust](https://www.youtube.com/watch?"
#~ "v=0zOg8_B71gE)\n"
#~ "  by Pascal Hertleif at RustFest (2017)\n"
#~ "- [Rust Programming Techniques](https://www.youtube.com/watch?"
#~ "v=vqavdUGKeb4) by\n"
#~ "  Nicholas Cameron at LinuxConfAu (2018)"
#~ msgstr ""
#~ "- [Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) "
#~ "by\n"
#~ "  Nicholas Cameron at the PDRust (2016)\n"
#~ "- [Writing Idiomatic Libraries in Rust](https://www.youtube.com/watch?"
#~ "v=0zOg8_B71gE)\n"
#~ "  by Pascal Hertleif at RustFest (2017)\n"
#~ "- [Rust Programming Techniques](https://www.youtube.com/watch?"
#~ "v=vqavdUGKeb4) by\n"
#~ "  Nicholas Cameron at LinuxConfAu (2018)"

#~ msgid "# Design principles"
#~ msgstr "# 設計原則"

#~ msgid ""
#~ "- [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/"
#~ "Single-responsibility_principle):\n"
#~ "  A class should only have a single responsibility, that is, only changes "
#~ "to\n"
#~ "  one part of the software's specification should be able to affect the\n"
#~ "  specification of the class.\n"
#~ "- [Open/Closed Principle (OCP)](https://en.wikipedia.org/wiki/"
#~ "Open%E2%80%93closed_principle):\n"
#~ "  \"Software entities ... should be open for extension, but closed for\n"
#~ "  modification.\"\n"
#~ "- [Liskov Substitution Principle (LSP)](https://en.wikipedia.org/wiki/"
#~ "Liskov_substitution_principle):\n"
#~ "  \"Objects in a program should be replaceable with instances of their "
#~ "subtypes\n"
#~ "  without altering the correctness of that program.\"\n"
#~ "- [Interface Segregation Principle (ISP)](https://en.wikipedia.org/wiki/"
#~ "Interface_segregation_principle):\n"
#~ "  \"Many client-specific interfaces are better than one general-purpose\n"
#~ "  interface.\"\n"
#~ "- [Dependency Inversion Principle (DIP)](https://en.wikipedia.org/wiki/"
#~ "Dependency_inversion_principle):\n"
#~ "  One should \"depend upon abstractions, [not] concretions.\""
#~ msgstr ""
#~ "- [単一責任の原則(SRP)](https://en.wikipedia.org/wiki/Single-"
#~ "responsibility_principle)：\n"
#~ "  クラスは単一の責任だけを持つべきです。\n"
#~ "  すなわち、ソフトウェアの仕様の一部分の変更のみが、クラスの仕様に影響を与"
#~ "えることができるべきです。\n"
#~ "- [開放/閉鎖原則(OCP)](https://en.wikipedia.org/wiki/"
#~ "Open%E2%80%93closed_principle)：\n"
#~ "  \"Software entities ... should be open for extension, but closed for\n"
#~ "  modification.(ソフトウェアエンティティは ... 拡張に対して開放され、変更"
#~ "に対して閉鎖されているべきです)\"\n"
#~ "- [リスコフの置換原則(LSP)](https://en.wikipedia.org/wiki/"
#~ "Liskov_substitution_principle)：\n"
#~ "  \"Objects in a program should be replaceable with instances of their "
#~ "subtypes\n"
#~ "  without altering the correctness of that program.(プログラム中のオブジェ"
#~ "クトは、プログラムを修正することなく、\n"
#~ "  そのサブタイプのインスタンスと置き換え可能であるべきです。\"\n"
#~ "- [インタフェース分離の原則(ISP)](https://en.wikipedia.org/wiki/"
#~ "Interface_segregation_principle)：\n"
#~ "  \"Many client-specific interfaces are better than one general-purpose\n"
#~ "  interface.(多くのクライアント固有のインタフェースは、1つの汎用インタ"
#~ "フェースよりも優れている)\"\n"
#~ "- [依存関係逆転の原則(DIP)](https://en.wikipedia.org/wiki/"
#~ "Dependency_inversion_principle)：\n"
#~ "  \"depend upon abstractions, [not] concretions.(抽象的なものに依存すべき"
#~ "であり、具体的なものに依存すべきではない)\"。"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "// Some type, not necessarily in the same module or even crate.\n"
#~ "struct Foo {\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // These functions are not present on Bar.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// The newtype.\n"
#~ "pub struct Bar(Foo);\n"
#~ "\n"
#~ "impl Bar {\n"
#~ "    // Constructor.\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> Self {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...);\n"
#~ "\n"
#~ "    // Foo and Bar are type incompatible, the following do not type "
#~ "check.\n"
#~ "    // let f: Foo = b;\n"
#~ "    // let b: Bar = Foo { ... };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト,無視\n"
#~ "// 同じモジュールやクレート内にあるとは限りません。\n"
#~ "struct Foo {.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // これらの関数はBarにはありません。\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// ニュータイプ。\n"
#~ "pub struct Bar(Foo)；\n"
#~ "\n"
#~ "impl Bar { // コンストラクタ。\n"
#~ "    // コンストラクタ。\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> 自己 {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...)；\n"
#~ "\n"
#~ "    // Foo と Bar は型互換性がありません。\n"
#~ "    // let f: Foo = b；\n"
#~ "    // let b: Bar = Foo { ...};\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "# Compose structs together for better borrowing"
#~ msgstr "# 構造体をまとめると借りやすくなります"

#, fuzzy
#~ msgid "TODO - this is not a very snappy name"
#~ msgstr "TODO - この名前はあまりスマートではありません。"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "struct A {\n"
#~ "    f1: u32,\n"
#~ "    f2: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    // The later usage of x causes a to be borrowed for the rest of the "
#~ "function.\n"
#~ "    let x = foo(a);\n"
#~ "    // Borrow checker error:\n"
#~ "    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more "
#~ "than once\n"
#~ "                       //          at a time\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "錆\n"
#~ "構造体 A {\n"
#~ "    f1: u32、\n"
#~ "    f2: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }.\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { // 後で x を使用すると、以下のようになります。\n"
#~ "    // xの後の使用により、aは関数の残りの部分で借用されます。\n"
#~ "    let x = foo(a)；\n"
#~ "    // 借用チェッカーのエラー：\n"
#~ "    // let y = bar(a); // ~ ERROR: `*a` を mutable として複数回借りること"
#~ "はできません。\n"
#~ "                       // 一度に\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "// A is now composed of two structs - B and C.\n"
#~ "struct A {\n"
#~ "    b: B,\n"
#~ "    c: C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32,\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "// These functions take a B or C, rather than A.\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    let x = foo(&mut a.b);\n"
#~ "    // Now it's OK!\n"
#~ "    let y = bar(&mut a.c);\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "// AはBとCの2つの構造体で構成されます。\n"
#~ "struct A {\n"
#~ "    b: B、\n"
#~ "    c:C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32、\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "// これらの関数は、AではなくBまたはCを取ります。\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }.\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { { fn x = foo(&mut B) -> u32\n"
#~ "    let x = foo(&mut a.b)；\n"
#~ "    // これでOK！\n"
#~ "    let y = bar(&mut a.c)；\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "TODO Why and where you should use the pattern"
#~ msgstr "TODO パターンを使うべき理由と場所"

#, fuzzy
#~ msgid "Often produces a better design."
#~ msgstr "多くの場合、より良いデザインが生まれます。"

#, fuzzy
#~ msgid "Leads to more verbose code."
#~ msgstr "より冗長なコードになります。"
