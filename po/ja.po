msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-07-17 12:38+0900\n"
"Last-Translator: ashiojin@gmail.com\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "はじめに"

#: src/SUMMARY.md:4
msgid "Translations"
msgstr "翻訳"

#: src/SUMMARY.md:5
msgid "Idioms"
msgstr "イディオム"

#: src/SUMMARY.md:6
msgid "Use borrowed types for arguments"
msgstr "引数には借用型（borrowed types）を使用する"

#: src/SUMMARY.md:7
msgid "Concatenating Strings with format!"
msgstr "format!による文字列の連結"

#: src/SUMMARY.md:8
msgid "Constructor"
msgstr "コンストラクタ"

#: src/SUMMARY.md:9
msgid "The Default Trait"
msgstr "Default トレイト"

#: src/SUMMARY.md:10
msgid "Collections Are Smart Pointers"
msgstr "スマートポインタとしてのコレクション"

#: src/SUMMARY.md:11
msgid "Finalisation in Destructors"
msgstr "デストラクタでのファイナライズ"

#: src/SUMMARY.md:12
msgid "mem::{take(_), replace(_)}"
msgstr "mem::{take(_), replace(_)}"

#: src/SUMMARY.md:13
msgid "On-Stack Dynamic Dispatch"
msgstr "オンスタックの動的ディスパッチ"

#: src/SUMMARY.md:14 src/SUMMARY.md:40
msgid "Foreign function interface (FFI)"
msgstr "Foreign function interface (FFI)"

#: src/SUMMARY.md:15
#, fuzzy
msgid "Idiomatic Errors"
msgstr "慣用句の誤り"

#: src/SUMMARY.md:16
#, fuzzy
msgid "Accepting Strings"
msgstr "弦楽器の受け入れ"

#: src/SUMMARY.md:17
#, fuzzy
msgid "Passing Strings"
msgstr "文字列の受け渡し"

#: src/SUMMARY.md:18
#, fuzzy
msgid "Iterating over an Option"
msgstr "オプションの反復処理"

#: src/SUMMARY.md:19
#, fuzzy
msgid "Pass Variables to Closure"
msgstr "変数をクロージャに渡す"

#: src/SUMMARY.md:20
#, fuzzy
msgid "Privacy For Extensibility"
msgstr "拡張性のためのプライバシー"

#: src/SUMMARY.md:21
#, fuzzy
msgid "Easy doc initialization"
msgstr "簡単なドキュメントの初期化"

#: src/SUMMARY.md:22
#, fuzzy
msgid "Temporary mutability"
msgstr "一時的な変更可能性"

#: src/SUMMARY.md:23
#, fuzzy
msgid "Return consumed arg on error"
msgstr "エラー時に消費された引数を返す"

#: src/SUMMARY.md:25
#, fuzzy
msgid "Design Patterns"
msgstr "デザインパターン"

#: src/SUMMARY.md:26
#, fuzzy
msgid "Behavioural"
msgstr "Behavioural"

#: src/SUMMARY.md:27
msgid "Command"
msgstr "コマンド"

#: src/SUMMARY.md:28
#, fuzzy
msgid "Interpreter"
msgstr "Interpreter"

#: src/SUMMARY.md:29
#, fuzzy
msgid "Newtype"
msgstr "ニュータイプ"

#: src/SUMMARY.md:30
#, fuzzy
msgid "RAII Guards"
msgstr "RAIIガード"

#: src/SUMMARY.md:31
#, fuzzy
msgid "Strategy"
msgstr "Strategy"

#: src/SUMMARY.md:32
#, fuzzy
msgid "Visitor"
msgstr "Visitor"

#: src/SUMMARY.md:33
#, fuzzy
msgid "Creational"
msgstr "Creational"

#: src/SUMMARY.md:34
#, fuzzy
msgid "Builder"
msgstr "Builder"

#: src/SUMMARY.md:35
#, fuzzy
msgid "Fold"
msgstr "Fold"

#: src/SUMMARY.md:36
#, fuzzy
msgid "Structural"
msgstr "構造的"

#: src/SUMMARY.md:37
#, fuzzy
msgid "Compose Structs"
msgstr "構造体の構成"

#: src/SUMMARY.md:38
#, fuzzy
msgid "Prefer Small Crates"
msgstr "小型クレートを好む"

#: src/SUMMARY.md:39
#, fuzzy
msgid "Contain unsafety in small modules"
msgstr "小さなモジュールに安全性を確保"

#: src/SUMMARY.md:41
#, fuzzy
msgid "Object-Based APIs"
msgstr "オブジェクトベースのAPI"

#: src/SUMMARY.md:42
#, fuzzy
msgid "Type Consolidation into Wrappers"
msgstr "ラッパーへのタイプ統合"

#: src/SUMMARY.md:44
#, fuzzy
msgid "Anti-patterns"
msgstr "アンチパターン"

#: src/SUMMARY.md:45
#, fuzzy
msgid "Clone to satisfy the borrow checker"
msgstr "借り手チェッカーを満足させるクローン"

#: src/SUMMARY.md:46
#, fuzzy
msgid "#[deny(warnings)]"
msgstr "#[deny(warnings)]"

#: src/SUMMARY.md:47
#, fuzzy
msgid "Deref Polymorphism"
msgstr "デレフ・ポリモーフィズム"

#: src/SUMMARY.md:49
#, fuzzy
msgid "Functional Programming"
msgstr "関数型プログラミング"

#: src/SUMMARY.md:50
#, fuzzy
msgid "Programming paradigms"
msgstr "プログラミング・パラダイム"

#: src/SUMMARY.md:51
#, fuzzy
msgid "Generics as Type Classes"
msgstr "型クラスとしてのジェネリック"

#: src/SUMMARY.md:52
#, fuzzy
msgid "Lenses and Prisms"
msgstr "レンズとプリズム"

#: src/SUMMARY.md:54
msgid "Additional Resources"
msgstr "追加リソース"

#: src/SUMMARY.md:55
#, fuzzy
msgid "Design principles"
msgstr "設計原則"

#: src/intro.md:1
msgid "# Introduction"
msgstr "# はじめに"

#: src/intro.md:3
msgid "## Participation"
msgstr "## 参加"

#: src/intro.md:5
msgid ""
"If you are interested in contributing to this book, check out the\n"
"[contribution guidelines](https://github.com/rust-unofficial/patterns/blob/"
"master/CONTRIBUTING.md)."
msgstr ""
"本書への寄稿にご興味のある方は、[contribution guidelines](https://github.com/"
"rust-unofficial/patterns/blob/master/CONTRIBUTING.md)をご覧ください。"

#: src/intro.md:8
msgid "## Design patterns"
msgstr "## デザインパターン"

#: src/intro.md:10
msgid ""
"In software development, we often come across problems that share\n"
"similarities regardless of the environment they appear in. Although the\n"
"implementation details are crucial to solve the task at hand, we may\n"
"abstract from these particularities to find the common practices that\n"
"are generically applicable."
msgstr ""
"ソフトウェア開発では、それがどのような環境で発生したかに関係なく、共通点を持"
"つ問題に出くわすことがよくあります。目の前の課題を解決するためにはその実装上"
"の詳細が非常に重要ですが、私たちはこのような特殊性を抽象化して、一般的に適用"
"可能な共通プラクティスを見出すことが可能です。"

#: src/intro.md:16
msgid ""
"Design patterns are a collection of reusable and tested solutions to\n"
"recurring problems in engineering. They make our software more modular,\n"
"maintainable, and extensible. Moreover, these patterns provide a common\n"
"language for developers, making them an excellent tool for effective\n"
"communication when problem-solving in teams."
msgstr ""
"デザインパターンとは、エンジニアリングで繰り返し発生する問題に対する、再利用"
"可能でテスト済みの解決策を集めたものです。\n"
"デザインパターンは、ソフトウェアをよりモジュール化し保守性と拡張性を高めま"
"す。さらに、これらのパターンは開発者に共通言語を提供するため、チームが問題解"
"決する際の効果的なコミュニケーションツールとなります。"

#: src/intro.md:22 src/patterns/index.md:14
msgid "## Design patterns in Rust"
msgstr "## Rustのデザインパターン"

#: src/intro.md:24
msgid ""
"Rust is not object-oriented, and the combination of all its "
"characteristics,\n"
"such as functional elements, a strong type system, and the borrow checker,\n"
"makes it unique.\n"
"Because of this, Rust design patterns vary with respect to other\n"
"traditional object-oriented programming languages.\n"
"That's why we decided to write this book. We hope you enjoy reading it!\n"
"The book is divided in three main chapters:"
msgstr ""
"Rustはオブジェクト指向ではありません。また、関数型プログラミングの要素、強力"
"な型システム、借用チェッカーなど、Rustのすべての特徴の組み合わせがRustをユ"
"ニークなものにしています。このため、Rust のデザインパターンは他の伝統的なオブ"
"ジェクト指向プログラミング言語とは異なります。これが私たちがこの本を書くこと"
"にした理由です。ご愛読いただければ幸いです！\n"
"本書は大きく3つの章に分かれています："

#: src/intro.md:32
msgid ""
"- [Idioms](./idioms/index.md): guidelines to follow when coding.\n"
"  They are the social norms of the community.\n"
"  You should break them only if you have a good reason for it.\n"
"- [Design patterns](./patterns/index.md): methods to solve common problems\n"
"  when coding.\n"
"- [Anti-patterns](./anti_patterns/index.md): methods to solve common "
"problems\n"
"  when coding.\n"
"  However, while design patterns give us benefits,\n"
"  anti-patterns create more problems."
msgstr ""
"- [イディオム](./idioms/index.md)：コーディングの際に従うべきガイドライン。\n"
"  コミュニティの社会的規範です。正当な理由がある場合のみ、破るべきです。\n"
"- [デザインパターン](./patterns/index.md): コーディングの際によくある問題を解"
"決するための方法です。\n"
"- [アンチパターン](./anti_patterns/index.md): コーディング時によくある問題を"
"解決するための方法です。\n"
"  ただし、デザインパターンが私たちに利益を与えてくれるのに対し、アンチパター"
"ンはより多くの問題を引き起こします。"

#: src/translations.md:1
msgid "# Translations"
msgstr "# 翻訳"

#: src/translations.md:3
msgid ""
"We are utilizing [mdbook-i18n-helper](https://github.com/google/mdbook-i18n-"
"helpers).\n"
"Please read up on how to _add_ and _update_ translations in [their "
"repository](https://github.com/google/mdbook-i18n-helpers#creating-and-"
"updating-translations)"
msgstr ""
"私たちは[mdbook-i18n-helper](https://github.com/google/mdbook-i18n-helpers)を"
"利用しています。翻訳の追加と更新の方法は[そのリポジトリ](https://github.com/"
"google/mdbook-i18n-helpers#creating-and-updating-translations)を参照してくだ"
"さい。"

#: src/translations.md:6
msgid "## External translations"
msgstr "## 外部の翻訳"

#: src/translations.md:8
msgid "- [简体中文](https://fomalhauthmj.github.io/patterns/)"
msgstr "- [简体中文](https://fomalhauthmj.github.io/patterns/)"

#: src/translations.md:10
msgid ""
"If you want to add a translation, please open an issue in the\n"
"[main repository](https://github.com/rust-unofficial/patterns)."
msgstr ""
"翻訳を追加したい場合は、[メインリポジトリ](https://github.com/rust-"
"unofficial/patterns) にissueを開いてください。"

#: src/idioms/index.md:1
msgid "# Idioms"
msgstr "# イディオム"

#: src/idioms/index.md:3
msgid ""
"[Idioms](https://en.wikipedia.org/wiki/Programming_idiom) are commonly used\n"
"styles, guidelines and patterns largely agreed upon by a community.\n"
"Writing idiomatic code allows other developers to understand better what is\n"
"happening."
msgstr ""
"[イディオム](https://en.wikipedia.org/wiki/Programming_idiom)は、一般的に使わ"
"れているスタイル、ガイドライン、パターンです。\n"
"慣用的なコードを書くことで、他の開発者は何が起こっているのかをよりよく理解す"
"ることができます。"

#: src/idioms/index.md:8
msgid ""
"After all, the computer only cares about the machine code that is generated\n"
"by the compiler.\n"
"Instead, the source code is mainly beneficial to the developer.\n"
"So, since we have this abstraction layer, why not make it more readable?"
msgstr ""
"結局のところ、コンピュータにとって重要なものは、コンパイラが生成したマシン"
"コードのみです。\n"
"むしろ、ソースコードは主に開発者にとって有益なものです。\n"
"せっかく、私たちには抽象化レイヤーがあるのですから、もっと読みやすくしたらど"
"うでしょう？"

#: src/idioms/index.md:13
msgid ""
"Remember the [KISS principle](https://en.wikipedia.org/wiki/"
"KISS_principle):\n"
"\"Keep It Simple, Stupid\". It claims that \"most systems work best if they "
"are\n"
"kept simple rather than made complicated; therefore, simplicity should be a "
"key\n"
"goal in design, and unnecessary complexity should be avoided\"."
msgstr ""
"[KISSの原則](https://en.wikipedia.org/wiki/KISS_principle) ：「シンプルにして"
"おけ！この間抜け」を思い出してください。この原則は、「ほとんどのシステムは、"
"複雑にするよりもシンプルにしたほうが最もうまく機能する。したがって、シンプル"
"であることが設計における重要な目標であるべきであり、不必要な複雑さは避けるべ"
"きである」と主張しています。"

#: src/idioms/index.md:18
msgid "> Code is there for humans, not computers, to understand."
msgstr ""
"> コードは人間が理解するものであって、コンピューターが理解するものではありま"
"せん。"

#: src/idioms/coercion-arguments.md:1
msgid "# Use borrowed types for arguments"
msgstr "# 引数には借用型（borrowed types）を使用する"

#: src/idioms/coercion-arguments.md:3 src/idioms/concat-format.md:3
#: src/idioms/ctor.md:3 src/idioms/default.md:3 src/idioms/deref.md:3
#: src/idioms/dtor-finally.md:3 src/idioms/mem-replace.md:3
#: src/idioms/on-stack-dyn-dispatch.md:3 src/idioms/ffi/errors.md:3
#: src/idioms/ffi/accepting-strings.md:3 src/idioms/ffi/passing-strings.md:3
#: src/idioms/option-iter.md:3 src/idioms/pass-var-to-closure.md:3
#: src/idioms/priv-extend.md:3 src/idioms/rustdoc-init.md:3
#: src/idioms/temporary-mutability.md:3
#: src/idioms/return-consumed-arg-on-error.md:3
#: src/patterns/behavioural/command.md:3
#: src/patterns/behavioural/interpreter.md:3
#: src/patterns/behavioural/newtype.md:13 src/patterns/behavioural/RAII.md:3
#: src/patterns/behavioural/strategy.md:3 src/patterns/behavioural/visitor.md:3
#: src/patterns/creational/builder.md:3 src/patterns/creational/fold.md:3
#: src/patterns/structural/compose-structs.md:3
#: src/patterns/structural/small-crates.md:3
#: src/patterns/structural/unsafe-mods.md:3 src/patterns/ffi/export.md:3
#: src/patterns/ffi/wrappers.md:3 src/anti_patterns/borrow_clone.md:3
#: src/anti_patterns/deny-warnings.md:3 src/anti_patterns/deref.md:3
#: src/functional/generics-type-classes.md:3
msgid "## Description"
msgstr "## 説明"

#: src/idioms/coercion-arguments.md:5
msgid ""
"Using a target of a deref coercion can increase the flexibility of your "
"code\n"
"when you are deciding which argument type to use for a function argument.\n"
"In this way, the function will accept more input types."
msgstr ""
"関数の引数にどの型を使うかを決めるときに、参照外し型強制(deref coercion)の対"
"象を使うことで、コードの柔軟性を高めることができます。この方法により、関数は"
"より多くの型を入力として受け入れられるようになります。"

#: src/idioms/coercion-arguments.md:9
msgid ""
"This is not limited to slice-able or fat pointer types.\n"
"In fact, you should always prefer using the **borrowed type** over\n"
"**borrowing the owned type**.\n"
"Such as `&str` over `&String`, `&[T]` over `&Vec<T>`, or `&T` over `&Box<T>`."
msgstr ""
"これはスライス可能な型やファットポインタ型に限ったことではありません。\n"
"実際、**所有型の借用**よりも **借用型** を常に使用することをお勧めします。\n"
"例えば、 `&String` よりも `&str` の方が、 `&Vec<T>` よりも `&[T]` の方が、 "
"`&Box<T>` よりも `&T` の方が優れています。"

#: src/idioms/coercion-arguments.md:14
msgid ""
"Using borrowed types you can avoid layers of indirection for those "
"instances\n"
"where the owned type already provides a layer of indirection. For instance, "
"a\n"
"`String` has a layer of indirection, so a `&String` will have two layers of\n"
"indirection. We can avoid this by using `&str` instead, and letting "
"`&String`\n"
"coerce to a `&str` whenever the function is invoked."
msgstr ""
"借用型を使えば、所有型がすでに間接的なレイヤーを提供しているような場合に、そ"
"のインスタンスに対する多重の間接的なレイヤーを避けることができます。例えば "
"`String` には間接的なレイヤーがあるので、 `&String` は2つの間接的なレイヤーを"
"持つことになってしまいます。\n"
"代わりに `&str` を使用し、関数呼び出し毎に `&String` を `&str` に型強制するこ"
"とでこれを避けることができます。"

#: src/idioms/coercion-arguments.md:20 src/idioms/concat-format.md:10
#: src/idioms/default.md:20 src/idioms/deref.md:9 src/idioms/dtor-finally.md:9
#: src/idioms/mem-replace.md:11 src/idioms/on-stack-dyn-dispatch.md:10
#: src/idioms/pass-var-to-closure.md:12 src/idioms/priv-extend.md:18
#: src/idioms/rustdoc-init.md:45 src/idioms/temporary-mutability.md:12
#: src/idioms/return-consumed-arg-on-error.md:8
#: src/patterns/behavioural/command.md:18
#: src/patterns/behavioural/newtype.md:18 src/patterns/behavioural/RAII.md:11
#: src/patterns/behavioural/strategy.md:28
#: src/patterns/behavioural/visitor.md:13 src/patterns/creational/builder.md:7
#: src/patterns/creational/fold.md:12
#: src/patterns/structural/compose-structs.md:15
#: src/anti_patterns/borrow_clone.md:11 src/anti_patterns/deny-warnings.md:8
#: src/anti_patterns/deref.md:8 src/functional/generics-type-classes.md:38
msgid "## Example"
msgstr "## 例"

#: src/idioms/coercion-arguments.md:22
msgid ""
"For this example, we will illustrate some differences for using `&String` as "
"a\n"
"function argument versus using a `&str`, but the ideas apply as well to "
"using\n"
"`&Vec<T>` versus using a `&[T]` or using a `&Box<T>` versus a `&T`."
msgstr ""
"この例では、関数の引数として `&String` を使用する場合と `&str` を使用する場合"
"の違いを説明します。例で示すものは型の組み合わせが `Vec<T>` に対して "
"`&[T]` 、 `&Box<T>` に対して `&T` 、などあっても同様です。"

#: src/idioms/coercion-arguments.md:26
msgid ""
"Consider an example where we wish to determine if a word contains three\n"
"consecutive vowels. We don't need to own the string to determine this, so "
"we\n"
"will take a reference."
msgstr ""
"例として、ある単語が3つの連続した母音を含むかどうかを調べたい場合を考えてみま"
"しょう。調べるにあたって、対象の文字列を所有する必要はありません。私たちは参"
"照を使うでしょう。"

#: src/idioms/coercion-arguments.md:30
msgid "The code might look something like this:"
msgstr "コードは次のようになります："

#: src/idioms/coercion-arguments.md:32
msgid ""
"```rust\n"
"fn three_vowels(word: &String) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let ferris = \"Ferris\".to_string();\n"
"    let curious = \"Curious\".to_string();\n"
"    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
"    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
"\n"
"    // This works fine, but the following two lines would fail:\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn three_vowels(word: &String) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let ferris = \"Ferris\".to_string();\n"
"    let curious = \"Curious\".to_string();\n"
"    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
"    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
"\n"
"    // 以上はうまく動作する。しかし以下の2行は失敗する：\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
"\n"
"}\n"
"```"

#: src/idioms/coercion-arguments.md:62
msgid ""
"This works fine because we are passing a `&String` type as a parameter.\n"
"If we remove the comments on the last two lines, the example will fail. "
"This\n"
"is because a `&str` type will not coerce to a `&String` type. We can fix "
"this\n"
"by simply modifying the type for our argument."
msgstr ""
"これは `&String` 型をパラメータとして渡しているため、問題なく動作します。最後"
"の2行のコメントを削除すると、この例は失敗します。これは `&str` 型が "
"`&String` 型に型強制されないからです。この問題を、単に引数の型を変更すること"
"で修正できます。"

#: src/idioms/coercion-arguments.md:67
msgid "For instance, if we change our function declaration to:"
msgstr "例えば、関数宣言を次のように変更します："

#: src/idioms/coercion-arguments.md:69
msgid ""
"```rust, ignore\n"
"fn three_vowels(word: &str) -> bool {\n"
"```"
msgstr ""
"```rust, ignore\n"
"fn three_vowels(word: &str) -> bool {\n"
"```"

#: src/idioms/coercion-arguments.md:73
msgid "then both versions will compile and print the same output."
msgstr ""
"すると、上述の例のどちらのバージョンもコンパイルされ、同じ出力が表示されま"
"す。"

#: src/idioms/coercion-arguments.md:75
msgid ""
"```bash\n"
"Ferris: false\n"
"Curious: true\n"
"```"
msgstr ""
"```bash\n"
"Ferris: false\n"
"Curious: true\n"
"```"

#: src/idioms/coercion-arguments.md:80
msgid ""
"But wait, that's not all! There is more to this story.\n"
"It's likely that you may say to yourself: that doesn't matter, I will never "
"be\n"
"using a `&'static str` as an input anyways (as we did when we used "
"`\"Ferris\"`).\n"
"Even ignoring this special example, you may still find that using `&str` "
"will\n"
"give you more flexibility than using a `&String`."
msgstr ""
"でも待ってください！この話にはまだ続きがあります。もしかしたら、あなたは"
"「 `&'static str` （上述の例では `\"Ferris\"` ）を入力に使うことは絶対ない"
"し・・・」と考え、こんなことどうでもいいと感じるかもしれません。\n"
"または、この特別な例を無視しても、`&str`を使用する方が`&'static str`を使用す"
"るよりも柔軟性があることに気づくかもしれません。"

#: src/idioms/coercion-arguments.md:86
msgid ""
"Let's now take an example where someone gives us a sentence, and we want to\n"
"determine if any of the words in the sentence contain three consecutive "
"vowels.\n"
"We probably should make use of the function we have already defined and "
"simply\n"
"feed in each word from the sentence."
msgstr ""
"では、誰かが私たちに文章を与えたとして、その中に3つの母音が連続する単語がある"
"かどうかを調べる例を考えてみましょう。\n"
"この場合、すでに定義した関数を利用すべきでしょう。単純に、文中の単語を関数に"
"与えるべきです。"

#: src/idioms/coercion-arguments.md:91
msgid "An example of this could look like this:"
msgstr "その例は次のようなものです："

#: src/idioms/coercion-arguments.md:93
msgid ""
"```rust\n"
"fn three_vowels(word: &str) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let sentence_string =\n"
"        \"Once upon a time, there was a friendly curious crab named Ferris\"."
"to_string();\n"
"    for word in sentence_string.split(' ') {\n"
"        if three_vowels(word) {\n"
"            println!(\"{} has three consecutive vowels!\", word);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn three_vowels(word: &str) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let sentence_string =\n"
"        \"Once upon a time, there was a friendly curious crab named Ferris\"."
"to_string();\n"
"    for word in sentence_string.split(' ') {\n"
"        if three_vowels(word) {\n"
"            println!(\"{} has three consecutive vowels!\", word);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/coercion-arguments.md:121
msgid ""
"Running this example using our function declared with an argument type "
"`&str`\n"
"will yield"
msgstr ""
"引数を `&str` として宣言した関数を使用してこの例を実行すると、次のようになる"
"でしょう"

#: src/idioms/coercion-arguments.md:124
msgid ""
"```bash\n"
"curious has three consecutive vowels!\n"
"```"
msgstr ""
"```bash\n"
"curious has three consecutive vowels!\n"
"```"

#: src/idioms/coercion-arguments.md:128
msgid ""
"However, this example will not run when our function is declared with an\n"
"argument type `&String`. This is because string slices are a `&str` and not "
"a\n"
"`&String` which would require an allocation to be converted to `&String` "
"which\n"
"is not implicit, whereas converting from `String` to `&str` is cheap and "
"implicit."
msgstr ""
"しかし私たちが関数の引数型を `&String` として宣言していた場合には、この例は実"
"行できません。これは、文字列スライスが `&str` であり、`&String` ではないため"
"です。 `&str` は `&String` に変換するためにはアロケーションを必要とし、暗黙期"
"には変換されません。対して `String` は `&str` に安価かつ暗黙的に変換されま"
"す。"

#: src/idioms/coercion-arguments.md:133 src/idioms/ctor.md:101
#: src/idioms/default.md:58 src/idioms/deref.md:76
#: src/idioms/dtor-finally.md:88 src/idioms/mem-replace.md:108
#: src/idioms/on-stack-dyn-dispatch.md:83 src/idioms/option-iter.md:46
#: src/idioms/priv-extend.md:120 src/patterns/behavioural/command.md:218
#: src/patterns/behavioural/interpreter.md:142
#: src/patterns/behavioural/newtype.md:93 src/patterns/behavioural/RAII.md:111
#: src/patterns/behavioural/strategy.md:174
#: src/patterns/behavioural/visitor.md:106
#: src/patterns/creational/builder.md:108 src/patterns/creational/fold.md:109
#: src/patterns/structural/small-crates.md:45
#: src/patterns/structural/unsafe-mods.md:32
#: src/anti_patterns/borrow_clone.md:68 src/anti_patterns/deny-warnings.md:96
#: src/anti_patterns/deref.md:123 src/functional/generics-type-classes.md:237
msgid "## See also"
msgstr "## See also"

#: src/idioms/coercion-arguments.md:135
msgid ""
"- [Rust Language Reference on Type Coercions](https://doc.rust-lang.org/"
"reference/type-coercions.html)\n"
"- For more discussion on how to handle `String` and `&str` see\n"
"  [this blog series (2015)](https://web.archive.org/web/20201112023149/"
"https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html)\n"
"  by Herman J. Radtke III"
msgstr ""
"- [型強制(Type coercions)に関するRust言語リファレンス](https://doc.rust-lang."
"org/reference/type-coercions.html)\n"
"- `String`と`&str`の扱い方に関する議論は、Herman J. Radtke III の\n"
"  [このブログのシリーズ(2015)](https://web.archive.org/web/20201112023149/"
"https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html) を"
"見てください"

#: src/idioms/concat-format.md:1
msgid "# Concatenating strings with `format!`"
msgstr "# `format! による文字列の連結"

#: src/idioms/concat-format.md:5
msgid ""
"It is possible to build up strings using the `push` and `push_str` methods "
"on a\n"
"mutable `String`, or using its `+` operator. However, it is often more\n"
"convenient to use `format!`, especially where there is a mix of literal and\n"
"non-literal strings."
msgstr ""
"`String` の `push` メソッドや `push_str` メソッドを使用したり、 `+` 演算子を"
"使用したりすることで、文字列を構築することは可能です。\n"
"しかし`format!` を使用した方がより便利なことがあります。特にリテラル文字列と"
"非リテラル文字列が混在している場合がそうです。"

#: src/idioms/concat-format.md:12
msgid ""
"```rust\n"
"fn say_hello(name: &str) -> String {\n"
"    // We could construct the result string manually.\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
"\n"
"    // But using format! is better.\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn say_hello(name: &str) -> String {\n"
"    // 以下のように result 文字列を構築することができます。\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
"\n"
"    // しかし format! を使うほうがよいでしょう。\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"```"

#: src/idioms/concat-format.md:25 src/idioms/deref.md:43
#: src/idioms/dtor-finally.md:42 src/idioms/mem-replace.md:83
#: src/idioms/on-stack-dyn-dispatch.md:48 src/idioms/ffi/errors.md:131
#: src/idioms/ffi/accepting-strings.md:68 src/idioms/ffi/passing-strings.md:68
#: src/idioms/pass-var-to-closure.md:48 src/idioms/rustdoc-init.md:77
#: src/idioms/temporary-mutability.md:38
#: src/idioms/return-consumed-arg-on-error.md:55
#: src/patterns/behavioural/newtype.md:55 src/patterns/behavioural/RAII.md:78
#: src/patterns/behavioural/strategy.md:95
#: src/patterns/creational/builder.md:68
#: src/patterns/structural/compose-structs.md:98
#: src/patterns/structural/small-crates.md:12
#: src/patterns/structural/unsafe-mods.md:11 src/patterns/ffi/export.md:111
#: src/patterns/ffi/wrappers.md:63 src/anti_patterns/deny-warnings.md:16
#: src/anti_patterns/deref.md:69 src/functional/generics-type-classes.md:210
msgid "## Advantages"
msgstr "## メリット"

#: src/idioms/concat-format.md:27
msgid ""
"Using `format!` is usually the most succinct and readable way to combine "
"strings."
msgstr ""
"`format!` を使う方法が、通常、文字列を組み合わせる最も簡潔で読みやすい方法で"
"す。"

#: src/idioms/concat-format.md:29 src/idioms/deref.md:50
#: src/idioms/dtor-finally.md:47 src/idioms/mem-replace.md:87
#: src/idioms/on-stack-dyn-dispatch.md:54 src/idioms/ffi/errors.md:136
#: src/idioms/ffi/accepting-strings.md:141
#: src/idioms/ffi/passing-strings.md:103 src/idioms/pass-var-to-closure.md:57
#: src/idioms/rustdoc-init.md:81 src/idioms/temporary-mutability.md:42
#: src/idioms/return-consumed-arg-on-error.md:59
#: src/patterns/behavioural/newtype.md:66
#: src/patterns/behavioural/strategy.md:104
#: src/patterns/creational/builder.md:76
#: src/patterns/structural/compose-structs.md:103
#: src/patterns/structural/small-crates.md:22
#: src/patterns/structural/unsafe-mods.md:17 src/patterns/ffi/export.md:234
#: src/patterns/ffi/wrappers.md:69 src/anti_patterns/deref.md:81
#: src/functional/generics-type-classes.md:221
msgid "## Disadvantages"
msgstr "## デメリット"

#: src/idioms/concat-format.md:31
msgid ""
"It is usually not the most efficient way to combine strings - a series of "
"`push`\n"
"operations on a mutable string is usually the most efficient (especially if "
"the\n"
"string has been pre-allocated to the expected size)."
msgstr ""
"通常、文字列を結合する最も効率的な方法とは言えません。通常、ミュータブルな文"
"字列への `push` の繰り返しが最も効率的です（特に、その文字列があらかじめ期待"
"されるサイズに割り当てられている場合）。"

#: src/idioms/ctor.md:1
msgid "# Constructors"
msgstr "# コンストラクタ"

#: src/idioms/ctor.md:5
msgid ""
"Rust does not have constructors as a language construct. Instead, the\n"
"convention is to use an [associated function][associated function] `new` to "
"create an object:"
msgstr ""
"Rustには、言語の構成要素としてコンストラクタというものを持っていません。\n"
"代わりに [関連関数][associated function] の `new` を使ってオブジェクトを生成"
"するのが一般的です："

#: src/idioms/ctor.md:8
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    // Constructs a new instance of [`Second`].\n"
"    // Note this is an associated function - no self.\n"
"    pub fn new(value: u64) -> Self {\n"
"        Self { value }\n"
"    }\n"
"\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    // [`Second`] のインスタンスを生成する。\n"
"    // 関連関数であることに注意： self が無い。 \n"
"    pub fn new(value: u64) -> Self {\n"
"        Self { value }\n"
"    }\n"
"\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:35
msgid "## Default Constructors"
msgstr "## デフォルトコンストラクタ"

#: src/idioms/ctor.md:37
msgid ""
"Rust supports default constructors with the [`Default`][std-default] trait:"
msgstr ""
"Rust は [`Default`][std-default] トレイトとして、デフォルトコンストラクタをサ"
"ポートしています："

#: src/idioms/ctor.md:39
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"\n"
"impl Default for Second {\n"
"    fn default() -> Self {\n"
"        Self { value: 0 }\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間。\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"\n"
"impl Default for Second {\n"
"    fn default() -> Self {\n"
"        Self { value: 0 }\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:66
msgid ""
"`Default` can also be derived if all types of all fields implement "
"`Default`,\n"
"like they do with `Second`:"
msgstr ""
"すべてのフィールドのすべての型が `Default` を実装していれば、 `Default` も派"
"生させることができます。下記の `Second` で行っているように："

#: src/idioms/ctor.md:69
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"#[derive(Default)]\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間。\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"#[derive(Default)]\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:91
msgid ""
"**Note:** It is common and expected for types to implement both\n"
"`Default` and an empty `new` constructor. `new` is the constructor\n"
"convention in Rust, and users expect it to exist, so if it is\n"
"reasonable for the basic constructor to take no arguments, then it\n"
"should, even if it is functionally identical to default."
msgstr ""
"**注意:** 型が `Default` と 空の `new` コンストラクタの両方を実装することは一"
"般的であり、期待されています。\n"
"`new` は Rust におけるコンストラクタの慣習であり、ユーザはその存在を期待して"
"います。\n"
"基本的なコンストラクタが引数を取らないことが合理的であれば、たとえ機能的には "
"default と同じであるとしても、実装すべきです。"

#: src/idioms/ctor.md:97
msgid ""
"**Hint:** The advantage of implementing or deriving `Default` is that your "
"type\n"
"can now be used where a `Default` implementation is required, most "
"prominently,\n"
"any of the [`*or_default` functions in the standard library][std-or-default]."
msgstr ""
"**ヒント:** `Default` を実装または派生させることの利点は、あなたの型が "
"`Default` の実装が必要な場所で使用できるようになることです。特に重要なのは、 "
"[標準ライブラリの `*or_default` 関数][std-or-default] です。"

#: src/idioms/ctor.md:103
msgid ""
"- The [default idiom](default.md) for a more in-depth description of the\n"
"  `Default` trait.\n"
"\n"
"- The [builder pattern](../patterns/creational/builder.md) for constructing\n"
"  objects where there are multiple configurations.\n"
"\n"
"- [API Guidelines/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS] for\n"
"  implementing both, `Default` and `new`."
msgstr ""
"- `Default` トレイトについてのより詳細な記述は [default idiom](default.md)を"
"参照してください。\n"
"\n"
"- 多数の設定項目を持つオブジェクトの構築については [builderパターン](../"
"patterns/creational/builder.md)を参照してください。\n"
"\n"
"- [APIガイドライン/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS]を参照して"
"ください。\n"
"  Default`と`new`の両方を実装します。"

#: src/idioms/default.md:1
msgid "# The `Default` Trait"
msgstr "# `Default` トレイト"

#: src/idioms/default.md:5
msgid ""
"Many types in Rust have a [constructor]. However, this is _specific_ to the\n"
"type; Rust cannot abstract over \"everything that has a `new()` method\". "
"To\n"
"allow this, the [`Default`] trait was conceived, which can be used with\n"
"containers and other generic types (e.g. see [`Option::"
"unwrap_or_default()`]).\n"
"Notably, some containers already implement it where applicable."
msgstr ""
"Rustの多くの型には [コンストラクタ][constructor] があります。しかし、これはそ"
"の型 _固有_ のものです。\n"
"Rustは「 `new()` メソッドを持つものすべて」を抽象化することはできません。\n"
"これを可能にするために、[`Default`] 特性が考案されました。\n"
"コンテナや他のジェネリック型と一緒に使うことができます (例えば、[`Option::"
"unwrap_or_default()`] を参照してください)。\n"
"注目すべきことに、いくつかのコンテナはすでにこれを実装しています。"

#: src/idioms/default.md:11
msgid ""
"Not only do one-element containers like `Cow`, `Box` or `Arc` implement\n"
"`Default` for contained `Default` types, one can automatically\n"
"`#[derive(Default)]` for structs whose fields all implement it, so the more\n"
"types implement `Default`, the more useful it becomes."
msgstr ""
"`Cow`、`Box`、`Arc` のような 1要素のコンテナが内包する `Default` 型に対して "
"`Default` を実装しているだけではありません。 すべてのフィールドが `Default` "
"を実装している構造体に対しては `#[derive(Default)]` による自動派生を適用でき"
"ます。\n"
"型が `Default` を実装すればするほど便利になります。"

#: src/idioms/default.md:16
msgid ""
"On the other hand, constructors can take multiple arguments, while the\n"
"`default()` method does not. There can even be multiple constructors with\n"
"different names, but there can only be one `Default` implementation per type."
msgstr ""
"コンストラクタは複数の引数を取ることができます。対して `default()` メソッドで"
"はできません。\n"
"また異なる名称の複数のコンストラクタを定義することもできます。\n"
"対して `Default` の実装は1つの型につき1つだけです。"

#: src/idioms/default.md:22
msgid ""
"```rust\n"
"use std::{path::PathBuf, time::Duration};\n"
"\n"
"// note that we can simply auto-derive Default here.\n"
"#[derive(Default, Debug, PartialEq)]\n"
"struct MyConfiguration {\n"
"    // Option defaults to None\n"
"    output: Option<PathBuf>,\n"
"    // Vecs default to empty vector\n"
"    search_path: Vec<PathBuf>,\n"
"    // Duration defaults to zero time\n"
"    timeout: Duration,\n"
"    // bool defaults to false\n"
"    check: bool,\n"
"}\n"
"\n"
"impl MyConfiguration {\n"
"    // add setters here\n"
"}\n"
"\n"
"fn main() {\n"
"    // construct a new instance with default values\n"
"    let mut conf = MyConfiguration::default();\n"
"    // do something with conf here\n"
"    conf.check = true;\n"
"    println!(\"conf = {:#?}\", conf);\n"
"        \n"
"    // partial initialization with default values, creates the same "
"instance\n"
"    let conf1 = MyConfiguration {\n"
"        check: true,\n"
"        ..Default::default()\n"
"    };\n"
"    assert_eq!(conf, conf1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::{path::PathBuf, time::Duration};\n"
"\n"
"// ここでは単にDefaultを自動派生できることに注目してください。\n"
"#[derive(Default, Debug, PartialEq)]\n"
"struct MyConfiguration {\n"
"    // Option のデフォルトは None\n"
"    output: Option<PathBuf>,\n"
"    // Vecs のデフォルトは空のベクタr\n"
"    search_path: Vec<PathBuf>,\n"
"    // Duration のデフォルトは 0時間\n"
"    timeout: Duration,\n"
"    // bool のデフォルトは false\n"
"    check: bool,\n"
"}\n"
"\n"
"impl MyConfiguration {\n"
"    // add setters here\n"
"}\n"
"\n"
"fn main() {\n"
"    // デフォルト値で新しいインスタンスを構築します\n"
"    let mut conf = MyConfiguration::default();\n"
"    // ここで conf に何かをします\n"
"    conf.check = true;\n"
"    println!(\"conf = {:#?}\", conf);\n"
"        \n"
"    // デフォルト値を使い部分的に初期化し、同じインスタンスを作成します。\n"
"    let conf1 = MyConfiguration {\n"
"        check: true,\n"
"        ..Default::default()\n"
"    };\n"
"    assert_eq!(conf, conf1);\n"
"}\n"
"```"

#: src/idioms/default.md:60
msgid ""
"- The [constructor] idiom is another way to generate instances that may or "
"may\n"
"  not be \"default\"\n"
"- The [`Default`] documentation (scroll down for the list of implementors)\n"
"- [`Option::unwrap_or_default()`]\n"
"- [`derive(new)`]"
msgstr ""
"- [コンストラクタ][constructor] イディオムは、 \"default\" であるかどうかにか"
"かわらずインスタンスを生成する別の方法です。\n"
"- [`Default`]ドキュメント (実装する型の一覧は下にスクロールしてください)\n"
"- [`Option::unwrap_or_default()`] \n"
"- [`derive(new)`]"

#: src/idioms/deref.md:1
msgid "# Collections are smart pointers"
msgstr "# スマートポインタとしてのコレクション"

#: src/idioms/deref.md:5
msgid ""
"Use the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)\n"
"trait to treat collections like smart pointers, offering owning\n"
"and borrowed views of data."
msgstr ""
"コレクションに [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) "
"トレイトを使うことで、そのデータに対し所有や借用のビューを提供するスマートポ"
"インタのようにコレクションを扱えます。"

#: src/idioms/deref.md:11
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Vec<T> {\n"
"    data: RawVec<T>,\n"
"    //..\n"
"}\n"
"\n"
"impl<T> Deref for Vec<T> {\n"
"    type Target = [T];\n"
"\n"
"    fn deref(&self) -> &[T] {\n"
"        //..\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Vec<T> {\n"
"    data: RawVec<T>,\n"
"    //..\n"
"}\n"
"\n"
"impl<T> Deref for Vec<T> {\n"
"    type Target = [T];\n"
"\n"
"    fn deref(&self) -> &[T] {\n"
"        //..\n"
"    }\n"
"}\n"
"```"

#: src/idioms/deref.md:28
msgid ""
"A `Vec<T>` is an owning collection of `T`s, while a slice (`&[T]`) is a "
"borrowed\n"
"collection of `T`s. Implementing `Deref` for `Vec` allows implicit "
"dereferencing\n"
"from `&Vec<T>` to `&[T]` and includes the relationship in auto-derefencing\n"
"searches. Most methods you might expect to be implemented for `Vec`s are "
"instead\n"
"implemented for slices."
msgstr ""
"スライス(`&[T]`)が `T` の借用のコレクションであるのに対し、 `Vec<T>` は`T` の"
"所有のコレクションです。\n"
"`Vec` に `Deref` を実装することで、 `&Vec<T>` から `&[T]` への暗黙的な参照外"
"しが可能になるとともに、\n"
"自動参照外しの検索対象に組み込まれます。\n"
"`Vec` に実装されることが期待されるほとんどのメソッドは、代わりにスライスのそ"
"れとして実装されます。"

#: src/idioms/deref.md:34
msgid "Also `String` and `&str` have a similar relation."
msgstr "`String` と `&str` もまた同様の関係にあります。"

#: src/idioms/deref.md:36 src/idioms/dtor-finally.md:32
#: src/idioms/mem-replace.md:57 src/idioms/on-stack-dyn-dispatch.md:37
#: src/idioms/ffi/accepting-strings.md:12 src/idioms/ffi/passing-strings.md:14
#: src/idioms/rustdoc-init.md:9 src/idioms/return-consumed-arg-on-error.md:43
#: src/patterns/behavioural/command.md:8
#: src/patterns/behavioural/interpreter.md:16
#: src/patterns/behavioural/newtype.md:45 src/patterns/behavioural/RAII.md:72
#: src/patterns/behavioural/strategy.md:19
#: src/patterns/behavioural/visitor.md:72 src/patterns/creational/builder.md:63
#: src/patterns/creational/fold.md:73
#: src/patterns/structural/compose-structs.md:92 src/patterns/ffi/export.md:15
#: src/anti_patterns/borrow_clone.md:30
msgid "## Motivation"
msgstr "## 動機"

#: src/idioms/deref.md:38
msgid ""
"Ownership and borrowing are key aspects of the Rust language. Data "
"structures\n"
"must account for these semantics properly to give a good user\n"
"experience. When implementing a data structure that owns its data, offering "
"a\n"
"borrowed view of that data allows for more flexible APIs."
msgstr ""
"所有権と借用はRust言語の重要な側面です。データ構造は、よりよいユーザエクスペ"
"リエンスのため、これらのセマンティクスに則る必要があります。\n"
"データを所有するデータ構造を実装する場合、そのデータへの借用のビューを提供す"
"ることで、よりフレキシブルなAPIを提供することが可能になります。"

#: src/idioms/deref.md:45
msgid ""
"Most methods can be implemented only for the borrowed view, they are then\n"
"implicitly available for the owning view."
msgstr ""
"ほとんどのメソッドが借用の型に対して実装可能です。それらメソッドが参照外しに"
"より、所有の型に対しても暗黙的に利用可能になります。"

#: src/idioms/deref.md:48
msgid "Gives clients a choice between borrowing or taking ownership of data."
msgstr ""
"データの借用を行うか、所有権を取るか、利用者が選択できるようにしましょう。"

#: src/idioms/deref.md:52
msgid ""
"Methods and traits only available via dereferencing are not taken into "
"account\n"
"when bounds checking, so generic programming with data structures using "
"this\n"
"pattern can get complex (see the `Borrow` and `AsRef` traits, etc.)."
msgstr ""
"参照外しを通してのみ利用可能なメソッドとトレイトは、境界チェックの際に考慮さ"
"れません。そのため、このパターンを使用したデータ構造でのジェネリックプログラ"
"ミングは複雑になる可能性があります (トレイト `Borrow` や `AsRef` など参照)。"

#: src/idioms/deref.md:56 src/idioms/dtor-finally.md:61
#: src/idioms/mem-replace.md:97 src/idioms/on-stack-dyn-dispatch.md:68
#: src/idioms/priv-extend.md:85 src/idioms/rustdoc-init.md:87
#: src/patterns/behavioural/command.md:203
#: src/patterns/behavioural/interpreter.md:103
#: src/patterns/behavioural/newtype.md:74 src/patterns/behavioural/RAII.md:83
#: src/patterns/behavioural/strategy.md:110
#: src/patterns/behavioural/visitor.md:79 src/patterns/creational/builder.md:81
#: src/patterns/creational/fold.md:85
#: src/patterns/structural/compose-structs.md:109
#: src/anti_patterns/deref.md:102
msgid "## Discussion"
msgstr "## 議論"

#: src/idioms/deref.md:58
msgid ""
"Smart pointers and collections are analogous: a smart pointer points to a "
"single\n"
"object, whereas a collection points to many objects. From the point of view "
"of\n"
"the type system, there is little difference between the two. A collection "
"owns\n"
"its data if the only way to access each datum is via the collection and the\n"
"collection is responsible for deleting the data (even in cases of shared\n"
"ownership, some kind of borrowed view may be appropriate). If a collection "
"owns\n"
"its data, it is usually useful to provide a view of the data as borrowed so "
"that\n"
"it can be referenced multiple times."
msgstr ""
"スマート・ポインタとコレクションは相似です。スマートポインタは単一のオブジェ"
"クトを指すのに対し、コレクションは多数のオブジェクトを指します。\n"
"型システムの観点からは、両者にほとんど違いはありません。\n"
"各データへのコレクション経由でのみアクセス可能なとき、コレクションはそれら"
"データを所有するとともに削除の責任を持ちます(所有権をを共有している場合でも、"
"一部の借用のビューでは当てはまります)。\n"
"コレクションがそのデータを所有する場合に、そのデータへの借用のビューを提供し"
"複数回参照可能にすることは、一般に有用です。"

#: src/idioms/deref.md:67
msgid ""
"Most smart pointers (e.g., `Foo<T>`) implement `Deref<Target=T>`. However,\n"
"collections will usually dereference to a custom type. `[T]` and `str` have "
"some\n"
"language support, but in the general case, this is not necessary. `Foo<T>` "
"can\n"
"implement `Deref<Target=Bar<T>>` where `Bar` is a dynamically sized type "
"and\n"
"`&Bar<T>` is a borrowed view of the data in `Foo<T>`."
msgstr ""
"ほとんどのスマートポインタ(例えば `Foo<T>`)は `Deref<Target=T>` を実装しま"
"す。\n"
"しかしコレクションは通常、カスタム型に参照外しされます。 `[T]`と `str` にはい"
"くつかの言語サポートがありますが、一般的なケースでは、その必要はありませ"
"ん。\n"
"`Foo<T>` が `Deref<Target=Bar<T>>` を実装することがあります。ここで `Bar` は"
"動的なサイズの型であり、`&Bar<T>` は `Foo<T>` のデータの借用のビューです。"

#: src/idioms/deref.md:73
msgid ""
"Commonly, ordered collections will implement `Index` for `Range`s to "
"provide\n"
"slicing syntax. The target will be the borrowed view."
msgstr ""
"一般的に、順序付きコレクションは `Range` に対して `Index` を実装し、スライス"
"構文を提供します。このターゲットは借用のビューになります。"

#: src/idioms/deref.md:78
msgid ""
"- [Deref polymorphism anti-pattern](../anti_patterns/deref.md).\n"
"- [Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."
msgstr ""
"- [Deref ポリモーフィズムのアンチパターン](../anti_patterns/deref.md).\n"
"- [`Deref` トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."

#: src/idioms/dtor-finally.md:1
msgid "# Finalisation in destructors"
msgstr "# デストラクタでのファイナライズ"

#: src/idioms/dtor-finally.md:5
msgid ""
"Rust does not provide the equivalent to `finally` blocks - code that will "
"be\n"
"executed no matter how a function is exited. Instead, an object's destructor "
"can\n"
"be used to run code that must be run before exit."
msgstr ""
"Rust には `finally` ブロック（関数の終了の仕方を問わずに実行されるコード）に"
"相当するものがありません。\n"
"その代わりに、オブジェクトのデストラクタを使用して、終了前に実行しなければな"
"らないコードを実行させることができます。"

#: src/idioms/dtor-finally.md:11
msgid ""
"```rust,ignore\n"
"fn bar() -> Result<(), ()> {\n"
"    // These don't need to be defined inside the function.\n"
"    struct Foo;\n"
"\n"
"    // Implement a destructor for Foo.\n"
"    impl Drop for Foo {\n"
"        fn drop(&mut self) {\n"
"            println!(\"exit\");\n"
"        }\n"
"    }\n"
"\n"
"    // The dtor of _exit will run however the function `bar` is exited.\n"
"    let _exit = Foo;\n"
"    // Implicit return with `?` operator.\n"
"    baz()?;\n"
"    // Normal return.\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn bar() -> Result<(), ()> {\n"
"    // 関数内で定義する必要はありません。\n"
"    struct Foo;\n"
"\n"
"    // Fooのデストラクタを実装。\n"
"    impl Drop for Foo {\n"
"        fn drop(&mut self) {\n"
"            println!(\"exit\");\n"
"        }\n"
"    }\n"
"\n"
"    // _exit のデストラクタは `bar` の抜け方にかかわらず実行されます。\n"
"    let _exit = Foo;\n"
"    // `?` による暗黙的な return。\n"
"    baz()?;\n"
"    // 通常の return。\n"
"    Ok(())\n"
"}\n"
"```"

#: src/idioms/dtor-finally.md:34
msgid ""
"If a function has multiple return points, then executing code on exit "
"becomes\n"
"difficult and repetitive (and thus bug-prone). This is especially the case "
"where\n"
"return is implicit due to a macro. A common case is the `?` operator which\n"
"returns if the result is an `Err`, but continues if it is `Ok`. `?` is used "
"as\n"
"an exception handling mechanism, but unlike Java (which has `finally`), "
"there is\n"
"no way to schedule code to run in both the normal and exceptional cases.\n"
"Panicking will also exit a function early."
msgstr ""
"関数に複数のリターン・ポイントがある場合、関数終了時にコードを実行するのは難"
"しく、繰り返し的になり（またそれゆえにバグの原因になり）ます。特にreturnがマ"
"クロによって暗黙的に行われる場合です。\n"
"よくあるケースが `?` 演算子で、これは結果が `Err` なら戻り、`Ok` なら続行する"
"ものです。 `?` は例外処理のメカニズムとして使用されますすが、(`finally`を持"
"つ) Javaとは異なり、通常と例外の両方のケースで実行されるコードを実装する方法"
"はありません。\n"
"また、パニックが起きると関数は早期に終了します。"

#: src/idioms/dtor-finally.md:44
msgid ""
"Code in destructors will (nearly) always be run - copes with panics, early\n"
"returns, etc."
msgstr ""
"デストラクタ内のコードは（ほぼ）常に実行されます。パニックや早期returnなどに"
"も対処できます。"

#: src/idioms/dtor-finally.md:49
msgid ""
"It is not guaranteed that destructors will run. For example, if there is an\n"
"infinite loop in a function or if running a function crashes before exit.\n"
"Destructors are also not run in the case of a panic in an already panicking\n"
"thread. Therefore, destructors cannot be relied on as finalizers where it "
"is\n"
"absolutely essential that finalisation happens."
msgstr ""
"デストラクタの実行は保証されていません。\n"
"例えば関数の無限ループがある場合や、関数の実行が終了前にクラッシュした場合な"
"どです。\n"
"また、すでにパニックになっているスレッドでパニックが発生した場合にも、デスト"
"ラクタは実行されません。\n"
"したがって、絶対的かつ本質的にファイナライズを行うファイナライザとしては、デ"
"ストラクタを頼ることはできません。"

#: src/idioms/dtor-finally.md:55
msgid ""
"This pattern introduces some hard to notice, implicit code. Reading a "
"function\n"
"gives no clear indication of destructors to be run on exit. This can make\n"
"debugging tricky."
msgstr ""
"このパターンは、気づきにくい暗黙のコードを導入することになります。関数を読ん"
"でも、 終了時にデストラクタが実行されることについて、明らかな兆候が得られませ"
"ん。これはデバッグを厄介なものにする可能性があります。"

#: src/idioms/dtor-finally.md:59
msgid ""
"Requiring an object and `Drop` impl just for finalisation is heavy on "
"boilerplate."
msgstr ""
"ファイナライズのためだけにオブジェクトと `Drop` の実装が必要となり、ボイラー"
"テンプレートが多くなります。"

#: src/idioms/dtor-finally.md:63
msgid ""
"There is some subtlety about how exactly to store the object used as a\n"
"finalizer. It must be kept alive until the end of the function and must then "
"be\n"
"destroyed. The object must always be a value or uniquely owned pointer (e."
"g.,\n"
"`Box<Foo>`). If a shared pointer (such as `Rc`) is used, then the finalizer "
"can\n"
"be kept alive beyond the lifetime of the function. For similar reasons, the\n"
"finalizer should not be moved or returned."
msgstr ""
"ファイナライザとして使用されるオブジェクトの正確な格納方法については、繊細な"
"点があります。\n"
"このオブジェクトは関数が終了するまで存続しなければならず、また終了時に破棄さ"
"れなければなりません。\n"
"このオブジェクトは常に値か一意に所有されるポインタでなければなりません (例 "
"`Box<Foo>` など) 。もし共有ポインタ(`Rc`など)を使用した場合、ファイナライザが"
"関数のライフタイムを超えて存続してしまう可能性があります。\n"
"同様の理由でファイナライザの所有権を移動したり、ファイナライザを戻り値として"
"はいけません。"

#: src/idioms/dtor-finally.md:70
msgid ""
"The finalizer must be assigned into a variable, otherwise it will be "
"destroyed\n"
"immediately, rather than when it goes out of scope. The variable name must "
"start\n"
"with `_` if the variable is only used as a finalizer, otherwise the "
"compiler\n"
"will warn that the finalizer is never used. However, do not call the "
"variable\n"
"`_` with no suffix - in that case it will be destroyed immediately."
msgstr ""
"ファイナライザは変数に代入しなければなりません。そうでないとスコープを外れる"
"前に即座に破棄されます。\n"
"変数名は `_` で始まらなければなりません。そうでないとコンパイラは変数が利用さ"
"れていない旨の警告を出します。\n"
"しかし変数をサフィックスなしの `_` としてはいけません。そうすると、即座に破棄"
"されてしまいます。"

#: src/idioms/dtor-finally.md:76
msgid ""
"In Rust, destructors are run when an object goes out of scope. This happens\n"
"whether we reach the end of block, there is an early return, or the program\n"
"panics. When panicking, Rust unwinds the stack running destructors for each\n"
"object in each stack frame. So, destructors get called even if the panic "
"happens\n"
"in a function being called."
msgstr ""
"Rustでは、デストラクタはオブジェクトがスコープ外に出たときに実行されます。\n"
"これが起こるのは、ブロックの終了に到達したとき、早期returnのとき、パニックが"
"発生したときです。\n"
"パニックが起きると、Rustはスタックフレームの各オブジェクトのデストラクタを実"
"行しつつスタックを巻き戻します。\n"
"そのため、呼び出し中の関数内にてパニックが発生した場合でも、デストラクタが呼"
"び出されます。"

#: src/idioms/dtor-finally.md:82
msgid ""
"If a destructor panics while unwinding, there is no good action to take, so "
"Rust\n"
"aborts the thread immediately, without running further destructors. This "
"means\n"
"that destructors are not absolutely guaranteed to run. It also means that "
"you\n"
"must take extra care in your destructors not to panic, since it could leave\n"
"resources in an unexpected state."
msgstr ""
"デストラクタが巻き戻し中にパニックを起こした場合、取るべき良いアクションはあ"
"りません。\n"
"よってRustはそれ以上デストラクタを実行せずに、スレッドを即座に終了させま"
"す。\n"
"これは、デストラクタの実行が絶対に保証されているわけではないということを意味"
"します。\n"
"また、デストラクタがパニックに陥らないように細心の注意を払う必要があるという"
"ことでもあります。\n"
"リソースを想定されない状態にする可能性があるからです。"

#: src/idioms/dtor-finally.md:90
msgid "[RAII guards](../patterns/behavioural/RAII.md)."
msgstr "[RAIIガード](../patterns/behavioural/RAII.md)。"

#: src/idioms/mem-replace.md:1
msgid "# `mem::{take(_), replace(_)}` to keep owned values in changed enums"
msgstr "# `mem::{take(_), replace(_)}` による値を所有したままの列挙値の変換"

#: src/idioms/mem-replace.md:5
msgid ""
"Say we have a `&mut MyEnum` which has (at least) two variants,\n"
"`A { name: String, x: u8 }` and `B { name: String }`. Now we want to change\n"
"`MyEnum::A` to a `B` if `x` is zero, while keeping `MyEnum::B` intact."
msgstr ""
"`A { name: String, x: u8 }` と `B { name: String }` という(少なくとも) 2つの"
"バリアントを持つ `&mut MyEnum` があるとします。\n"
"`MyEnum::A` をその `x` が 0 の場合に `B` に変更したいとします。このとき "
"`MyEnum::B` に手を入れたくないとします。"

#: src/idioms/mem-replace.md:9
msgid "We can do this without cloning the `name`."
msgstr "`name` をクローンすることなく、これを実行できます。"

#: src/idioms/mem-replace.md:13
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MyEnum {\n"
"    A { name: String, x: u8 },\n"
"    B { name: String }\n"
"}\n"
"\n"
"fn a_to_b(e: &mut MyEnum) {\n"
"    if let MyEnum::A { name, x: 0 } = e {\n"
"        // this takes out our `name` and put in an empty String instead\n"
"        // (note that empty strings don't allocate).\n"
"        // Then, construct the new enum variant (which will\n"
"        // be assigned to `*e`).\n"
"        *e = MyEnum::B { name: mem::take(name) }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MyEnum {\n"
"    A { name: String, x: u8 },\n"
"    B { name: String }\n"
"}\n"
"\n"
"fn a_to_b(e: &mut MyEnum) {\n"
"    if let MyEnum::A { name, x: 0 } = e {\n"
"        // これは `name` を取り出し、その代わりに空文字列を置きます。\n"
"        // (空文字列はメモリが割り当てが発生しないことに注意)\n"
"        // そして、新しい列挙型のバリアントを作成します( `*e` に代入しま"
"す)。\n"
"        *e = MyEnum::B { name: mem::take(name) }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/mem-replace.md:32
msgid "This also works with more variants:"
msgstr "より多くのバリアントでも同様です："

#: src/idioms/mem-replace.md:34
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MultiVariateEnum {\n"
"    A { name: String },\n"
"    B { name: String },\n"
"    C,\n"
"    D\n"
"}\n"
"\n"
"fn swizzle(e: &mut MultiVariateEnum) {\n"
"    use MultiVariateEnum::*;\n"
"    *e = match e {\n"
"        // Ownership rules do not allow taking `name` by value, but we "
"cannot\n"
"        // take the value out of a mutable reference, unless we replace it:\n"
"        A { name } => B { name: mem::take(name) },\n"
"        B { name } => A { name: mem::take(name) },\n"
"        C => D,\n"
"        D => C\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MultiVariateEnum {\n"
"    A { name: String },\n"
"    B { name: String },\n"
"    C,\n"
"    D\n"
"}\n"
"\n"
"fn swizzle(e: &mut MultiVariateEnum) {\n"
"    use MultiVariateEnum::*;\n"
"    *e = match e {\n"
"        // 所有権のルールは `name` を値として取り出すことを禁じているため、\n"
"        // 置き換える形以外では、ミュータブルな参照の外へ値を取り出せない。\n"
"        A { name } => B { name: mem::take(name) },\n"
"        B { name } => A { name: mem::take(name) },\n"
"        C => D,\n"
"        D => C\n"
"    }\n"
"}\n"
"```"

#: src/idioms/mem-replace.md:59
msgid ""
"When working with enums, we may want to change an enum value in place, "
"perhaps\n"
"to another variant. This is usually done in two phases to keep the borrow\n"
"checker happy. In the first phase, we observe the existing value and look "
"at\n"
"its parts to decide what to do next. In the second phase we may "
"conditionally\n"
"change the value (as in the example above)."
msgstr ""
"列挙型を扱うとき、ある列挙型の値を別のバリアントに置き換えたいことがありま"
"す。\n"
"通常これは、借用チェッカーを満足させるために、二段階に分けて行われます。\n"
"第一段階では、既存の値を参照し、その一部を見て次の処理を決めます。\n"
"第二段階では、(上の例のように) 条件付きで値を変更することができます。"

#: src/idioms/mem-replace.md:65
msgid ""
"The borrow checker won't allow us to take out `name` of the enum (because\n"
"_something_ must be there.) We could of course `.clone()` name and put the "
"clone\n"
"into our `MyEnum::B`, but that would be an instance of the [Clone to satisfy "
"the borrow checker](../anti_patterns/borrow_clone.md) anti-pattern. Anyway, "
"we\n"
"can avoid the extra allocation by changing `e` with only a mutable borrow."
msgstr ""
"借用チェッカーは列挙型の `name` を取り出すことを許可しません (そこに _何か_ "
"がなければならないため)。\n"
"もちろん、 `name` を `.clone()` して、そのクローンを `MyEnum::B` に入れること"
"はできますが、\n"
"それは [借用チェッカーを満足させるためのClone](../anti_patterns/borrow_clone."
"md) アンチパターンのインスタンスになってしまいます。\n"
"いずれにせよ、 ミュータブルな借用のみ使用し ‘e‘ を変更することで余分なアロ"
"ケーションを避けることができます。"

#: src/idioms/mem-replace.md:70
msgid ""
"`mem::take` lets us swap out the value, replacing it with it's default "
"value,\n"
"and returning the previous value. For `String`, the default value is an "
"empty\n"
"`String`, which does not need to allocate. As a result, we get the original\n"
"`name` _as an owned value_. We can then wrap this in another enum."
msgstr ""
"`mem::take` は、値をそのデフォルト値に置き換えるとともに、元の値を返します。"
"これにより値を入れ替える形で取り出せます。\n"
"`String`の場合、デフォルト値は空の `String` であり、アロケートの必要がありま"
"せん。\n"
"結果として、元の `name` を _所有した値として_ 取得できます。そしてこれを別の"
"列挙型にラップすることができます。"

#: src/idioms/mem-replace.md:75
msgid ""
"**NOTE:** `mem::replace` is very similar, but allows us to specify what to\n"
"replace the value with. An equivalent to our `mem::take` line would be\n"
"`mem::replace(name, String::new())`."
msgstr ""
"**NOTE:** `mem::replace` は非常に似ていますが、値を何に置き換えるかを指定でき"
"ます。\n"
"例示の `mem::take` は `mem::replace(name, String::new())` に相当します。"

#: src/idioms/mem-replace.md:79
msgid ""
"Note, however, that if we are using an `Option` and want to replace its\n"
"value with a `None`, `Option`’s `take()` method provides a shorter and\n"
"more idiomatic alternative."
msgstr ""
"ただし `Option` を使用していてその値を `None` に置き換えたい状況では、 "
"`Option` の `take()` メソッドを使用することがより短くイディオム的な代替手段で"
"あること注意してください。"

# インディージョーンズが何かトラップを回避するために宝物的なモノを置き換えることをイメージしている？
#: src/idioms/mem-replace.md:85
msgid ""
"Look ma, no allocation! Also you may feel like Indiana Jones while doing it."
msgstr ""
"アロケーションが発生しません！インディ・ジョーンズがそうするような気分になれ"
"るかもしれません。"

#: src/idioms/mem-replace.md:89
msgid ""
"This gets a bit wordy. Getting it wrong repeatedly will make you hate the\n"
"borrow checker. The compiler may fail to optimize away the double store,\n"
"resulting in reduced performance as opposed to what you'd do in unsafe\n"
"languages."
msgstr ""
"少しくどい表現になります。\n"
"何度も間違えると借用チェッカーが憎くなるかもしれません。\n"
"コンパイラはダブルストアの最適化に失敗するかもしれません、\n"
"その結果、 unsafe で行うのとは対照的に、パフォーマンスが低下します。"

#: src/idioms/mem-replace.md:94
msgid ""
"Furthermore, the type you are taking needs to implement the [`Default` trait]"
"(./default.md). However, if the type you're working with doesn't\n"
"implement this, you can instead use `mem::replace`."
msgstr ""
"さらに、扱う型は [`Default` trait](./default.md) を実装している必要がありま"
"す。\n"
"もし実装していない場合は、代わりに `mem::replace` を使用することができます。"

#: src/idioms/mem-replace.md:99
msgid ""
"This pattern is only of interest in Rust. In GC'd languages, you'd take the\n"
"reference to the value by default (and the GC would keep track of refs), and "
"in\n"
"other low-level languages like C you'd simply alias the pointer and fix "
"things\n"
"later."
msgstr ""
"このパターンが注目されるのはRustだけです。\n"
"GCのある言語では、デフォルトで値への参照を取ります（そしてGCは参照を追跡しま"
"す）。\n"
"Cのような低レベル言語では、単にポインタをエイリアスして後から修正します。"

#: src/idioms/mem-replace.md:104
msgid ""
"However, in Rust, we have to do a little more work to do this. An owned "
"value\n"
"may only have one owner, so to take it out, we need to put something back in "
"–\n"
"like Indiana Jones, replacing the artifact with a bag of sand."
msgstr ""
"しかしRustでは、これを行うにはもう少し工夫が必要です。\n"
"所有された値には所有者が1人しかいないので、それを取り出すには、何かを戻す必要"
"があります。\n"
"インディ・ジョーンズのように、アーティファクトを砂袋に置き換えるのです。"

#: src/idioms/mem-replace.md:110
msgid ""
"This gets rid of the [Clone to satisfy the borrow checker](../anti_patterns/"
"borrow_clone.md)\n"
"anti-pattern in a specific case."
msgstr ""
"これは [借用チェッカーを満足させるためのClone](../anti_patterns/borrow_clone."
"md) アンチパターンを特定のケースで取り除くものです。"

#: src/idioms/on-stack-dyn-dispatch.md:1
msgid "# On-Stack Dynamic Dispatch"
msgstr "# オンスタックの動的ディスパッチ"

#: src/idioms/on-stack-dyn-dispatch.md:5
msgid ""
"We can dynamically dispatch over multiple values, however, to do so, we "
"need\n"
"to declare multiple variables to bind differently-typed objects. To extend "
"the\n"
"lifetime as necessary, we can use deferred conditional initialization, as "
"seen\n"
"below:"
msgstr ""
"複数の値を動的にディスパッチすることは可能ですが、\n"
"そうするためには、異なる型のオブジェクトに束縛するため複数の変数を宣言する必"
"要があります。\n"
"ライフタイムを必要に応じて延長するために、遅延条件付き初期化を使うことができ"
"ます。"

#: src/idioms/on-stack-dyn-dispatch.md:12
msgid ""
"```rust\n"
"use std::io;\n"
"use std::fs;\n"
"\n"
"# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"# let arg = \"-\";\n"
"\n"
"// These must live longer than `readable`, and thus are declared first:\n"
"let (mut stdin_read, mut file_read);\n"
"\n"
"// We need to ascribe the type to get dynamic dispatch.\n"
"let readable: &mut dyn io::Read = if arg == \"-\" {\n"
"    stdin_read = io::stdin();\n"
"    &mut stdin_read\n"
"} else {\n"
"    file_read = fs::File::open(arg)?;\n"
"    &mut file_read\n"
"};\n"
"\n"
"// Read from `readable` here.\n"
"\n"
"# Ok(())\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"use std::io;\n"
"use std::fs;\n"
"\n"
"# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"# let arg = \"-\";\n"
"\n"
"// These must live longer than `readable`, and thus are declared first:\n"
"// これらは `readable` よりも長く存在しなければならないので、最初に宣言しま"
"す：\n"
"let (mut stdin_read, mut file_read);\n"
"\n"
"// We need to ascribe the type to get dynamic dispatch.\n"
"// 動的なディスパッチを行うために、ディスパッチ先の型を指定する必要がありま"
"す。\n"
"let readable: &mut dyn io::Read = if arg == \"-\" {\n"
"    stdin_read = io::stdin();\n"
"    &mut stdin_read\n"
"} else {\n"
"    file_read = fs::File::open(arg)?;\n"
"    &mut file_read\n"
"};\n"
"\n"
"// ここで `readable` から読み出し。\n"
"\n"
"# Ok(())\n"
"# }\n"
"```"

#: src/idioms/on-stack-dyn-dispatch.md:39
msgid ""
"Rust monomorphises code by default. This means a copy of the code will be\n"
"generated for each type it is used with and optimized independently. While "
"this\n"
"allows for very fast code on the hot path, it also bloats the code in "
"places\n"
"where performance is not of the essence, thus costing compile time and "
"cache\n"
"usage."
msgstr ""
"Rustはデフォルトでコードを単相化します。これは、使用する型毎にコードのコピー"
"が生成され、別個に最適化されることを意味します。\n"
"これはホットパスにおける非常に高速なコードを実現しますが、\n"
"パフォーマンスが重要でない場所においてコードが肥大化することにもなります。そ"
"の結果コンパイル時間やキャッシュの使用量が犠牲になります。"

#: src/idioms/on-stack-dyn-dispatch.md:45
msgid ""
"Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly "
"ask\n"
"for it."
msgstr ""
"幸いなことに、Rustでは動的ディスパッチが使えますが、明示的に要求する必要があ"
"ります。"

#: src/idioms/on-stack-dyn-dispatch.md:50
msgid ""
"We do not need to allocate anything on the heap. Neither do we need to\n"
"initialize something we won't use later, nor do we need to monomorphize the\n"
"whole code that follows to work with both `File` or `Stdin`."
msgstr ""
"ヒープ上に何もアロケートする必要がありません。\n"
"後で使わないものを初期化する必要もなく、 `File` と `Stdin` の両方で動作するよ"
"うに、続くコード全体を単相化する必要もありません。"

#: src/idioms/on-stack-dyn-dispatch.md:56
msgid "The code needs more moving parts than the `Box`-based version:"
msgstr "このコードは、 `Box` ベースのバージョンよりも多くの変動部があります："

#: src/idioms/on-stack-dyn-dispatch.md:58
msgid ""
"```rust,ignore\n"
"// We still need to ascribe the type for dynamic dispatch.\n"
"let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
"    Box::new(io::stdin())\n"
"} else {\n"
"    Box::new(fs::File::open(arg)?)\n"
"};\n"
"// Read from `readable` here.\n"
"```"
msgstr ""
"```rust,ignore\n"
"// We still need to ascribe the type for dynamic dispatch.\n"
"// この場合でも、動的なディスパッチを行うために、ディスパッチ先の型を指定する"
"必要があります。\n"
"let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
"    Box::new(io::stdin())\n"
"} else {\n"
"    Box::new(fs::File::open(arg)?)\n"
"};\n"
"// ここで `readable` から読み出し。\n"
"```"

#: src/idioms/on-stack-dyn-dispatch.md:70
msgid ""
"Rust newcomers will usually learn that Rust requires all variables to be\n"
"initialized _before use_, so it's easy to overlook the fact that _unused_\n"
"variables may well be uninitialized. Rust works quite hard to ensure that "
"this\n"
"works out fine and only the initialized values are dropped at the end of "
"their\n"
"scope."
msgstr ""
"Rustの初心者は通常、Rustはすべての変数を _使用前に_ 初期化する必要があること"
"を学びます。\n"
"そのため、 _未使用_ 変数が初期化されていないという事実を見落としがちです。\n"
"変数が初期化されていないという事実を見落としがちです。\n"
"Rust は、これが問題なく動作するよう相当な努力を払って保証しており、スコープの"
"最後には初期化済みの値のみがdropされます。"

#: src/idioms/on-stack-dyn-dispatch.md:76
msgid "The example meets all the constraints Rust places on us:"
msgstr "この例は、Rust が私たちに課しているすべての制約を満たしています："

#: src/idioms/on-stack-dyn-dispatch.md:78
msgid ""
"- All variables are initialized before using (in this case borrowing) them\n"
"- Each variable only holds values of a single type. In our example, `stdin` "
"is\n"
"  of type `Stdin`, `file` is of type `File` and `readable` is of type `&mut "
"dyn Read`\n"
"- Each borrowed value outlives all the references borrowed from it"
msgstr ""
"- すべての変数は、使用する（この場合は借用される）前に初期化されます。\n"
"- 各変数は単一の型の値のみを保持します。\n"
"  この例では、 `stdin_read` は `Stdin` 型、`file_read` は `File` 型、"
"`readable` は `&mut dyn Read` 型です。\n"
"- 借用された各値は、それから借用されたすべての参照よりも長生きします。"

#: src/idioms/on-stack-dyn-dispatch.md:85
msgid ""
"- [Finalisation in destructors](dtor-finally.md) and\n"
"  [RAII guards](../patterns/behavioural/RAII.md) can benefit from tight "
"control over\n"
"  lifetimes.\n"
"- For conditionally filled `Option<&T>`s of (mutable) references, one can\n"
"  initialize an `Option<T>` directly and use its [`.as_ref()`] method to get "
"an\n"
"  optional reference."
msgstr ""
"- [デストラクタでのファイナライズ](dtor-finally.md) と\n"
"  [RAIIガード](../patterns/behavioural/RAII.md)は、ライフタイムの厳密な制御か"
"ら恩恵を得ます。\n"
"- 条件により中身が決まる参照 (ミュータブル含む) の `Option<&T>` などに対して"
"は、次のようにします。\n"
"  `Option<T>` を直接初期化し、その [`.as_ref()`] メソッドを使用することで"
"Optionにくるまれた参照を取得できます。"

#: src/idioms/ffi/intro.md:1
msgid "# FFI Idioms"
msgstr "# FFIのイディオム"

#: src/idioms/ffi/intro.md:3
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid\n"
"traps for inexperienced users of `unsafe` Rust."
msgstr ""
"FFIコードを書くことは、それ自体が1つの課程です。\n"
"しかしながら、ポインタの役割を担い、`unsafe` Rustの経験の浅いユーザーが陥る罠"
"を回避する、いくつかのイディオムがあります。"

#: src/idioms/ffi/intro.md:7
msgid "This section contains idioms that may be useful when doing FFI."
msgstr "このセクションでは、FFIを行う際に役立つイディオムを紹介します。"

# タイトル名は要見直し。目次見直しの時でもいいが・・・
#: src/idioms/ffi/intro.md:9
msgid ""
"1. [Idiomatic Errors](./errors.md) - Error handling with integer codes and\n"
"   sentinel return values (such as `NULL` pointers)\n"
"\n"
"2. [Accepting Strings](./accepting-strings.md) with minimal unsafe code\n"
"\n"
"3. [Passing Strings](./passing-strings.md) to FFI functions"
msgstr ""
"1.[慣習的なエラー](./errors.md) - 整数コードと番人戻り値（`NULL`ポインタな"
"ど）によるエラー処理\n"
"\n"
"2. 最小の `unsafe` コードでの [文字列の受け入れ](./accepting-strings.md) \n"
"\n"
"3.FFI関数への[文字列の受け渡し](./passing-strings.md)"

#: src/idioms/ffi/errors.md:1
msgid "# Error Handling in FFI"
msgstr "# FFI のエラー処理"

#: src/idioms/ffi/errors.md:5
msgid ""
"In foreign languages like C, errors are represented by return codes.\n"
"However, Rust's type system allows much more rich error information to be\n"
"captured and propogated through a full type."
msgstr ""
"C言語のような言語では、エラーはリターンコードで表されます。\n"
"しかしRustの型システムは、よりリッチなエラー情報を完全な型を通して捕捉、伝播"
"することが可能です。"

#: src/idioms/ffi/errors.md:9
msgid ""
"This best practice shows different kinds of error codes, and how to expose "
"them\n"
"in a usable way:"
msgstr ""
"このベストプラクティスでは、さまざまな種類のエラーコードを示し、どのようにそ"
"れらを扱いやすい方法で公開するかを示します："

#: src/idioms/ffi/errors.md:12
msgid ""
"1. Flat Enums should be converted to integers and returned as codes.\n"
"2. Structured Enums should be converted to an integer code with a string "
"error\n"
"   message for detail.\n"
"3. Custom Error Types should become \"transparent\", with a C representation."
msgstr ""
"1. フラットな Enum は整数に変換してコードとして返す必要があります。\n"
"2. 構造化された Enum は、詳細の文字列のエラーメッセージとともに整数コードに変"
"換されるべきです。\n"
"3. カスタムエラー型は、C言語表現に \"透過的 \" にするべきです。"

#: src/idioms/ffi/errors.md:17 src/idioms/ffi/accepting-strings.md:29
#: src/idioms/ffi/passing-strings.md:26 src/patterns/ffi/export.md:40
#: src/patterns/ffi/wrappers.md:23
msgid "## Code Example"
msgstr "## コード例"

#: src/idioms/ffi/errors.md:19
msgid "### Flat Enums"
msgstr "### フラットな Enum"

#: src/idioms/ffi/errors.md:21
msgid ""
"```rust,ignore\n"
"enum DatabaseError {\n"
"    IsReadOnly = 1, // user attempted a write operation\n"
"    IOError = 2, // user should read the C errno() for what it was\n"
"    FileCorrupted = 3, // user should run a repair tool to recover it\n"
"}\n"
"\n"
"impl From<DatabaseError> for libc::c_int {\n"
"    fn from(e: DatabaseError) -> libc::c_int {\n"
"        (e as i8).into()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"enum DatabaseError {\n"
"    IsReadOnly = 1, // ユーザが書き込みを試行しました。\n"
"    IOError = 2, // ユーザは C の error() を読み、何があったか確認するべきで"
"す。\n"
"    FileCorrupted = 3, // ユーザは復旧するために修復ツールを実行する必要があ"
"ります。\n"
"}\n"
"\n"
"impl From<DatabaseError> for libc::c_int {\n"
"    fn from(e: DatabaseError) -> libc::c_int {\n"
"        (e as i8).into()\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:35
msgid "### Structured Enums"
msgstr "### 構造化された Enum"

#: src/idioms/ffi/errors.md:37
msgid ""
"```rust,ignore\n"
"pub mod errors {\n"
"    enum DatabaseError {\n"
"        IsReadOnly,\n"
"        IOError(std::io::Error),\n"
"        FileCorrupted(String), // message describing the issue\n"
"    }\n"
"\n"
"    impl From<DatabaseError> for libc::c_int {\n"
"        fn from(e: DatabaseError) -> libc::c_int {\n"
"            match e {\n"
"                DatabaseError::IsReadOnly => 1,\n"
"                DatabaseError::IOError(_) => 2,\n"
"                DatabaseError::FileCorrupted(_) => 3,\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub mod c_api {\n"
"    use super::errors::DatabaseError;\n"
"\n"
"    #[no_mangle]\n"
"    pub extern \"C\" fn db_error_description(\n"
"        e: *const DatabaseError\n"
"        ) -> *mut libc::c_char {\n"
"\n"
"        let error: &DatabaseError = unsafe {\n"
"            // SAFETY: pointer lifetime is greater than the current stack "
"frame\n"
"            &*e\n"
"        };\n"
"\n"
"        let error_str: String = match error {\n"
"            DatabaseError::IsReadOnly => {\n"
"                format!(\"cannot write to read-only database\");\n"
"            }\n"
"            DatabaseError::IOError(e) => {\n"
"                format!(\"I/O Error: {}\", e);\n"
"            }\n"
"            DatabaseError::FileCorrupted(s) => {\n"
"                format!(\"File corrupted, run repair: {}\", &s);\n"
"            }\n"
"        };\n"
"\n"
"        let c_error = unsafe {\n"
"            // SAFETY: copying error_str to an allocated buffer with a NUL\n"
"            // character at the end\n"
"            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as "
"*mut _;\n"
"\n"
"            if malloc.is_null() {\n"
"                return std::ptr::null_mut();\n"
"            }\n"
"\n"
"            let src = error_str.as_bytes().as_ptr();\n"
"\n"
"            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
"\n"
"            std::ptr::write(malloc.add(error_str.len()), 0);\n"
"\n"
"            malloc as *mut libc::c_char\n"
"        };\n"
"\n"
"        c_error\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod errors {\n"
"    enum DatabaseError {\n"
"        IsReadOnly,\n"
"        IOError(std::io::Error),\n"
"        FileCorrupted(String), // 問題を説明するメッセージ\n"
"    }\n"
"\n"
"    impl From<DatabaseError> for libc::c_int {\n"
"        fn from(e: DatabaseError) -> libc::c_int {\n"
"            match e {\n"
"                DatabaseError::IsReadOnly => 1,\n"
"                DatabaseError::IOError(_) => 2,\n"
"                DatabaseError::FileCorrupted(_) => 3,\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub mod c_api {\n"
"    use super::errors::DatabaseError;\n"
"\n"
"    #[no_mangle]\n"
"    pub extern \"C\" fn db_error_description(\n"
"        e: *const DatabaseError\n"
"        ) -> *mut libc::c_char {\n"
"\n"
"        let error: &DatabaseError = unsafe {\n"
"            // SAFETY: ポインタの寿命が現在のスタックフレームより長い\n"
"            &*e\n"
"        };\n"
"\n"
"        let error_str: String = match error {\n"
"            DatabaseError::IsReadOnly => {\n"
"                format!(\"cannot write to read-only database\");\n"
"            }\n"
"            DatabaseError::IOError(e) => {\n"
"                format!(\"I/O Error: {}\", e);\n"
"            }\n"
"            DatabaseError::FileCorrupted(s) => {\n"
"                format!(\"File corrupted, run repair: {}\", &s);\n"
"            }\n"
"        };\n"
"\n"
"        let c_error = unsafe {\n"
"            // SAFETY: error_str をNUL終端されたアロケートされたバッファにコ"
"ピーします。\n"
"            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as "
"*mut _;\n"
"\n"
"            if malloc.is_null() {\n"
"                return std::ptr::null_mut();\n"
"            }\n"
"\n"
"            let src = error_str.as_bytes().as_ptr();\n"
"\n"
"            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
"\n"
"            std::ptr::write(malloc.add(error_str.len()), 0);\n"
"\n"
"            malloc as *mut libc::c_char\n"
"        };\n"
"\n"
"        c_error\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:104
msgid "### Custom Error Types"
msgstr "### カスタムエラー型"

#: src/idioms/ffi/errors.md:106
msgid ""
"```rust,ignore\n"
"struct ParseError {\n"
"    expected: char,\n"
"    line: u32,\n"
"    ch: u16\n"
"}\n"
"\n"
"impl ParseError { /* ... */ }\n"
"\n"
"/* Create a second version which is exposed as a C structure */\n"
"#[repr(C)]\n"
"pub struct parse_error {\n"
"    pub expected: libc::c_char,\n"
"    pub line: u32,\n"
"    pub ch: u16\n"
"}\n"
"\n"
"impl From<ParseError> for parse_error {\n"
"    fn from(e: ParseError) -> parse_error {\n"
"        let ParseError { expected, line, ch } = e;\n"
"        parse_error { expected, line, ch }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct ParseError {\n"
"    expected: char,\n"
"    line: u32,\n"
"    ch: u16\n"
"}\n"
"\n"
"impl ParseError { /* ... */ }\n"
"\n"
"/* Cの構造体として公開する2つ目のバージョンを作成 */\n"
"#[repr(C)]\n"
"pub struct parse_error {\n"
"    pub expected: libc::c_char,\n"
"    pub line: u32,\n"
"    pub ch: u16\n"
"}\n"
"\n"
"impl From<ParseError> for parse_error {\n"
"    fn from(e: ParseError) -> parse_error {\n"
"        let ParseError { expected, line, ch } = e;\n"
"        parse_error { expected, line, ch }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:133
msgid ""
"This ensures that the foreign language has clear access to error "
"information\n"
"while not compromising the Rust code's API at all."
msgstr ""
"これにより、RustコードのAPIをまったく損なうことなく、他言語でもエラー情報にア"
"クセスできるようになります。"

#: src/idioms/ffi/errors.md:138
msgid ""
"It's a lot of typing, and some types may not be able to be converted easily\n"
"to C."
msgstr "タイピングが多くなります。またC言語に簡単に変換できない型もあります。"

#: src/idioms/ffi/accepting-strings.md:1
#, fuzzy
msgid "# Accepting Strings"
msgstr "# 文字列の受け入れ"

#: src/idioms/ffi/accepting-strings.md:5
#, fuzzy
msgid ""
"When accepting strings via FFI through pointers, there are two principles "
"that\n"
"should be followed:"
msgstr ""
"FFI経由で文字列をポインタで受け取る場合、次の2つの原則に従う必要がありま"
"す。\n"
"があります："

#: src/idioms/ffi/accepting-strings.md:8
#, fuzzy
msgid ""
"1. Keep foreign strings \"borrowed\", rather than copying them directly.\n"
"2. Minimize the amount of complexity and `unsafe` code involved in "
"converting\n"
"   from a C-style string to native Rust strings."
msgstr ""
"1.外国の文字列を直接コピーするのではなく、「借用」しておいてください。\n"
"2.Cスタイルの文字列からRustネイティブ文字列への変換に伴う複雑さと`安全でない`"
"コードの量を最小限にします。\n"
"   を最小化します。"

#: src/idioms/ffi/accepting-strings.md:14
#, fuzzy
msgid ""
"The strings used in C have different behaviours to those used in Rust, "
"namely:"
msgstr ""
"C言語で使用される文字列は、Rustで使用される文字列とは動作が異なります："

#: src/idioms/ffi/accepting-strings.md:16
#, fuzzy
msgid ""
"- C strings are null-terminated while Rust strings store their length\n"
"- C strings can contain any arbitrary non-zero byte while Rust strings must "
"be\n"
"  UTF-8\n"
"- C strings are accessed and manipulated using `unsafe` pointer operations\n"
"  while interactions with Rust strings go through safe methods"
msgstr ""
"- C言語の文字列はヌル終端であるのに対し、Rustの文字列は長さを保存します。\n"
"- C言語の文字列は0以外の任意のバイトを含むことができますが、Rustの文字列は\n"
"  でなければなりません。\n"
"- C の文字列は `unsafe` ポインタ操作を使ってアクセスおよび操作されます。\n"
"  一方、Rust の文字列とのやり取りは安全なメソッドを使用します。"

#: src/idioms/ffi/accepting-strings.md:22
#, fuzzy
msgid ""
"The Rust standard library comes with C equivalents of Rust's `String` and "
"`&str`\n"
"called `CString` and `&CStr`, that allow us to avoid a lot of the "
"complexity\n"
"and `unsafe` code involved in converting between C strings and Rust strings."
msgstr ""
"Rustの標準ライブラリには、Rustの `String` と `&str` に相当するC言語が用意され"
"ています。\n"
"CString` と `&CStr` と呼ばれる C の `String` と `&str` に相当するものが用意さ"
"れています。\n"
"を回避することができます。"

#: src/idioms/ffi/accepting-strings.md:26
#, fuzzy
msgid ""
"The `&CStr` type also allows us to work with borrowed data, meaning passing\n"
"strings between Rust and C is a zero-cost operation."
msgstr ""
"また、`&CStr`型は、借用データを扱うことができます。\n"
"文字列の受け渡しがゼロコストで行えるということです。"

#: src/idioms/ffi/accepting-strings.md:31
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    /// Log a message at the specified level.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// It is the caller's guarantee to ensure `msg`:\n"
"    ///\n"
"    /// - is not a null pointer\n"
"    /// - points to valid, initialized data\n"
"    /// - points to memory ending in a null byte\n"
"    /// - won't be mutated for the duration of this function call\n"
"    #[no_mangle]\n"
"    pub unsafe extern \"C\" fn mylib_log(\n"
"        msg: *const libc::c_char,\n"
"        level: libc::c_int\n"
"    ) {\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        // SAFETY: The caller has already guaranteed this is okay (see the\n"
"        // `# Safety` section of the doc-comment).\n"
"        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() {\n"
"            Ok(s) => s,\n"
"            Err(e) => {\n"
"                crate::log_error(\"FFI string conversion failed\");\n"
"                return;\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"pub mod unsafe_module {\n"
"\n"
"    // その他のモジュールの内容\n"
"\n"
"    /// 指定されたレベルのメッセージをログに記録します。\n"
"    ///\n"
"    /// 安全性\n"
"    ///\n"
"    /// `msg` を保証するのは呼び出し側です：\n"
"    ///\n"
"    /// null ポインタでないこと。\n"
"    /// 有効で初期化されたデータを指していること。\n"
"    /// null バイトで終わるメモリを指すこと。\n"
"    /// - この関数呼び出しの間、変異されません。\n"
"    #[no_mangle]\n"
"    pub unsafe extern \"C\" fn mylib_log(\n"
"        msg: *const libc::c_char、\n"
"        level: libc::c_int\n"
"    ){\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        // 安全性: 呼び出し元はこれが問題ないことを既に保証しています（doc-"
"commentの\n"
"        // doc-comment の `# Safety` セクションを参照）。\n"
"        let msg_str：&str = match std::ffi::CStr::from_ptr(msg).to_str() "
"{ OK(s) => s.\n"
"            OK(s) => s、\n"
"            Err(e) => { エラー\n"
"                crate::log_error(\"FFI 文字列変換に失敗しました\")；\n"
"                を返します；\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(msg_str, level)；\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/accepting-strings.md:70
#, fuzzy
msgid "The example is is written to ensure that:"
msgstr "この例は、以下のことを保証するために書かれています："

#: src/idioms/ffi/accepting-strings.md:72
#, fuzzy
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The pointer with an \"untracked\" lifetime becomes a \"tracked\" shared\n"
"   reference"
msgstr ""
"1.unsafe`ブロックはできるだけ小さくします。\n"
"2.追跡されない」寿命のポインタは「追跡される」共有参照になります。\n"
"   参照"

#: src/idioms/ffi/accepting-strings.md:76
#, fuzzy
msgid "Consider an alternative, where the string is actually copied:"
msgstr "文字列を実際にコピーする別の方法を考えてみましょう："

#: src/idioms/ffi/accepting-strings.md:78
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
"c_int) {\n"
"        // DO NOT USE THIS CODE.\n"
"        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.\n"
"\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */\n"
"            libc::strlen(msg)\n"
"        };\n"
"\n"
"        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
"\n"
"        let msg_cstr: std::ffi::CString = unsafe {\n"
"            // SAFETY: copying from a foreign pointer expected to live\n"
"            // for the entire stack frame into owned memory\n"
"            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);\n"
"\n"
"            msg_data.set_len(msg_len + 1);\n"
"\n"
"            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
"        }\n"
"\n"
"        let msg_str: String = unsafe {\n"
"            match msg_cstr.into_string() {\n"
"                Ok(s) => s,\n"
"                Err(e) => {\n"
"                    crate::log_error(\"FFI string conversion failed\");\n"
"                    return;\n"
"                }\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(&msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"pub mod unsafe_module {\n"
"\n"
"    // その他のモジュールの内容\n"
"\n"
"    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
"c_int) { // このコードは使用しないでください。\n"
"        // このコードは使用しないでください。\n"
"        // このコードは醜く、冗長で、微妙なバグを含んでいます。\n"
"\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        let msg_len = unsafe { /* SAFETY: strlenって何だろう？ */\n"
"            libc::strlen(msg)\n"
"        };\n"
"\n"
"        mut msg_data = Vec::with_capacity(msg_len + 1)；\n"
"\n"
"        let msg_cstr: std::ffi::CString = unsafe { // 安全：生きていると期待"
"される外部ポインタからのコピー\n"
"            安全：スタック・フレーム全体が生きていると期待される外部ポインタ"
"から、 // 所有ポインタへのコピー。\n"
"            // スタックフレーム全体から所有メモリへのコピー\n"
"            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), "
"msg_len)；\n"
"\n"
"            msg_data.set_len(msg_len + 1)；\n"
"\n"
"            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
"        }\n"
"\n"
"        msg_str：文字列\n"
"            msg_cstr.into_string() { にマッチします。\n"
"                Ok(s) => s、\n"
"                エラー(e) => {\n"
"                    crate::log_error(\"FFI 文字列変換に失敗しました\")；\n"
"                    を返します；\n"
"                }\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(&msg_str, level)；\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/accepting-strings.md:120
#, fuzzy
msgid "This code in inferior to the original in two respects:"
msgstr "このコードは2つの点でオリジナルより劣っています："

#: src/idioms/ffi/accepting-strings.md:122
#, fuzzy
msgid ""
"1. There is much more `unsafe` code, and more importantly, more invariants "
"it\n"
"   must uphold.\n"
"2. Due to the extensive arithmetic required, there is a bug in this version\n"
"   that cases Rust `undefined behaviour`."
msgstr ""
"1.より多くの「安全でない」コードがあり、より重要なことは、そのコードが守らな"
"ければならない不変性がより多いということです。\n"
"   を守らなければなりません。\n"
"2.大規模な演算が必要なため、このバージョンにはバグがあります。\n"
"   があります。"

#: src/idioms/ffi/accepting-strings.md:127
#, fuzzy
msgid ""
"The bug here is a simple mistake in pointer arithmetic: the string was "
"copied,\n"
"all `msg_len` bytes of it. However, the `NUL` terminator at the end was not."
msgstr ""
"このバグはポインタ演算の単純なミスです、\n"
"msg_len`バイトすべてがコピーされました。しかし、末尾の `NUL` はコピーされませ"
"んでした。"

#: src/idioms/ffi/accepting-strings.md:130
#, fuzzy
msgid ""
"The Vector then had its size _set_ to the length of the _zero padded string_ "
"--\n"
"rather than _resized_ to it, which could have added a zero at the end.\n"
"As a result, the last byte in the Vector is uninitialized memory.\n"
"When the `CString` is created at the bottom of the block, its read of the\n"
"Vector will cause `undefined behaviour`!"
msgstr ""
"ベクターのサイズは、ゼロパディングされた文字列の長さに設定されます。\n"
"その結果、Vectorの最後のバイトは初期化されていないメモリになります。\n"
"その結果、Vectorの最後のバイトは初期化されていないメモリになります。\n"
"ブロックの一番下に `CString` が作成されると、その読み込みによって\n"
"Vectorの読み込みは`未定義の動作`を引き起こします！"

#: src/idioms/ffi/accepting-strings.md:136
#, fuzzy
msgid ""
"Like many such issues, this would be difficult issue to track down.\n"
"Sometimes it would panic because the string was not `UTF-8`, sometimes it "
"would\n"
"put a weird character at the end of the string, sometimes it would just\n"
"completely crash."
msgstr ""
"このような問題の多くがそうであるように、この問題を追跡するのは困難です。\n"
"文字列が`UTF-8`でなかったためにパニックになることもあれば、文字列の最後に変な"
"文字を置くこともあります。\n"
"文字列の最後に変な文字を置いたり、時には完全にクラッシュしたり。\n"
"完全にクラッシュすることもあります。"

#: src/idioms/ffi/accepting-strings.md:143
#: src/idioms/ffi/passing-strings.md:105
#, fuzzy
msgid "None?"
msgstr "いない？"

#: src/idioms/ffi/passing-strings.md:1
#, fuzzy
msgid "# Passing Strings"
msgstr "# 文字列の受け渡し"

#: src/idioms/ffi/passing-strings.md:5
#, fuzzy
msgid ""
"When passing strings to FFI functions, there are four principles that should "
"be\n"
"followed:"
msgstr ""
"FFI関数に文字列を渡す場合、次の4つの原則に従う必要があります。\n"
"があります："

#: src/idioms/ffi/passing-strings.md:8
#, fuzzy
msgid ""
"1. Make the lifetime of owned strings as long as possible.\n"
"2. Minimize `unsafe` code during the conversion.\n"
"3. If the C code can modify the string data, use `Vec` instead of "
"`CString`.\n"
"4. Unless the Foreign Function API requires it, the ownership of the string\n"
"   should not transfer to the callee."
msgstr ""
"1.所有する弦の寿命をできるだけ長くしてください。\n"
"2.変換中の `unsafe` コードを最小限にします。\n"
"3.C のコードが文字列データを変更できる場合は、 `CString` の代わりに `Vec` を"
"使用してください。\n"
"4.外部関数APIがそれを要求しない限り、文字列の所有権\n"
"   の所有権を着呼側に移さないようにします。"

#: src/idioms/ffi/passing-strings.md:16
#, fuzzy
msgid ""
"Rust has built-in support for C-style strings with its `CString` and `CStr`\n"
"types. However, there are different approaches one can take with strings "
"that\n"
"are being sent to a foreign function call from a Rust function."
msgstr ""
"Rust は `CString` 型と `CStr` 型で C スタイルの文字列をビルトインでサポートし"
"ています。\n"
"型があります。しかし、Rust 関数から外部関数呼び出しに送信される文字列には、さ"
"まざまなアプローチがあります。\n"
"の文字列は、Rust 関数から外部関数呼び出しに送信されます。"

#: src/idioms/ffi/passing-strings.md:20
#, fuzzy
msgid ""
"The best practice is simple: use `CString` in such a way as to minimize\n"
"`unsafe` code. However, a secondary caveat is that\n"
"_the object must live long enough_, meaning the lifetime should be "
"maximized.\n"
"In addition, the documentation explains that \"round-tripping\" a `CString` "
"after\n"
"modification is UB, so additional work is necessary in that case."
msgstr ""
"ベストプラクティスは単純です。\n"
"安全でないコードを最小限にするように `CString` を使うことです。ただし、二次的"
"な注意点として\n"
"オブジェクトは十分に長く生きなければなりません。\n"
"加えて、ドキュメントでは `CString` を変更した後に \"ラウンドトリップ\" するこ"
"とは UB であると説明しています。\n"
"を \"ラウンドトリップ \"することはUBであると説明されています。"

#: src/idioms/ffi/passing-strings.md:28
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    extern \"C\" {\n"
"        fn seterr(message: *const libc::c_char);\n"
"        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> libc::"
"c_int;\n"
"    }\n"
"\n"
"    fn report_error_to_ffi<S: Into<String>>(\n"
"        err: S\n"
"    ) -> Result<(), std::ffi::NulError>{\n"
"        let c_err = std::ffi::CString::new(err.into())?;\n"
"\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation says the pointer "
"is\n"
"            // const, so no modification should occur\n"
"            seterr(c_err.as_ptr());\n"
"        }\n"
"\n"
"        Ok(())\n"
"        // The lifetime of c_err continues until here\n"
"    }\n"
"\n"
"    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> {\n"
"        let mut buffer = vec![0u8; 1024];\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation implies\n"
"            // that the input need only live as long as the call\n"
"            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();\n"
"\n"
"            buffer.truncate(written + 1);\n"
"        }\n"
"\n"
"        std::ffi::CString::new(buffer).unwrap().into_string()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"pub mod unsafe_module {\n"
"\n"
"    // その他のモジュールの内容\n"
"\n"
"    extern \"C\" {\n"
"        fn seterr(message: *const libc::c_char)；\n"
"        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -&gt; libc::"
"c_int；\n"
"    }\n"
"\n"
"    fn report_error_to_ffi&lt;S: Into<String>&gt;(\n"
"        err：S\n"
"    ) -&gt; 結果<(), std::ffi::NulError>{\n"
"        let c_err = std::ffi::CString::new(err.into())?\n"
"\n"
"        unsafe {\n"
"            安全: ポインタが const であるとドキュメントに記述されている FFI "
"を呼び出す // ので、変更は発生しません。\n"
"            // ポインタは const なので、変更すべきではありません。\n"
"            seterr(c_err.as_ptr())；\n"
"        }\n"
"\n"
"        Ok(())\n"
"        // c_errの寿命はここまで続きます。\n"
"    }\n"
"\n"
"    fn get_error_from_ffi() -&gt; 結果<String, std::ffi::IntoStringError> "
"{.\n"
"        let mut buffer = vec![0u8; 1024]；\n"
"        unsafe {\n"
"            // 安全性: ドキュメントに次のように記述されているFFIを呼び出すこ"
"と。\n"
"            // を呼び出します。\n"
"            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into()；\n"
"\n"
"            buffer.truncate(written + 1)；\n"
"        }\n"
"\n"
"        std::ffi::CString::new(buffer).unwrap().into_string()\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/passing-strings.md:70
#, fuzzy
msgid "The example is written in a way to ensure that:"
msgstr "この例は、確実にそうなるように書かれています："

#: src/idioms/ffi/passing-strings.md:72
#, fuzzy
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The `CString` lives long enough.\n"
"3. Errors with typecasts are always propagated when possible."
msgstr ""
"1.unsafe`ブロックはできるだけ小さくします。\n"
"2.CString` は十分長生きします。\n"
"3.型キャストによるエラーは可能な限り常に伝播されます。"

#: src/idioms/ffi/passing-strings.md:76
#, fuzzy
msgid ""
"A common mistake (so common it's in the documentation) is to not use the\n"
"variable in the first block:"
msgstr ""
"よくある間違い（ドキュメントにも載っているほど）は、最初のブロックで\n"
"変数を使わないことです："

#: src/idioms/ffi/passing-strings.md:79
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    fn report_error<S: Into<String>>(err: S) -> Result<(), std::ffi::"
"NulError> {\n"
"        unsafe {\n"
"            // SAFETY: whoops, this contains a dangling pointer!\n"
"            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"pub mod unsafe_module {\n"
"\n"
"    // その他のモジュールの内容\n"
"\n"
"    fn report_error&lt;S: Into<String>&gt;(err: S) -&gt; 結果<(), std::ffi::"
"NulError> {。\n"
"        unsafe {\n"
"            // セーフ: おっと、これにはダングリングポインタが含まれていま"
"す！\n"
"            seterr(std::ffi::CString::new(err.into())?.as_ptr())；\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/passing-strings.md:94
#, fuzzy
msgid ""
"This code will result in a dangling pointer, because the lifetime of the\n"
"`CString` is not extended by the pointer creation, unlike if a reference "
"were\n"
"created."
msgstr ""
"このコードではポインタがぶら下がった状態になります。\n"
"ポインタの作成によって `CString` の寿命が延長されることはないからです。\n"
"とは異なり、ポインタの生成によって `CString` の寿命が延長されることはありませ"
"ん。"

#: src/idioms/ffi/passing-strings.md:98
#, fuzzy
msgid ""
"Another issue frequently raised is that the initialization of a 1k vector "
"of\n"
"zeroes is \"slow\". However, recent versions of Rust actually optimize that\n"
"particular macro to a call to `zmalloc`, meaning it is as fast as the "
"operating\n"
"system's ability to return zeroed memory (which is quite fast)."
msgstr ""
"もうひとつよく指摘される問題は、1k個のゼロのベクトルの初期化が「遅い」という"
"ことです。\n"
"の初期化が「遅い」ことです。しかし、Rustの最近のバージョンでは、この特定のマ"
"クロは実際に最適化されています。\n"
"zmalloc`の呼び出しに最適化されています。\n"
"つまり、オペレーティングシステムのゼロになったメモリを返す機能（これはかなり"
"高速です）と同じ速さです。"

#: src/idioms/option-iter.md:1
#, fuzzy
msgid "# Iterating over an `Option`"
msgstr "# オプションの反復処理"

#: src/idioms/option-iter.md:5
#, fuzzy
msgid ""
"`Option` can be viewed as a container that contains either zero or one\n"
"element. In particular, it implements the `IntoIterator` trait, and as such\n"
"can be used with generic code that needs such a type."
msgstr ""
"Option`は、0個または1個の要素を含むコンテナとみなすことができます。\n"
"要素を含むコンテナとみなすことができます。特に、 `IntoIterator` 特性を実装し"
"ているので、このような型を必要とする汎用的なコードで使用することができま"
"す。\n"
"を実装しているので、このような型を必要とする一般的なコードで使用することがで"
"きます。"

#: src/idioms/option-iter.md:9 src/patterns/structural/small-crates.md:34
#: src/patterns/structural/unsafe-mods.md:22
#, fuzzy
msgid "## Examples"
msgstr "## 例"

#: src/idioms/option-iter.md:11
#, fuzzy
msgid ""
"Since `Option` implements `IntoIterator`, it can be used as an argument to\n"
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod."
"extend):"
msgstr ""
"Option` は `IntoIterator` を実装しているので、次の引数として使用できます。\n"
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod."
"extend)の引数として使用できます："

#: src/idioms/option-iter.md:14
#, fuzzy
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"logicians.extend(turing);\n"
"\n"
"// equivalent to\n"
"if let Some(turing_inner) = turing {\n"
"    logicians.push(turing_inner);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"let turing = Some(\"Turing\")；\n"
"let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"]；\n"
"\n"
"logicians.extend(turing)；\n"
"\n"
"// 以下と等価\n"
"もし let Some(turing_inner) = turing { とすれば\n"
"    logicians.push(turing_inner)；\n"
"}\n"
"```"

#: src/idioms/option-iter.md:26
#, fuzzy
msgid ""
"If you need to tack an `Option` to the end of an existing iterator, you can\n"
"pass it to [`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.chain):"
msgstr ""
"既存のイテレータの末尾に `Option` を追加する必要がある場合は、[`.chain() `]"
"() にそれを渡すことができます。\n"
"それを [`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.chain) に渡すことができます："

#: src/idioms/option-iter.md:29
#, fuzzy
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"for logician in logicians.iter().chain(turing.iter()) {\n"
"    println!(\"{} is a logician\", logician);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"let turing = Some(\"Turing\")；\n"
"let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"]；\n"
"\n"
"for logician in logicians.iter().chain(turing.iter()) { 論理学者(logicians."
"iter())\n"
"    println!(\"{} is a logician\", logician)；\n"
"}\n"
"```"

#: src/idioms/option-iter.md:38
#, fuzzy
msgid ""
"Note that if the `Option` is always `Some`, then it is more idiomatic to "
"use\n"
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) on the\n"
"element instead."
msgstr ""
"もし `Option` が常に `Some` である場合は、よりイディオム的に\n"
"要素の代わりに [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn."
"once.html) を使用する方がよりイディオム的です。\n"
"要素の代わりに"

#: src/idioms/option-iter.md:42
#, fuzzy
msgid ""
"Also, since `Option` implements `IntoIterator`, it's possible to iterate "
"over\n"
"it using a `for` loop. This is equivalent to matching it with `if let "
"Some(..)`,\n"
"and in most cases you should prefer the latter."
msgstr ""
"また、`Option` は `IntoIterator` を実装しているので、`for` ループを使って繰り"
"返し処理を行うことができます。\n"
"ループを使うことができます。これは `if let Some(...)` とマッチさせるのと同じ"
"です、\n"
"ほとんどの場合、後者の方がよいでしょう。"

#: src/idioms/option-iter.md:48
#, fuzzy
msgid ""
"- [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) is "
"an\n"
"  iterator which yields exactly one element. It's a more readable "
"alternative to\n"
"  `Some(foo).into_iter()`.\n"
"\n"
"- [`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.filter_map)\n"
"  is a version of [`Iterator::map`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html#method.map),\n"
"  specialized to mapping functions which return `Option`.\n"
"\n"
"- The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"  for converting an `Option` to a zero- or one-element slice.\n"
"\n"
"- [Documentation for `Option<T>`](https://doc.rust-lang.org/std/option/enum."
"Option.html)"
msgstr ""
"- [std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html)はちょう"
"ど1つの要素を返すイテレータです。\n"
"  イテレータです。これは\n"
"  Some(foo).into_iter()`の代わりです。\n"
"\n"
"- [イテレータ::フィルタマップ`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html#method.filter_map)\n"
"  は [`Iterator::map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.map) のバージョンです、\n"
"  オプション`を返す関数に特化したものです。\n"
"\n"
"- ref_slice`](https://crates.io/crates/ref_slice) は `Option` を変換する関数"
"を提供します。\n"
"  は、 `Option` を 0 要素または 1 要素のスライスに変換する関数を提供しま"
"す。\n"
"\n"
"- [Option<T>` のドキュメント](https://doc.rust-lang.org/std/option/enum."
"Option.html)"

#: src/idioms/pass-var-to-closure.md:1
#, fuzzy
msgid "# Pass variables to closure"
msgstr "# 変数をクロージャに渡す"

#: src/idioms/pass-var-to-closure.md:5
#, fuzzy
msgid ""
"By default, closures capture their environment by borrowing. Or you can use\n"
"`move`-closure to move whole environment. However, often you want to move "
"just\n"
"some variables to closure, give it copy of some data, pass it by reference, "
"or\n"
"perform some other transformation."
msgstr ""
"デフォルトでは、クロージャは借用によって環境を取り込みます。あるいは\n"
"を使うこともできます。しかし\n"
"クロージャにいくつかの変数のみを移動させたり、あるデータのコピーを与えたり、"
"参照渡しをしたり、その他の変換を行いたいことがよくあります。\n"
"その他の変換を行いたいこともあります。"

#: src/idioms/pass-var-to-closure.md:10
#, fuzzy
msgid "Use variable rebinding in separate scope for that."
msgstr "その場合は、別のスコープで変数の再バインディングを使用します。"

#: src/idioms/pass-var-to-closure.md:14
#, fuzzy
msgid "Use"
msgstr "使用"

#: src/idioms/pass-var-to-closure.md:16
#, fuzzy
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"let closure = {\n"
"    // `num1` is moved\n"
"    let num2 = num2.clone();  // `num2` is cloned\n"
"    let num3 = num3.as_ref();  // `num3` is borrowed\n"
"    move || {\n"
"        *num1 + *num2 + *num3;\n"
"    }\n"
"};\n"
"```"
msgstr ""
"ラスト\n"
"std::rc::Rc；\n"
"\n"
"let num1 = Rc::new(1)；\n"
"let num2 = Rc::new(2)；\n"
"let num3 = Rc::new(3)；\n"
"let closure = {\n"
"    // `num1` を移動\n"
"    let num2 = num2.clone(); // `num2` はクローン化されます。\n"
"    let num3 = num3.as_ref(); // `num3` が借用されます。\n"
"    move || {\n"
"        *num1 + *num2 + *num3；\n"
"    \n"
"};\n"
"```"

#: src/idioms/pass-var-to-closure.md:32
#, fuzzy
msgid "instead of"
msgstr "ではなく"

#: src/idioms/pass-var-to-closure.md:34
#, fuzzy
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"\n"
"let num2_cloned = num2.clone();\n"
"let num3_borrowed = num3.as_ref();\n"
"let closure = move || {\n"
"    *num1 + *num2_cloned + *num3_borrowed;\n"
"};\n"
"```"
msgstr ""
"ラスト\n"
"std::rc::Rc；\n"
"\n"
"let num1 = Rc::new(1)；\n"
"let num2 = Rc::new(2)；\n"
"let num3 = Rc::new(3)；\n"
"\n"
"let num2_cloned = num2.clone()；\n"
"let num3_borrowed = num3.as_ref()；\n"
"let closure = move || { (クロージャ)\n"
"    *num1 + *num2_cloned + *num3_borrowed；\n"
"};\n"
"```"

#: src/idioms/pass-var-to-closure.md:50
#, fuzzy
msgid ""
"Copied data are grouped together with closure definition, so their purpose "
"is\n"
"more clear, and they will be dropped immediately even if they are not "
"consumed\n"
"by closure."
msgstr ""
"コピーされたデータは、クロージャの定義と一緒にグループ化されるため、目的がよ"
"り明確になります。\n"
"クロージャによって消費されなくても、すぐに削除されます。\n"
"クロージャによって消費されなくても直ちに削除されます。"

#: src/idioms/pass-var-to-closure.md:54
#, fuzzy
msgid ""
"Closure uses same variable names as surrounding code whether data are copied "
"or\n"
"moved."
msgstr ""
"クロージャは、データがコピーされようが移動されようが、周囲のコードと同じ変数"
"名を使用します。\n"
"を使用します。"

#: src/idioms/pass-var-to-closure.md:59
#, fuzzy
msgid "Additional indentation of closure body."
msgstr "クロージャー本体の追加くぼみ。"

#: src/idioms/priv-extend.md:1
#, fuzzy
msgid "# `#[non_exhaustive]` and private fields for extensibility"
msgstr "# 拡張性のための `#[non_exhaustive]` とプライベートフィールド"

#: src/idioms/priv-extend.md:5
#, fuzzy
msgid ""
"A small set of scenarios exist where a library author may want to add "
"public\n"
"fields to a public struct or new variants to an enum without breaking "
"backwards\n"
"compatibility."
msgstr ""
"ライブラリの作者が、public構造体にpublicフィールドを追加したり、enumに新しい"
"変種を追加したりする場合、後方互換性を壊すことなく行えるシナリオがいくつか存"
"在します。\n"
"を追加したい場合があります。\n"
"があります。"

#: src/idioms/priv-extend.md:9
#, fuzzy
msgid "Rust offers two solutions to this problem:"
msgstr "Rustはこの問題に対して2つの解決策を提供します："

#: src/idioms/priv-extend.md:11
#, fuzzy
msgid ""
"- Use `#[non_exhaustive]` on `struct`s, `enum`s, and `enum` variants.\n"
"  For extensive documentation on all the places where `#[non_exhaustive]` "
"can be\n"
"  used, see [the docs](https://doc.rust-lang.org/reference/attributes/"
"type_system.html#the-non_exhaustive-attribute).\n"
"\n"
"- You may add a private field to a struct to prevent it from being directly\n"
"  instantiated or matched against (see Alternative)"
msgstr ""
"- non_exhaustive]` は `struct`s, `enum`s, `enum` variant で使用してくださ"
"い。\n"
"  non_exhaustive]`が使用できるすべての場所についての詳細なドキュメントは"
"[docs]()を参照してください。\n"
"  が使用できるすべての場所に関する詳細なドキュメントは [the docs](https://"
"doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-"
"attribute) を参照してください。\n"
"\n"
"- 構造体が直接インスタンス化されたり、マッチングされたりしないようにするため"
"に、構造体にプライベートフィールドを追加することができます。\n"
"  インスタンス化されたり、マッチングされたりするのを防ぐために、 構造体にプラ"
"イベートフィールドを追加することができます。"

#: src/idioms/priv-extend.md:20
#, fuzzy
msgid ""
"```rust\n"
"mod a {\n"
"    // Public struct.\n"
"    #[non_exhaustive]\n"
"    pub struct S {\n"
"        pub foo: i32,\n"
"    }\n"
"    \n"
"    #[non_exhaustive]\n"
"    pub enum AdmitMoreVariants {\n"
"        VariantA,\n"
"        VariantB,\n"
"        #[non_exhaustive]\n"
"        VariantC { a: String }\n"
"    }\n"
"}\n"
"\n"
"fn print_matched_variants(s: a::S) {\n"
"    // Because S is `#[non_exhaustive]`, it cannot be named here and\n"
"    // we must use `..` in the pattern.\n"
"    let a::S { foo: _, ..} = s;\n"
"    \n"
"    let some_enum = a::AdmitMoreVariants::VariantA;\n"
"    match some_enum {\n"
"        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
"        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
"\n"
"        // .. required because this variant is non-exhaustive as well\n"
"        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a c\"),\n"
"\n"
"        // The wildcard match is required because more variants may be\n"
"        // added in the future\n"
"        _ => println!(\"it's a new variant\")\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆\n"
"mod a {\n"
"    // 公開構造体。\n"
"    #[non_exhaustive]\n"
"    pub struct S {\n"
"        pub foo: i32、\n"
"    }\n"
"    \n"
"    非網羅的] #[非網羅的\n"
"    pub enum AdmitMoreVariants { { 変数Aを許可します。\n"
"        VariantA、\n"
"        VariantB、\n"
"        #[non_exhaustive]\n"
"        VariantC { a：文字列 }.\n"
"    }\n"
"}\n"
"\n"
"fn print_matched_variants(s: a::S) { // S は `#[非_網羅的]` であるため、ここ"
"で名前を付けることはできません。\n"
"    // S は `#[non_exhaustive]` なので、ここで名前を付けることはできませ"
"ん。\n"
"    // パターンに `..` を使う必要があります。\n"
"    let a::S { foo：_, ..} = s;\n"
"    \n"
"    let some_enum = a::AdmitMoreVariants::VariantA；\n"
"    とマッチします。\n"
"        a::AdmitMoreVariants::VariantA => println!(\"it's an A\")、\n"
"        a::AdmitMoreVariants::VariantB => println!(\"it's a b\")、\n"
"\n"
"        // ... このバリアントも非網羅的なので必須\n"
"        a::AdmitMoreVariants::VariantC { a, ...}=> println!(\"it's a c\")、\n"
"\n"
"        // ワイルドカードのマッチは必要です。\n"
"        // 将来的に追加される可能性があるためです。\n"
"        _ => println!(\"it's a new variant\").\n"
"    }\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:57
#, fuzzy
msgid "## Alternative: `Private fields` for structs"
msgstr ""
"代替: 構造体のための `プライベートフィールド` ## Alternative: `Private "
"fields` for structs"

#: src/idioms/priv-extend.md:59
#, fuzzy
msgid ""
"`#[non_exhaustive]` only works across crate boundaries.\n"
"Within a crate, the private field method may be used."
msgstr ""
"non_exhaustive]` はクレートの境界を越えてのみ機能します。\n"
"クレート内では、プライベートフィールドメソッドを使用できます。"

#: src/idioms/priv-extend.md:62
#, fuzzy
msgid ""
"Adding a field to a struct is a mostly backwards compatible change.\n"
"However, if a client uses a pattern to deconstruct a struct instance, they\n"
"might name all the fields in the struct and adding a new one would break "
"that\n"
"pattern.\n"
"The client could name some fields and use `..` in the pattern, in which case "
"adding\n"
"another field is backwards compatible.\n"
"Making at least one of the struct's fields private forces clients to use the "
"latter\n"
"form of patterns, ensuring that the struct is future-proof."
msgstr ""
"構造体にフィールドを追加することは、ほぼ後方互換性のある変更です。\n"
"ただし、クライアントがパターンを使用して構造体インスタンスを分解する場合、構"
"造体内のすべてのフィールドに名前を付ける可能性があります。\n"
"構造体のすべてのフィールドに名前を付ける可能性があり、新しいフィールドを追加"
"するとそのパターンが壊れます。\n"
"パターンを壊すことになります。\n"
"クライアントはいくつかのフィールドに名前を付け、パターンに `..` を使用するこ"
"とができます。\n"
"を使用することができます。\n"
"構造体のフィールドの少なくとも1つをプライベートにすると、クライアントは後者の"
"形式のパターンを使用するようになります。\n"
"パターンを使用するようにクライアントに強制し、構造体の将来性を確保します。"

#: src/idioms/priv-extend.md:71
#, fuzzy
msgid ""
"The downside of this approach is that you might need to add an otherwise "
"unneeded\n"
"field to the struct.\n"
"You can use the `()` type so that there is no runtime overhead and prepend "
"`_` to\n"
"the field name to avoid the unused field warning."
msgstr ""
"この方法の欠点は、構造体に不要なフィールドを追加する必要があるかもしれないこ"
"とです。\n"
"フィールドを追加する必要があることです。\n"
"型を使って実行時のオーバーヘッドをなくし、フィールド名の前に `_` を付けること"
"で未使用フィールドの警告を回避することができます。\n"
"をフィールド名の前に付けることで未使用フィールドの警告を回避することができま"
"す。"

#: src/idioms/priv-extend.md:76
#, fuzzy
msgid ""
"```rust\n"
"pub struct S {\n"
"    pub a: i32,\n"
"    // Because `b` is private, you cannot match on `S` without using `..` "
"and `S`\n"
"    //  cannot be directly instantiated or matched against\n"
"    _b: ()\n"
"}\n"
"```"
msgstr ""
"錆\n"
"pub struct S {\n"
"    pub a: i32、\n"
"    // b` はプライベートなので、`..` を使用せずに `S` にマッチさせることはで"
"きません。\n"
"    // に対して直接インスタンス化やマッチングを行うことはできません。\n"
"    _b: ()\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:87
#, fuzzy
msgid ""
"On `struct`s, `#[non_exhaustive]` allows adding additional fields in a "
"backwards\n"
"compatible way.\n"
"It will also prevent clients from using the struct constructor, even if all "
"the\n"
"fields are public.\n"
"This may be helpful, but it's worth considering if you _want_ an additional "
"field\n"
"to be found by clients as a compiler error rather than something that may be "
"silently\n"
"undiscovered."
msgstr ""
"struct`sでは、`#[non_exhaustive]`によって後方互換性のある方法でフィールドを追"
"加することができます。\n"
"フィールドを追加することができます。\n"
"また、すべてのフィールドがpublicであっても、クライアントは構造体のコンストラ"
"クタを使用できなくなります。\n"
"フィールドがすべてパブリックであっても、クライアントは構造体のコンストラクタ"
"を使用できなくなります。\n"
"これは便利かもしれませんが、追加フィールドをクライアントがコンパイル時に\n"
"追加フィールドを、黙って発見されるのではなく、コンパイラー・エラーとしてクラ"
"イアントに発見させたい場合は、検討する価値があります。\n"
"としてクライアントから検出されるようにしたい場合は、検討する価値があります。"

#: src/idioms/priv-extend.md:95
#, fuzzy
msgid ""
"`#[non_exhaustive]` can be applied to enum variants as well.\n"
"A `#[non_exhaustive]` variant behaves in the same way as a "
"`#[non_exhaustive]` struct."
msgstr ""
"non_exhaustive]` は列挙型のバリアントにも適用できます。\n"
"非網羅的]`バリアントは `#[非網羅的]`構造体と同じように振る舞います。"

#: src/idioms/priv-extend.md:98
#, fuzzy
msgid ""
"Use this deliberately and with caution: incrementing the major version when "
"adding\n"
"fields or variants is often a better option.\n"
"`#[non_exhaustive]` may be appropriate in scenarios where you're modeling an "
"external\n"
"resource that may change out-of-sync with your library, but is not a general "
"purpose\n"
"tool."
msgstr ""
"フィールドやバリアントを追加するときは、 メジャーバージョンをインクリメントし"
"た方が良いことが多いのです。\n"
"フィールドやバリアントを追加するときは、メジャーバージョンをインクリメントす"
"る方が良い場合があります。\n"
"non_exhaustive]`は、外部リソースをモデル化する場合に適切かもしれません。\n"
"をモデル化しているような場面では適切かもしれません。\n"
"ツールではありません。"

#: src/idioms/priv-extend.md:104
#, fuzzy
msgid "### Disadvantages"
msgstr "### デメリット"

#: src/idioms/priv-extend.md:106
#, fuzzy
msgid ""
"`#[non_exhaustive]` can make your code much less ergonomic to use, "
"especially when\n"
"forced to handle unknown enum variants.\n"
"It should only be used when these sorts of evolutions are required "
"**without**\n"
"incrementing the major version."
msgstr ""
"non_exhaustive]`はコードを人間工学的に使いにくくします。\n"
"特に未知の列挙型の変種を扱わなければならない場合。\n"
"このような種類の進化が必要な場合にのみ使うべきです。\n"
"メジャーバージョンをインクリメントすることなく"

#: src/idioms/priv-extend.md:111
#, fuzzy
msgid ""
"When `#[non_exhaustive]` is applied to `enum`s, it forces clients to handle "
"a\n"
"wildcard variant.\n"
"If there is no sensible action to take in this case, this may lead to "
"awkward\n"
"code and code paths that are only executed in extremely rare circumstances.\n"
"If a client decides to `panic!()` in this scenario, it may have been better "
"to\n"
"expose this error at compile time.\n"
"In fact, `#[non_exhaustive]` forces clients to handle the \"Something else\" "
"case;\n"
"there is rarely a sensible action to take in this scenario."
msgstr ""
"enum`に `#[non_exhaustive]` が適用されると、クライアントは強制的に\n"
"を強制します。\n"
"この場合に取るべき賢明なアクションがなければ、厄介なコードや\n"
"コードや、極めて稀な状況でのみ実行されるコードパスにつながるかもしれませ"
"ん。\n"
"クライアントがこのシナリオで `panic!\n"
"このエラーはコンパイル時に公開した方がよかったかもしれません。\n"
"実際、`#[non_exhaustive]`はクライアントに \"Something else \"のケースを処理す"
"るように強制します；\n"
"このシナリオで取るべき賢明な行動はほとんどありません。"

#: src/idioms/priv-extend.md:122
#, fuzzy
msgid ""
"- [RFC introducing #[non_exhaustive] attribute for enums and structs]"
"(https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"
msgstr ""
"- [列挙型と構造体に#[非網羅的]属性を導入するRFC](https://github.com/rust-"
"lang/rfcs/blob/master/text/2008-non-exhaustive.md)"

#: src/idioms/rustdoc-init.md:1
#, fuzzy
msgid "# Easy doc initialization"
msgstr "# 簡単なドキュメントの初期化"

#: src/idioms/rustdoc-init.md:5
#, fuzzy
msgid ""
"If a struct takes significant effort to initialize when writing docs, it can "
"be\n"
"quicker to wrap your example with a helper function which takes the struct "
"as an\n"
"argument."
msgstr ""
"ドキュメントを書くときに、構造体を初期化するのに多大な労力がかかる場合は\n"
"構造体を引数に取るヘルパー関数で例をラップした方が早い場合があります。\n"
"を引数に取るヘルパー関数で例をラップするのが手っ取り早いでしょう。"

#: src/idioms/rustdoc-init.md:11
#, fuzzy
msgid ""
"Sometimes there is a struct with multiple or complicated parameters and "
"several\n"
"methods. Each of these methods should have examples."
msgstr ""
"複数の、あるいは複雑なパラメータと複数のメソッドを持つ構造体が存在することが"
"あります。\n"
"メソッドがあります。これらのメソッドにはそれぞれ例があるはずです。"

#: src/idioms/rustdoc-init.md:14
msgid "For example:"
msgstr "例:"

#: src/idioms/rustdoc-init.md:16
#, fuzzy
msgid ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```no_run\n"
"    /// # // Boilerplate are required to get an example working.\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream };\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> {\n"
"        // ...\n"
"    }\n"
"\n"
"    /// Oh no, all that boilerplate needs to be repeated here!\n"
"    fn check_status(&self) -> Status {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"
msgstr ""
"錆、無視\n"
"struct 接続 {\n"
"    name: 文字列、\n"
"    stream：TcpStream、\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信します。\n"
"    ///\n"
"    /// # 例\n"
"    /// ``no_run\n"
"    /// # // 例を動かすにはボイラープレートが必要です。\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\")；\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), "
"stream }；\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\")；\n"
"    /// let response = connection.send_request(request)；\n"
"    /// assert!(response.is_ok())；\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> "
"{ // ...\n"
"        // ...\n"
"    }\n"
"\n"
"    /// いやはや、すべての定型文はここで繰り返す必要があります！\n"
"    fn check_status(&self) -> Status { // ...\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:47
#, fuzzy
msgid ""
"Instead of typing all of this boilerplate to create a `Connection` and\n"
"`Request`, it is easier to just create a wrapping helper function which "
"takes\n"
"them as arguments:"
msgstr ""
"このような定型文をすべて入力して `Connection` と `Request` を作成する代わり"
"に\n"
"と `Request` を作成するためにこのような定型文をすべて入力するよりも、それらを"
"引数として受け取るラッパーのヘルパー関数を作成する方が簡単です。\n"
"を作成する方が簡単です："

#: src/idioms/rustdoc-init.md:51
#, fuzzy
msgid ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// # }\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"
msgstr ""
"錆、無視\n"
"struct 接続 {\n"
"    name: 文字列、\n"
"    stream：TcpStream、\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信します。\n"
"    ///\n"
"    /// # 例\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request)；\n"
"    /// assert!(response.is_ok())；\n"
"    /// # }\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) { //...\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:73
#, fuzzy
msgid ""
"**Note** in the above example the line `assert!(response.is_ok());` will "
"not\n"
"actually run while testing because it is inside a function which is never\n"
"invoked."
msgstr ""
"**注意** 上の例では、`assert!(response.is_ok());`という行は、テスト中に実際に"
"は実行されません。\n"
"という行はテスト中に実際に実行されることはありません。\n"
"の中にあるためです。"

#: src/idioms/rustdoc-init.md:79
#, fuzzy
msgid "This is much more concise and avoids repetitive code in examples."
msgstr ""
"この方がはるかに簡潔で、例題でのコードの繰り返しを避けることができます。"

#: src/idioms/rustdoc-init.md:83
#, fuzzy
msgid ""
"As example is in a function, the code will not be tested. Though it will "
"still be\n"
"checked to make sure it compiles when running a `cargo test`. So this "
"pattern is\n"
"most useful when you need `no_run`. With this, you do not need to add "
"`no_run`."
msgstr ""
"例題は関数の中にあるので、コードはテストされません。しかし\n"
"cargoテスト`を実行したときにコンパイルされているかどうかはチェックされます。"
"ですから、このパターンは\n"
"このパターンは `no_run` が必要なときに便利です。このパターンでは `no_run` を"
"追加する必要はありません。"

#: src/idioms/rustdoc-init.md:89
#, fuzzy
msgid "If assertions are not required this pattern works well."
msgstr "アサーションが必要ない場合は、このパターンがうまく機能します。"

#: src/idioms/rustdoc-init.md:91
#, fuzzy
msgid ""
"If they are, an alternative can be to create a public method to create a "
"helper\n"
"instance which is annotated with `#[doc(hidden)]` (so that users won't see "
"it).\n"
"Then this method can be called inside of rustdoc because it is part of the\n"
"crate's public API."
msgstr ""
"もしそうであれば、別の方法として、`#[doc(hidden)]`でアノテーションされたヘル"
"パーのインスタンスを作成するパブリックメソッドを作成することができます。\n"
"インスタンスを作成するためのパブリックメソッドを作成することです。\n"
"このメソッドはrustdocの内部で呼び出すことができます。\n"
"crateのパブリックAPIの一部だからです。"

#: src/idioms/temporary-mutability.md:1
#, fuzzy
msgid "# Temporary mutability"
msgstr "# 一時的な変更可能性"

#: src/idioms/temporary-mutability.md:5
#, fuzzy
msgid ""
"Often it is necessary to prepare and process some data, but after that data "
"are\n"
"only inspected and never modified. The intention can be made explicit by "
"redefining\n"
"the mutable variable as immutable."
msgstr ""
"多くの場合、いくつかのデータを準備し、処理する必要がありますが、その後、デー"
"タは検査されるだけで、変更されることはありません。\n"
"は検査されるだけで、変更されることはありません。このような場合は\n"
"をイミュータブル変数として再定義することで、その意図を明示することができま"
"す。"

#: src/idioms/temporary-mutability.md:9
#, fuzzy
msgid ""
"It can be done either by processing data within a nested block or by "
"redefining\n"
"the variable."
msgstr ""
"これは、ネストされたブロック内でデータを処理するか、変数を再定義することで可"
"能です。\n"
"変数を再定義することです。"

#: src/idioms/temporary-mutability.md:14
#, fuzzy
msgid "Say, vector must be sorted before usage."
msgstr "つまり、ベクトルは使用する前にソートする必要があります。"

#: src/idioms/temporary-mutability.md:16
#, fuzzy
msgid "Using nested block:"
msgstr "ネストされたブロックの使用"

#: src/idioms/temporary-mutability.md:18
#, fuzzy
msgid ""
"```rust,ignore\n"
"let data = {\n"
"    let mut data = get_vec();\n"
"    data.sort();\n"
"    data\n"
"};\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""
"錆、無視\n"
"let data = {\n"
"    mut data = get_vec()；\n"
"    data.sort()；\n"
"    データ\n"
"};\n"
"\n"
"// ここで `data` はイミュータブルです。\n"
"```"

#: src/idioms/temporary-mutability.md:28
#, fuzzy
msgid "Using variable rebinding:"
msgstr "変数の再バインドの使用"

#: src/idioms/temporary-mutability.md:30
#, fuzzy
msgid ""
"```rust,ignore\n"
"let mut data = get_vec();\n"
"data.sort();\n"
"let data = data;\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""
"錆、無視\n"
"mut data = get_vec()；\n"
"data.sort()；\n"
"let data = data；\n"
"\n"
"// ここで `data` はイミュータブルです。\n"
"```"

#: src/idioms/temporary-mutability.md:40
#, fuzzy
msgid ""
"Compiler ensures that you don't accidentally mutate data after some point."
msgstr "コンパイラーは、ある時点以降に誤ってデータを変異させないようにします。"

#: src/idioms/temporary-mutability.md:44
#, fuzzy
msgid ""
"Nested block requires additional indentation of block body.\n"
"One more line to return data from block or redefine variable."
msgstr ""
"ネストされたブロックでは、ブロック本体のインデントを追加する必要がありま"
"す。\n"
"ブロックからデータを返したり、変数を再定義するには、もう1行必要です。"

#: src/idioms/return-consumed-arg-on-error.md:1
#, fuzzy
msgid "# Return consumed argument on error"
msgstr "# エラー時には消費された引数を返します。"

#: src/idioms/return-consumed-arg-on-error.md:5
#, fuzzy
msgid ""
"If a fallible function consumes (moves) an argument, return that argument "
"back inside\n"
"an error."
msgstr ""
"誤りやすい関数が引数を消費（移動）した場合、その引数をエラーの中に戻してくだ"
"さい。\n"
"エラーを返します。"

#: src/idioms/return-consumed-arg-on-error.md:10
#, fuzzy
msgid ""
"```rust\n"
"pub fn send(value: String) -> Result<(), SendError> {\n"
"    println!(\"using {value} in a meaningful way\");\n"
"    // Simulate non-deterministic fallible action.\n"
"    use std::time::SystemTime;\n"
"    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
"unwrap();\n"
"    if period.subsec_nanos() % 2 == 1 {\n"
"        Ok(())\n"
"    } else {\n"
"        Err(SendError(value))\n"
"    }\n"
"}\n"
"\n"
"pub struct SendError(String);\n"
"\n"
"fn main() {\n"
"    let mut value = \"imagine this is very long string\".to_string();\n"
"\n"
"    let success = 's: {\n"
"        // Try to send value two times.\n"
"        for _ in 0..2 {\n"
"            value = match send(value) {\n"
"                Ok(()) => break 's true,\n"
"                Err(SendError(value)) => value,\n"
"            }\n"
"        }\n"
"        false\n"
"    };\n"
"\n"
"    println!(\"success: {}\", success);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"pub fn send(value: String) -> Result<(), SendError> { {.\n"
"    println!(\"using {value} in a meaningful way\")；\n"
"    // 非決定論的な誤りやすいアクションをシミュレートします。\n"
"    use std::time::SystemTime；\n"
"    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
"unwrap()；\n"
"    もしperiod.subsec_nanos() % 2 == 1であれば{。\n"
"        Ok(())\n"
"    } else {\n"
"        Err(SendError(値))\n"
"    }\n"
"}\n"
"\n"
"pub struct SendError(String)；\n"
"\n"
"fn main() {\n"
"    let mut value = \"これが非常に長い文字列だと想像してください\"."
"to_string()；\n"
"\n"
"    let success = 's：{\n"
"        // 値を2回送ってみてください。\n"
"        for _ in 0.\n"
"            value = match send(value) {\n"
"                Ok(()) => break 's true、\n"
"                Err(SendError(value)) => value、\n"
"            }\n"
"        }\n"
"        false\n"
"    };\n"
"\n"
"    println!(\"success: {}\", success)；\n"
"}\n"
"```"

#: src/idioms/return-consumed-arg-on-error.md:45
#, fuzzy
msgid ""
"In case of error you may want to try some alternative way or to\n"
"retry action in case of non-deterministic function. But if the argument\n"
"is always consumed, you are forced to clone it on every call, which\n"
"is not very efficient."
msgstr ""
"エラーの場合、別の方法を試したり、非決定的な関数の場合は動作を再試行したりす"
"ることができます。\n"
"非決定的な関数の場合は動作を再試行します。しかし、引数\n"
"が常に消費されるのであれば、呼び出しのたびに引数をクローンしなければならなく"
"なります。\n"
"はあまり効率的ではありません。"

#: src/idioms/return-consumed-arg-on-error.md:50
#, fuzzy
msgid ""
"The standard library uses this approach in e.g. `String::from_utf8` method.\n"
"When given a vector that doesn't contain valid UTF-8, a `FromUtf8Error`\n"
"is returned.\n"
"You can get original vector back using `FromUtf8Error::into_bytes` method."
msgstr ""
"標準ライブラリでは、このアプローチを `String::from_utf8` メソッドなどで使用し"
"ています。\n"
"有効な UTF-8 を含まないベクトルが与えられた場合、 `FromUtf8Error` を返しま"
"す。\n"
"が返されます。\n"
"元のベクトルを取得するには `FromUtf8Error::into_bytes` メソッドを使用します。"

#: src/idioms/return-consumed-arg-on-error.md:57
#, fuzzy
msgid "Better performance because of moving arguments whenever possible."
msgstr "可能な限り引数を移動させることで、パフォーマンスが向上。"

#: src/idioms/return-consumed-arg-on-error.md:61
#, fuzzy
msgid "Slightly more complex error types."
msgstr "少し複雑なエラータイプ。"

#: src/patterns/index.md:1
#, fuzzy
msgid "# Design Patterns"
msgstr "# デザインパターン"

#: src/patterns/index.md:3
#, fuzzy
msgid ""
"[Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) "
"are\n"
"\"general reusable solutions to a commonly occurring problem within a given\n"
"context in software design\". Design patterns are a great way to describe "
"the\n"
"culture of a programming language. Design patterns are very language-"
"specific -\n"
"what is a pattern in one language may be unnecessary in another due to a\n"
"language feature, or impossible to express due to a missing feature."
msgstr ""
"[デザイン・パターン](https://en.wikipedia.org/wiki/Software_design_pattern)と"
"は\n"
"ソフトウェア設計において、与えられた文脈の中で一般的に発生する問題に対する一"
"般的な再利用可能な解決策」です。\n"
"一般的な再利用可能な解決策」です。デザインパターンは\n"
"プログラミング言語の文化を表現する素晴らしい方法です。デザインパターンは非常"
"に言語固有です。\n"
"ある言語ではパターンであるものが、別の言語では言語機能によって不要になること"
"もあります。\n"
"ある言語ではパターンであっても、別の言語ではその言語の特徴によって不要であっ"
"たり、欠けている機能によって表現できなかったりします。"

#: src/patterns/index.md:10
#, fuzzy
msgid ""
"If overused, design patterns can add unnecessary complexity to programs.\n"
"However, they are a great way to share intermediate and advanced level "
"knowledge\n"
"about a programming language."
msgstr ""
"デザインパターンは使い過ぎると、プログラムに不必要な複雑さを加えることになり"
"ます。\n"
"しかし、デザインパターンは、プログラミング言語に関する中級および上級レベルの"
"知識を共有するための素晴らしい方法です。\n"
"を共有するための素晴らしい方法です。"

#: src/patterns/index.md:16
#, fuzzy
msgid ""
"Rust has many unique features. These features give us great benefit by "
"removing\n"
"whole classes of problems. Some of them are also patterns that are _unique_ "
"to Rust."
msgstr ""
"ラストには多くのユニークな特徴があります。これらの機能は\n"
"大きなメリットをもたらします。その中には、Rust独自のパターンもあります。"

#: src/patterns/index.md:19
#, fuzzy
msgid "## YAGNI"
msgstr "## ♪ YAGNI"

#: src/patterns/index.md:21
#, fuzzy
msgid ""
"YAGNI is an acronym that stands for `You Aren't Going to Need It`.\n"
"It's a vital software design principle to apply as you write code."
msgstr ""
"YAGNIとは「You Aren't Going to Need It」の頭文字をとったものです。\n"
"これは、コードを書くときに適用すべき重要なソフトウェア設計の原則です。"

#: src/patterns/index.md:24
#, fuzzy
msgid "> The best code I ever wrote was code I never wrote."
msgstr "> 私がこれまで書いた中で最高のコードは、私が書かなかったコードです。"

#: src/patterns/index.md:26
#, fuzzy
msgid ""
"If we apply YAGNI to design patterns, we see that the features of Rust allow "
"us to\n"
"throw out many patterns. For instance, there is no need for the [strategy "
"pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"in Rust because we can just use [traits](https://doc.rust-lang.org/book/"
"traits.html)."
msgstr ""
"YAGNIをデザインパターンに適用すると、Rustの機能によって多くのパターンを捨てる"
"ことができることがわかります。\n"
"多くのパターンを捨てることができます。例えば、Rustでは[strategyパターン]"
"(https://en.wikipedia.org/wiki/Strategy_pattern)は不要です。\n"
"なぜなら、[trait](https://doc.rust-lang.org/book/traits.html)を使えばいいから"
"です。"

#: src/patterns/behavioural/intro.md:1
#, fuzzy
msgid "# Behavioural Patterns"
msgstr "# 行動パターン"

#: src/patterns/behavioural/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern):"
msgstr "Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern)より："

#: src/patterns/behavioural/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that identify common communication patterns among "
"objects.\n"
"> By doing so, these patterns increase flexibility in carrying out "
"communication."
msgstr ""
"> オブジェクト間で共通する通信パターンを特定するデザイン・パターン。\n"
"> そうすることで、通信の柔軟性が高まります。"

#: src/patterns/behavioural/command.md:1
#, fuzzy
msgid "# Command"
msgstr "# コマンド"

#: src/patterns/behavioural/command.md:5
#, fuzzy
msgid ""
"The basic idea of the Command pattern is to separate out actions into its "
"own\n"
"objects and pass them as parameters."
msgstr ""
"Commandパターンの基本的な考え方は、アクションを独自の\n"
"オブジェクトに分離し、それらをパラメータとして渡すことです。"

#: src/patterns/behavioural/command.md:10
#, fuzzy
msgid ""
"Suppose we have a sequence of actions or transactions encapsulated as "
"objects.\n"
"We want these actions or commands to be executed or invoked in some order "
"later\n"
"at different time. These commands may also be triggered as a result of some "
"event.\n"
"For example, when a user pushes a button, or on arrival of a data packet.\n"
"In addition, these commands might be undoable. This may come in useful for\n"
"operations of an editor. We might want to store logs of executed commands so "
"that\n"
"we could reapply the changes later if the system crashes."
msgstr ""
"オブジェクトとしてカプセル化された一連のアクションやトランザクションがあると"
"します。\n"
"これらのアクションやコマンドを、ある順序で、別の時間に実行したり呼び出したり"
"したいとします。\n"
"実行されるようにします。これらのコマンドは、何らかのイベントの結果としてトリ"
"ガーされることもあります。\n"
"例えば、ユーザーがボタンを押した時や、データパケットが到着した時などです。\n"
"さらに、これらのコマンドは取り消すことができるかもしれません。これは\n"
"エディターの操作に役立ちます。実行されたコマンドのログを保存しておき、後で変"
"更を適用できるようにしたいかもしれません。\n"
"実行したコマンドのログを保存しておき、後でシステムがクラッシュしたときにその"
"変更を再適用できるようにしておくとよいでしょう。"

#: src/patterns/behavioural/command.md:20
#, fuzzy
msgid ""
"Define two database operations `create table` and `add field`. Each of "
"these\n"
"operations is a command which knows how to undo the command, e.g., `drop "
"table`\n"
"and `remove field`. When a user invokes a database migration operation then "
"each\n"
"command is executed in the defined order, and when the user invokes the "
"rollback\n"
"operation then the whole set of commands is invoked in reverse order."
msgstr ""
"テーブルの作成`とフィールドの追加`の2つのデータベース操作を定義します。これら"
"の操作はそれぞれ\n"
"これらの操作はそれぞれ、コマンドを元に戻す方法を知っているコマンド、例えば "
"`drop table` と `remove field` です。\n"
"と `remove field` のように。ユーザがデータベースの移行操作を実行すると、各コ"
"マンドが定義された順序で実行されます。\n"
"ユーザがデータベースの移行操作を実行すると、各コマンドは定義された順序で実行"
"されます。\n"
"操作を呼び出すと、コマンド一式が逆の順序で実行されます。"

#: src/patterns/behavioural/command.md:26
#, fuzzy
msgid "## Approach: Using trait objects"
msgstr "## アプローチ特性オブジェクトの使用"

#: src/patterns/behavioural/command.md:28
#, fuzzy
msgid ""
"We define a common trait which encapsulates our command with two operations\n"
"`execute` and `rollback`. All command `structs` must implement this trait."
msgstr ""
"次の2つの操作でコマンドをカプセル化する共通の特徴を定義します。\n"
"execute` と `rollback` です。すべてのコマンド `struct` はこの trait を実装し"
"なければなりません。"

#: src/patterns/behavioural/command.md:31
#, fuzzy
msgid ""
"```rust\n"
"pub trait Migration {\n"
"    fn execute(&self) -> &str;\n"
"    fn rollback(&self) -> &str;\n"
"}\n"
"\n"
"pub struct CreateTable;\n"
"impl Migration for CreateTable {\n"
"    fn execute(&self) -> &str {\n"
"        \"create table\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"drop table\"\n"
"    }\n"
"}\n"
"\n"
"pub struct AddField;\n"
"impl Migration for AddField {\n"
"    fn execute(&self) -> &str {\n"
"        \"add field\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"remove field\"\n"
"    }\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Box<dyn Migration>>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"\n"
"    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
"        self.commands.push(cmd);\n"
"    }\n"
"\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev() // reverse iterator's direction\n"
"            .map(|cmd| cmd.rollback())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"\n"
"    let cmd = Box::new(CreateTable);\n"
"    schema.add_migration(cmd);\n"
"    let cmd = Box::new(AddField);\n"
"    schema.add_migration(cmd);\n"
"\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"pub trait マイグレーション {\n"
"    fn execute(&amp;self) -&gt; &amp;str；\n"
"    fn rollback(&amp;self) -&gt; &amp;str；\n"
"}\n"
"\n"
"pub struct CreateTable；\n"
"CreateTable { に対する impl Migration\n"
"    fn execute(&amp;self) -&gt; &amp;str { \"テーブルを作成します。\n"
"        \"テーブルを作成\"\n"
"    }\n"
"    fn rollback(&amp;self) -&gt; &amp;str { \"テーブルを削除します。\n"
"        \"テーブルを削除\"\n"
"    }\n"
"}\n"
"\n"
"pub struct AddField；\n"
"AddField { 用の impl Migration\n"
"    fn execute(&amp;self) -&gt; &amp;str { \"フィールドを追加します。\n"
"        \"フィールドを追加\"\n"
"    }\n"
"    fn rollback(&amp;self) -&gt; &amp;str { \"フィールドを削除\" }.\n"
"        \"フィールドを削除\"\n"
"    }\n"
"}\n"
"\n"
"struct スキーマ {\n"
"    コマンドVec&lt;Box<dyn Migration>&gt;、\n"
"}\n"
"\n"
"impl スキーマ {\n"
"    fn new() -&gt; Self { { コマンド: vec!\n"
"        Self { commands: vec![] }.\n"
"    }\n"
"\n"
"    fn add_migration(&amp;mut self, cmd: Box<dyn Migration>) { 。\n"
"        self.commands.push(cmd)；\n"
"    }\n"
"\n"
"    fn execute(&amp;self) -&gt; Vec<&str> { }.\n"
"        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
"    }\n"
"    fn rollback(&amp;self) -&gt; Vec<&str> { {.\n"
"        self.commands\n"
"            .iter()\n"
"            .rev() // イテレータの方向を反転\n"
"            .map(|cmd| cmd.rollback())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    mut schema = Schema::new()；\n"
"\n"
"    let cmd = Box::new(CreateTable)；\n"
"    schema.add_migration(cmd)；\n"
"    let cmd = Box::new(AddField)；\n"
"    schema.add_migration(cmd)；\n"
"\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute())；\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback())；\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:95
#, fuzzy
msgid "## Approach: Using function pointers"
msgstr "## アプローチ関数ポインタの使用"

#: src/patterns/behavioural/command.md:97
#, fuzzy
msgid ""
"We could follow another approach by creating each individual command as\n"
"a different function and store function pointers to invoke these functions "
"later\n"
"at a different time. Since function pointers implement all three traits "
"`Fn`,\n"
"`FnMut`, and `FnOnce` we could as well pass and store closures instead of\n"
"function pointers."
msgstr ""
"別の方法として、個々のコマンドを別の関数として作成し\n"
"それぞれのコマンドを別の関数として作成し、後でこれらの関数を別の時間に呼び出"
"すための関数ポインタを格納することで\n"
"を別の時に呼び出すことができます。関数ポインタは `Fn`、\n"
"FnMut`、`FnOnce`の3つの特性を実装しているので、関数ポインタの代わりにクロー"
"ジャを渡して格納することもできます。\n"
"関数ポインタの代わりに"

#: src/patterns/behavioural/command.md:103
#, fuzzy
msgid ""
"```rust\n"
"type FnPtr = fn() -> String;\n"
"struct Command {\n"
"    execute: FnPtr,\n"
"    rollback: FnPtr,\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Command>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
"        self.commands.push(Command { execute, rollback });\n"
"    }\n"
"    fn execute(&self) -> Vec<String> {\n"
"        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<String> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev()\n"
"            .map(|cmd| (cmd.rollback)())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> String {\n"
"    \"add field\".to_string()\n"
"}\n"
"\n"
"fn remove_field() -> String {\n"
"    \"remove field\".to_string()\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\".to_string(), || \"drop table\"."
"to_string());\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"type FnPtr = fn() -&gt; String；\n"
"struct コマンド\n"
"    を実行します：FnPtr、\n"
"    rollback：FnPtr、\n"
"}\n"
"\n"
"struct Schema {\n"
"    コマンド：Vec<Command> 、\n"
"}\n"
"\n"
"impl スキーマ {\n"
"    fn new() -&gt; Self { { コマンド: vec!\n"
"        Self { commands: vec![] }.\n"
"    }\n"
"    fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) "
"{ { self.\n"
"        self.commands.push(Command { execute, rollback })；\n"
"    }\n"
"    fn execute(&amp;self) -&gt; Vec<String> { 実行します。\n"
"        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
"    }\n"
"    fn rollback(&amp;self) -&gt; Vec<String> {。\n"
"        self.commands\n"
"            .iter()\n"
"            .rev()\n"
"            .map(|cmd| (cmd.rollback)())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -&gt; String { \"フィールドを追加\".to_string()\n"
"    \"フィールドを追加\".to_string()\n"
"}\n"
"\n"
"fn remove_field() -&gt; String { \"フィールドを削除\".\n"
"    \"フィールドを削除\".to_string()\n"
"}\n"
"\n"
"fn main() {\n"
"    mut schema = Schema::new()；\n"
"    schema.add_migration(|| \"create table\".to_string(), || \"drop table\"."
"to_string())；\n"
"    schema.add_migration(add_field, remove_field)；\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute())；\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback())；\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:150
#, fuzzy
msgid "## Approach: Using `Fn` trait objects"
msgstr "## アプローチFn` 特性オブジェクトの使用"

#: src/patterns/behavioural/command.md:152
#, fuzzy
msgid ""
"Finally, instead of defining a common command trait we could store\n"
"each command implementing the `Fn` trait separately in vectors."
msgstr ""
"最後に、共通のコマンドの特徴を定義する代わりに、`Fn`の特徴を実装した各コマン"
"ドを別々にベクターに格納することができます。\n"
"を実装した各コマンドを別々にベクターに格納することができます。"

#: src/patterns/behavioural/command.md:155
#, fuzzy
msgid ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>；\n"
"\n"
"構造体スキーマ<'a> {\n"
"    を実行します：Vec<Migration<'a>>、\n"
"    ロールバックVec<Migration<'a>>、\n"
"}\n"
"\n"
"impl<'a> Schema<'a> { 以下のようになります。\n"
"    fn new() -> Self { {.\n"
"        自己 {\n"
"            executes: vec![]、\n"
"            rollbacks: vec!\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    ここで\n"
"        E: Fn() -> &'a str + 'static、\n"
"        R: Fn() -> &'a str + 'static, R: Fn() -> &'a str + 'static、\n"
"    {\n"
"        self.executes.push(Box::new(execute))；\n"
"        self.rollbacks.push(Box::new(rollback))；\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> { { self.executes.iter()を実行します。\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    \n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str { \"フィールドの追加\n"
"    \"フィールドを追加\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str { \"フィールドを削除\" }.\n"
"    \"フィールドを削除\"\n"
"}\n"
"\n"
"fn main() {\n"
"    mut schema = Schema::new()；\n"
"    schema.add_migration(|| \"create table\", || \"drop table\")；\n"
"    schema.add_migration(add_field, remove_field)；\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute())；\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback())；\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:205
#, fuzzy
msgid ""
"If our commands are small and may be defined as functions or passed as a "
"closure\n"
"then using function pointers might be preferable since it does not exploit\n"
"dynamic dispatch. But if our command is a whole struct with a bunch of "
"functions\n"
"and variables defined as seperated module then using trait objects would be\n"
"more suitable. A case of application can be found in [`actix`](https://actix."
"rs/),\n"
"which uses trait objects when it registers a handler function for routes.\n"
"In case of using `Fn` trait objects we can create and use commands in the "
"same\n"
"way as we used in case of function pointers."
msgstr ""
"コマンドが小さく、関数として定義されたり、クロージャとして渡されたりするので"
"あれば、関数ポインタを使うのが望ましいでしょう。\n"
"として渡されるのであれば、関数ポインタを使う方が望ましいでしょう。\n"
"動的ディスパッチを悪用しないからです。しかし、コマンドが構造体全体であり、関"
"数や変数がモジュールとして分離されて定義されているような場合は、 trait オブ"
"ジェクトを使用するのが望ましいでしょう。\n"
"と変数が分離されたモジュールとして定義されている場合は、 trait オブジェクトを"
"使用する方が適しています。\n"
"の方が適しています。その応用例が[`actix`](https://actix.rs/)にあります、\n"
"これは、ルート用のハンドラ関数を登録するときに trait オブジェクトを使用してい"
"ます。\n"
"Fn` 特性オブジェクトを使用する場合、関数の場合と同じようにコマンドを作成して"
"使用することができます。\n"
"関数ポインタの場合と同じようにコマンドを作成して使用することができます。"

#: src/patterns/behavioural/command.md:214
#, fuzzy
msgid ""
"As performance, there is always a trade-off between performance and code\n"
"simplicity and organisation. Static dispatch gives faster performance, "
"while\n"
"dynamic dispatch provides flexibility when we structure our application."
msgstr ""
"パフォーマンスとコードは常にトレードオフの関係にあります。\n"
"シンプルさと整理の間には常にトレードオフがあります。静的ディスパッチはより高"
"速なパフォーマンスをもたらしますが\n"
"動的ディスパッチはアプリケーションを構成する際に柔軟性をもたらします。"

#: src/patterns/behavioural/command.md:220
#, fuzzy
msgid ""
"- [Command pattern](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [Another example for the `command` pattern](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"
msgstr ""
"- [コマンドパターン](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [コマンドパターンのもう一つの例](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"

#: src/patterns/behavioural/interpreter.md:1
#, fuzzy
msgid "# Interpreter"
msgstr "# 通訳"

#: src/patterns/behavioural/interpreter.md:5
#, fuzzy
msgid ""
"If a problem occurs very often and requires long and repetitive steps to "
"solve\n"
"it, then the problem instances might be expressed in a simple language and "
"an\n"
"interpreter object could solve it by interpreting the sentences written in "
"this\n"
"simple language."
msgstr ""
"ある問題が非常に頻繁に発生し、その解決に長く反復的な手順を必要とする場合、問"
"題のインスタンスは単純な言語で表現されるかもしれません。\n"
"問題のインスタンスは簡単な言語で表現され、インタープリタ・オブジェクトはこの"
"言語で書かれた文章を解釈することで問題を解決することができます。\n"
"インタプリタ・オブジェクトは、この単純な言語で書かれた文章を解釈することで\n"
"この単純な言語で書かれた文章を解釈することで"

#: src/patterns/behavioural/interpreter.md:10
#, fuzzy
msgid "Basically, for any kind of problems we define:"
msgstr "基本的に、私たちが定義するあらゆる種類の問題に対してです："

#: src/patterns/behavioural/interpreter.md:12
#, fuzzy
msgid ""
"- A [domain specific language](https://en.wikipedia.org/wiki/Domain-"
"specific_language),\n"
"- A grammar for this language,\n"
"- An interpreter that solves the problem instances."
msgstr ""
"- ドメイン固有言語](https://en.wikipedia.org/wiki/Domain-"
"specific_language)、\n"
"- この言語の文法、\n"
"- 問題インスタンスを解決するインタプリタ。"

#: src/patterns/behavioural/interpreter.md:18
#, fuzzy
msgid ""
"Our goal is to translate simple mathematical expressions into postfix "
"expressions\n"
"(or [Reverse Polish notation](https://en.wikipedia.org/wiki/"
"Reverse_Polish_notation))\n"
"For simplicity, our expressions consist of ten digits `0`, ..., `9` and two\n"
"operations `+`, `-`. For example, the expression `2 + 4` is translated into\n"
"`2 4 +`."
msgstr ""
"私たちの目標は、簡単な数式をポストフィックス式\n"
"(または[逆ポーランド記法](https://en.wikipedia.org/wiki/"
"Reverse_Polish_notation))\n"
"簡単のために、式は10桁の数字 `0`, ..., `9` と2つの演算 `+`, `-` で構成されま"
"す。\n"
"演算 `+`, `-`.例えば `2 + 4` という式は次のように変換されます。\n"
"`2 4 +`."

#: src/patterns/behavioural/interpreter.md:24
#, fuzzy
msgid "## Context Free Grammar for our problem"
msgstr ""
"## Context Free Grammar for our problem (私たちの問題のための文脈自由文法)"

#: src/patterns/behavioural/interpreter.md:26
#, fuzzy
msgid ""
"Our task is translating infix expressions into postfix ones. Let's define a "
"context\n"
"free grammar for a set of infix expressions over `0`, ..., `9`, `+`, and `-"
"`,\n"
"where:"
msgstr ""
"私たちの仕事は、infix式をpostfix式に変換することです。では、`0`, ..., `9`, "
"`+`, `-` に対する\n"
"0`, ..., `9`, `+`, `-` に対応するinfix式の集合に対して文脈自由文法を定義しま"
"しょう、\n"
"ここで"

#: src/patterns/behavioural/interpreter.md:30
#, fuzzy
msgid ""
"- Terminal symbols: `0`, `...`, `9`, `+`, `-`\n"
"- Non-terminal symbols: `exp`, `term`\n"
"- Start symbol is `exp`\n"
"- And the following are production rules"
msgstr ""
"- 終端記号：`0`, `...`, `9`, `+`, `-`\n"
"- 非終端記号：exp`, `term`\n"
"- 開始記号は `exp` です。\n"
"- そして、以下はプロダクションルールです。"

#: src/patterns/behavioural/interpreter.md:35
#, fuzzy
msgid ""
"```ignore\n"
"exp -> exp + term\n"
"exp -> exp - term\n"
"exp -> term\n"
"term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
"```"
msgstr ""
"無視\n"
"exp -> exp + term\n"
"exp -> exp - term\n"
"exp -> term\n"
"項→0｜1｜2｜3｜4｜5｜6｜7｜8｜9\n"
"```"

#: src/patterns/behavioural/interpreter.md:42
#, fuzzy
msgid ""
"**NOTE:** This grammar should be further transformed depending on what we "
"are going\n"
"to do with it. For example, we might need to remove left recursion. For "
"more\n"
"details please see [Compilers: Principles,Techniques, and Tools](https://en."
"wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)\n"
"(aka Dragon Book)."
msgstr ""
"**注：**この文法は、私たちが何をしようとしているかによって、さらに変形される"
"べきです。\n"
"例えば、左再帰を削除する必要があるかもしれません。例えば、左再帰を削除する必"
"要があるかもしれません。詳しくは\n"
"詳細は[Compilers: Principles,Techniques, and Tools](https://en.wikipedia.org/"
"wiki/Compilers:_Principles,_Techniques,_and_Tools)を参照してください。\n"
"(別名ドラゴンブック)を参照してください。"

#: src/patterns/behavioural/interpreter.md:47
#, fuzzy
msgid "## Solution"
msgstr "## 解決"

#: src/patterns/behavioural/interpreter.md:49
#, fuzzy
msgid ""
"We simply implement a recursive descent parser. For simplicity's sake, the "
"code\n"
"panics when an expression is syntactically wrong (for example `2-34` or `2+5-"
"`\n"
"are wrong according to the grammar definition)."
msgstr ""
"再帰降下パーサーを実装するだけです。簡単にするために、コードは\n"
"はパニックになります。\n"
"は文法定義によると間違っています）。"

#: src/patterns/behavioural/interpreter.md:53
#, fuzzy
msgid ""
"```rust\n"
"pub struct Interpreter<'a> {\n"
"    it: std::str::Chars<'a>,\n"
"}\n"
"\n"
"impl<'a> Interpreter<'a> {\n"
"\n"
"    pub fn new(infix: &'a str) -> Self {\n"
"        Self { it: infix.chars() }\n"
"    }\n"
"\n"
"    fn next_char(&mut self) -> Option<char> {\n"
"        self.it.next()\n"
"    }\n"
"\n"
"    pub fn interpret(&mut self, out: &mut String) {\n"
"        self.term(out);\n"
"\n"
"        while let Some(op) = self.next_char() {\n"
"            if op == '+' || op == '-' {\n"
"                self.term(out);\n"
"                out.push(op);\n"
"            } else {\n"
"                panic!(\"Unexpected symbol '{}'\", op);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    fn term(&mut self, out: &mut String) {\n"
"        match self.next_char() {\n"
"            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
"            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
"            None => panic!(\"Unexpected end of string\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let mut intr = Interpreter::new(\"2+3\");\n"
"    let mut postfix = String::new();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"23+\");\n"
"\n"
"    intr = Interpreter::new(\"1-2+3-4\");\n"
"    postfix.clear();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"12-3+4-\");\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"pub struct インタープリタ<'a> {\n"
"    it: std::str::Chars<'a> 、\n"
"}\n"
"\n"
"impl<'a> Interpreter<'a> {\n"
"\n"
"    pub fn new(infix: &amp;'a str) -&gt; Self {.\n"
"        Self { it: infix.chars() }.\n"
"    }\n"
"\n"
"    fn next_char(&amp;mut self) -&gt; オプション<char> {。\n"
"        self.it.next()\n"
"    }\n"
"\n"
"    pub fn interpret(&amp;mut self, out: &amp;mut String) { { self.\n"
"        self.term(out)；\n"
"\n"
"        while let Some(op) = self.next_char() { if op == '+' || op == "
"'-' { if op == '+' || op == '-'\n"
"            if op == '+' || op == '-' { {.\n"
"                self.term(out)；\n"
"                out.push(op)；\n"
"            } else {\n"
"                panic!(\"Unexpected symbol '{}'\", op)；\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    fn term(&amp;mut self, out: &amp;mut String) { { 次のようになります。\n"
"        match self.next_char() { { {.\n"
"            Some(ch) if ch.is_digit(10) =&gt; out.push(ch)、\n"
"            Some(ch) =&gt; panic!(\"Unexpected symbol '{}'\", ch)、\n"
"            None =&gt; panic!(\"Unexpected end of string\")、\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let mut intr = Interpreter::new(\"2+3\")；\n"
"    let mut postfix = String::new()；\n"
"    intr.interpret(&amp;mut postfix)；\n"
"    assert_eq!(postfix, \"23+\")；\n"
"\n"
"    intr = Interpreter::new(\"1-2+3-4\")；\n"
"    postfix.clear()；\n"
"    intr.interpret(&amp;mut postfix)；\n"
"    assert_eq!(postfix, \"12-3+4-\");\n"
"}\n"
"```"

#: src/patterns/behavioural/interpreter.md:105
#, fuzzy
msgid ""
"There may be a wrong perception that the Interpreter design pattern is about "
"design\n"
"grammars for formal languages and implementation of parsers for these "
"grammars.\n"
"In fact, this pattern is about expressing problem instances in a more "
"specific\n"
"way and implementing functions/classes/structs that solve these problem "
"instances.\n"
"Rust language has `macro_rules!` that allow us to define special syntax and "
"rules\n"
"on how to expand this syntax into source code."
msgstr ""
"インタープリター・デザイン・パターンは、形式言語のための文法設計と、その文法"
"に対応したパーザーの実装に関するものだという間違った認識があるかもしれませ"
"ん。\n"
"文法を設計し、その文法に対応するパーサーを実装することです。\n"
"実際には、このパターンは問題インスタンスをより具体的に表現し、その問題インス"
"タンスを解決する関数/クラス/構造を実装するためのものです。\n"
"問題インスタンスをより具体的に表現し、その問題インスタンスを解決する関数/クラ"
"ス/構造を実装することです。\n"
"Rust言語には`macro_rules!\n"
"があります。"

#: src/patterns/behavioural/interpreter.md:112
#, fuzzy
msgid ""
"In the following example we create a simple `macro_rules!` that computes\n"
"[Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) of `n`\n"
"dimensional vectors. Writing `norm!(x,1,2)` might be easier to express and "
"more\n"
"efficient than packing `x,1,2` into a `Vec` and calling a function "
"computing\n"
"the length."
msgstr ""
"次の例では、次のような単純な `macro_rules!` を作成します。\n"
"[ユークリッド長](https://en.wikipedia.org/wiki/Euclidean_distance) を計算す"
"る `n`\n"
"次元ベクトルの[ユークリッド長]() を計算する簡単な `macro_ules!norm!(x,1,2)`と"
"書くと、`x,1,2)`を詰め込むよりも表現が簡単で効率的です。\n"
"x,1,2`を `Vec` に詰め込んで長さを計算する関数を呼び出すよりも\n"
"を呼び出すよりも簡単で効率的です。"

#: src/patterns/behavioural/interpreter.md:118
#, fuzzy
msgid ""
"```rust\n"
"macro_rules! norm {\n"
"    ($($element:expr),*) => {\n"
"        {\n"
"            let mut n = 0.0;\n"
"            $(\n"
"                n += ($element as f64)*($element as f64);\n"
"            )*\n"
"            n.sqrt()\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -3f64;\n"
"    let y = 4f64;\n"
"\n"
"    assert_eq!(3f64, norm!(x));\n"
"    assert_eq!(5f64, norm!(x, y));\n"
"    assert_eq!(0f64, norm!(0, 0, 0)); \n"
"    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"macro_rules!\n"
"    ($($element:expr),*) => {.\n"
"        {\n"
"            mut n = 0.0；\n"
"            $(\n"
"                n += ($element as f64)*($element as f64)；\n"
"            )*\n"
"            n.sqrt()\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -3f64；\n"
"    let y = 4f64；\n"
"\n"
"    assert_eq!(3f64, norm!(x))；\n"
"    assert_eq!(5f64, norm!(x, y))；\n"
"    assert_eq!(0f64, norm!(0, 0, 0))；\n"
"    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5))；\n"
"}\n"
"```"

#: src/patterns/behavioural/interpreter.md:144
#, fuzzy
msgid ""
"- [Interpreter pattern](https://en.wikipedia.org/wiki/Interpreter_pattern)\n"
"- [Context free grammar](https://en.wikipedia.org/wiki/Context-"
"free_grammar)\n"
"- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"
msgstr ""
"- [インタープリターパターン](https://en.wikipedia.org/wiki/"
"Interpreter_pattern)\n"
"- [文脈自由文法](https://en.wikipedia.org/wiki/Context-free_grammar)\n"
"- [マクロ_ルール！](https://doc.rust-lang.org/rust-by-example/macros.html)"

#: src/patterns/behavioural/newtype.md:1
#, fuzzy
msgid "# Newtype"
msgstr "# ニュータイプ"

#: src/patterns/behavioural/newtype.md:3
#, fuzzy
msgid ""
"What if in some cases we want a type to behave similar to another type or\n"
"enforce some behaviour at compile time when using only type aliases would\n"
"not be enough?"
msgstr ""
"ある型が別の型と同じような振る舞いをするようにしたい場合や、コンパイル時に\n"
"コンパイル時に型エイリアスだけでは十分でないような場合に\n"
"では不十分だとしたら？"

#: src/patterns/behavioural/newtype.md:7
#, fuzzy
msgid ""
"For example, if we want to create a custom `Display` implementation for "
"`String`\n"
"due to security considerations (e.g. passwords)."
msgstr ""
"例えば、セキュリティ（パスワードなど）を考慮して `String` に対してカスタムの "
"`Display` 実装を作成したい場合。\n"
"のカスタム実装を作成したい場合 (パスワードなど)。"

#: src/patterns/behavioural/newtype.md:10
#, fuzzy
msgid ""
"For such cases we could use the `Newtype` pattern to provide **type "
"safety**\n"
"and **encapsulation**."
msgstr ""
"このような場合、`Newtype`パターンを使って、**型の安全性** と**カプセル化** を"
"提供することができます。\n"
"と **カプセル化** を提供します。"

#: src/patterns/behavioural/newtype.md:15
#, fuzzy
msgid ""
"Use a tuple struct with a single field to make an opaque wrapper for a "
"type.\n"
"This creates a new type, rather than an alias to a type (`type` items)."
msgstr ""
"単一のフィールドを持つタプル構造体を使用して、型の不透明なラッパーを作成しま"
"す。\n"
"これは、型のエイリアス（`type`項目）ではなく、新しい型を作成します。"

#: src/patterns/behavioural/newtype.md:20
msgid ""
"```rust\n"
"use std::fmt::Display;\n"
"\n"
"// Create Newtype Password to override the Display trait for String\n"
"struct Password(String);\n"
"\n"
"impl Display for Password {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"****************\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let unsecured_password: String = \"ThisIsMyPassword\".to_string();\n"
"    let secured_password: Password = Password(unsecured_password.clone());\n"
"    println!(\"unsecured_password: {unsecured_password}\");\n"
"    println!(\"secured_password: {secured_password}\");\n"
"}\n"
"```"
msgstr ""

#: src/patterns/behavioural/newtype.md:40
msgid ""
"```shell\n"
"unsecured_password: ThisIsMyPassword\n"
"secured_password: ****************\n"
"```"
msgstr ""

#: src/patterns/behavioural/newtype.md:47
#, fuzzy
msgid ""
"The primary motivation for newtypes is abstraction. It allows you to share\n"
"implementation details between types while precisely controlling the "
"interface.\n"
"By using a newtype rather than exposing the implementation type as part of "
"an\n"
"API, it allows you to change implementation backwards compatibly."
msgstr ""
"ニュータイプの主な動機は抽象化です。これによって\n"
"インターフェイスを正確に制御しながら、型間で実装の詳細を共有することができま"
"す。\n"
"実装型をAPIの一部として公開するのではなく、newtypeを使うことで\n"
"を使うことで、互換性を保ったまま実装を変更することができます。"

#: src/patterns/behavioural/newtype.md:52
#, fuzzy
msgid ""
"Newtypes can be used for distinguishing units, e.g., wrapping `f64` to give\n"
"distinguishable `Miles` and `Kilometres`."
msgstr ""
"例えば、`f64`をラップして`miles`と`Kilometres`を区別できるようにします。\n"
"例えば、`f64` をラップして `Miles` と `Kilometres` を区別できるようにします。"

#: src/patterns/behavioural/newtype.md:57
#, fuzzy
msgid ""
"The wrapped and wrapper types are not type compatible (as opposed to using\n"
"`type`), so users of the newtype will never 'confuse' the wrapped and "
"wrapper\n"
"types."
msgstr ""
"ラップ型とラッパー型は型互換性がありません。\n"
"type`を使うのとは対照的です)、そのため、newtypeのユーザがwrapped型とwrapper型"
"を「混同」することはありません。\n"
"型と混同することはありません。"

#: src/patterns/behavioural/newtype.md:61
#, fuzzy
msgid "Newtypes are a zero-cost abstraction - there is no runtime overhead."
msgstr ""
"newtypesはコストゼロの抽象化であり、実行時のオーバーヘッドはありません。"

#: src/patterns/behavioural/newtype.md:63
#, fuzzy
msgid ""
"The privacy system ensures that users cannot access the wrapped type (if "
"the\n"
"field is private, which it is by default)."
msgstr ""
"プライバシーシステムは、ユーザがラップされた型にアクセスできないことを保証し"
"ます。\n"
"フィールドにアクセスできないようにします。）"

#: src/patterns/behavioural/newtype.md:68
#, fuzzy
msgid ""
"The downside of newtypes (especially compared with type aliases), is that "
"there\n"
"is no special language support. This means there can be _a lot_ of "
"boilerplate.\n"
"You need a 'pass through' method for every method you want to expose on the\n"
"wrapped type, and an impl for every trait you want to also be implemented "
"for\n"
"the wrapper type."
msgstr ""
"newtypeの欠点は（特に型のエイリアスと比べて）、特別な言語サポートがないことで"
"す。\n"
"特別な言語サポートがないことです。つまり、多くの定型文が必要になります。\n"
"ラップされた型に公開したいメソッドには「パススルー」メソッドが必要です。\n"
"ラップされた型に公開したいメソッドには「パススルー」メソッドが必要です。\n"
"を実装する必要があります。"

#: src/patterns/behavioural/newtype.md:76
#, fuzzy
msgid ""
"Newtypes are very common in Rust code. Abstraction or representing units are "
"the\n"
"most common uses, but they can be used for other reasons:"
msgstr ""
"Rustのコードでは、newtypesがよく使われます。抽象化や単位の表現が最も一般的で"
"すが\n"
"が最も一般的な使用法ですが、その他の理由でも使用できます："

#: src/patterns/behavioural/newtype.md:79
#, fuzzy
msgid ""
"- restricting functionality (reduce the functions exposed or traits "
"implemented),\n"
"- making a type with copy semantics have move semantics,\n"
"- abstraction by providing a more concrete type and thus hiding internal "
"types,\n"
"  e.g.,"
msgstr ""
"- 機能の制限（公開される関数や実装される特質を減らす）、\n"
"- コピー・セマンティクスを持つ型にムーブ・セマンティクスを持たせること、\n"
"- より具象的な型を提供することで、内部型を隠すことによる抽象化、\n"
"  例えば"

#: src/patterns/behavioural/newtype.md:84
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub struct Foo(Bar<T1, T2>);\n"
"```"
msgstr ""
"錆、無視\n"
"pub struct Foo(Bar<T1, T2>)；\n"
"```"

#: src/patterns/behavioural/newtype.md:88
#, fuzzy
msgid ""
"Here, `Bar` might be some public, generic type and `T1` and `T2` are some "
"internal\n"
"types. Users of our module shouldn't know that we implement `Foo` by using a "
"`Bar`,\n"
"but what we're really hiding here is the types `T1` and `T2`, and how they "
"are used\n"
"with `Bar`."
msgstr ""
"ここで、`Bar` はパブリックな汎用型であり、`T1` と `T2` は内部型です。\n"
"型です。このモジュールのユーザは `Bar` を使って `Foo` を実装していることを知"
"らないはずです、\n"
"しかし、ここで本当に隠しているのは `T1` と `T2` という型であり、それらが "
"`Bar` でどのように使われているかということです。\n"
"と `Bar` です。"

#: src/patterns/behavioural/newtype.md:95
#, fuzzy
msgid ""
"- [Advanced Types in the book](https://doc.rust-lang.org/book/ch19-04-"
"advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-"
"safety-and-abstraction)\n"
"- [Newtypes in Haskell](https://wiki.haskell.org/Newtype)\n"
"- [Type aliases](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
"types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more), a crate for deriving "
"many\n"
"  builtin traits on newtypes.\n"
"- [The Newtype Pattern In Rust](https://web.archive.org/web/20230519162111/"
"https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"
msgstr ""
"- [本の中の高度な型](https://doc.rust-lang.org/book/ch19-04-advanced-types."
"html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-"
"abstraction)\n"
"- [Haskellにおける新しい型](https://wiki.haskell.org/Newtype)\n"
"- [型のエイリアス](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
"types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more)。\n"
"  クレートです。\n"
"- [Rust における Newtype パターン](https://www.worthe-it.co.za/"
"blog/2020-10-31-newtype-pattern-in-rust.html)"

#: src/patterns/behavioural/RAII.md:1
#, fuzzy
msgid "# RAII with guards"
msgstr "# ガード付きRAII"

#: src/patterns/behavioural/RAII.md:5
#, fuzzy
msgid ""
"[RAII][wikipedia] stands for \"Resource Acquisition is Initialisation\" "
"which is a\n"
"terrible name. The essence of the pattern is that resource initialisation is "
"done\n"
"in the constructor of an object and finalisation in the destructor. This "
"pattern\n"
"is extended in Rust by using a RAII object as a guard of some resource and "
"relying\n"
"on the type system to ensure that access is always mediated by the guard "
"object."
msgstr ""
"[RAII][wikipedia]は「Resource Acquisition is Initialisation」の略。\n"
"ひどい名前です。このパターンの本質は、リソースの初期化をオブジェクトのコンス"
"トラクタで行い、最終化をデストラクタで行うというものです。\n"
"オブジェクトのコンストラクタで行われ、デストラクタで最終化されるということで"
"す。このパターン\n"
"Rustでは、RAIIオブジェクトをリソースのガードとして使用し、型システムに依存す"
"ることで、このパターンを拡張しています。\n"
"型システムに依存し、アクセスが常にガードオブジェクトによって媒介されるように"
"します。"

#: src/patterns/behavioural/RAII.md:13
#, fuzzy
msgid ""
"Mutex guards are the classic example of this pattern from the std library "
"(this\n"
"is a simplified version of the real implementation):"
msgstr ""
"ミューテックス・ガードは、stdライブラリにあるこのパターンの典型的な例です（こ"
"れは実際の実装を簡略化したものです）。\n"
"これは実際の実装を簡略化したものです）："

#: src/patterns/behavioural/RAII.md:16
#, fuzzy
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"struct Mutex<T> {\n"
"    // We keep a reference to our data: T here.\n"
"    //..\n"
"}\n"
"\n"
"struct MutexGuard<'a, T: 'a> {\n"
"    data: &'a T,\n"
"    //..\n"
"}\n"
"\n"
"// Locking the mutex is explicit.\n"
"impl<T> Mutex<T> {\n"
"    fn lock(&self) -> MutexGuard<T> {\n"
"        // Lock the underlying OS mutex.\n"
"        //..\n"
"\n"
"        // MutexGuard keeps a reference to self\n"
"        MutexGuard {\n"
"            data: self,\n"
"            //..\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Destructor for unlocking the mutex.\n"
"impl<'a, T> Drop for MutexGuard<'a, T> {\n"
"    fn drop(&mut self) {\n"
"        // Unlock the underlying OS mutex.\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"// Implementing Deref means we can treat MutexGuard like a pointer to T.\n"
"impl<'a, T> Deref for MutexGuard<'a, T> {\n"
"    type Target = T;\n"
"\n"
"    fn deref(&self) -> &T {\n"
"        self.data\n"
"    }\n"
"}\n"
"\n"
"fn baz(x: Mutex<Foo>) {\n"
"    let xx = x.lock();\n"
"    xx.foo(); // foo is a method on Foo.\n"
"    // The borrow checker ensures we can't store a reference to the "
"underlying\n"
"    // Foo which will outlive the guard xx.\n"
"\n"
"    // x is unlocked when we exit this function and xx's destructor is "
"executed.\n"
"}\n"
"```"
msgstr ""
"錆,無視\n"
"std::ops::Derefを使用してください；\n"
"\n"
"構造体 Foo{}\n"
"\n"
"struct Mutex<T> {\n"
"    // データへの参照を保持します：Tはここにあります。\n"
"    //..\n"
"}\n"
"\n"
"struct ミューテックスガード<'a, T: 'a> {\n"
"    data: &amp;'a T、\n"
"    //..\n"
"}\n"
"\n"
"// ミューテックスのロックは明示的です。\n"
"impl<T> ミューテックス<T> {\n"
"    fn lock(&amp;self) -&gt; MutexGuard<T> {.\n"
"        // OSのミューテックスをロックします。\n"
"        //..\n"
"\n"
"        // MutexGuard は self への参照を保持します。\n"
"        MutexGuard {\n"
"            data: self、\n"
"            //..\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ミューテックスをアンロックするためのデストラクタです。\n"
"impl<'a, T> Drop for MutexGuard<'a, T> {\n"
"    fn drop(&amp;mut self) { // OSのミューテックスのロックを解除します。\n"
"        // OSのミューテックスのロックを解除します。\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"// Derefを実装するということは、MutexGuardをTへのポインタのように扱うことがで"
"きるということです。\n"
"impl<'a, T> Deref for MutexGuard<'a, T> {\n"
"    型 Target = T；\n"
"\n"
"    fn deref(&amp;self) -&gt; &amp;T { 以下のようになります。\n"
"        self.data\n"
"    }\n"
"}\n"
"\n"
"fn baz(x: Mutex<Foo>) { { }.\n"
"    let xx = x.lock()；\n"
"    xx.foo(); // fooはFooのメソッドです。\n"
"    借用チェッカーは、 // Foo への参照を保存できないことを保証します。\n"
"    // への参照を保存できないことを保証します。\n"
"\n"
"    この関数を終了して xx のデストラクタが実行されると、 // x のロックが解除"
"されます。\n"
"}\n"
"```"

#: src/patterns/behavioural/RAII.md:74
#, fuzzy
msgid ""
"Where a resource must be finalised after use, RAII can be used to do this\n"
"finalisation. If it is an error to access that resource after finalisation, "
"then\n"
"this pattern can be used to prevent such errors."
msgstr ""
"リソースの使用後に最終確認が必要な場合、RAIIを使用して最終確認を行うことがで"
"きます。\n"
"ファイナライズを行います。ファイナライズ後にリソースにアクセスするとエラーに"
"なる場合は\n"
"このパターンを使ってそのようなエラーを防ぐことができます。"

#: src/patterns/behavioural/RAII.md:80
#, fuzzy
msgid ""
"Prevents errors where a resource is not finalised and where a resource is "
"used\n"
"after finalisation."
msgstr ""
"リソースが確定していない場合や、確定後にリソースが使用された場合のエラーを防"
"ぎます。\n"
"エラーを防ぎます。"

#: src/patterns/behavioural/RAII.md:85
#, fuzzy
msgid ""
"RAII is a useful pattern for ensuring resources are properly deallocated or\n"
"finalised. We can make use of the borrow checker in Rust to statically "
"prevent\n"
"errors stemming from using resources after finalisation takes place."
msgstr ""
"RAIIは、リソースが適切に割り当て解除または確定されるようにするための有用なパ"
"ターンです。\n"
"を保証するための有用なパターンです。Rustのボローン・チェッカーを使用すること"
"で、最終化後にリソースを使用することによるエラーを静的に防ぐことができま"
"す。\n"
"エラーを静的に防ぐことができます。"

#: src/patterns/behavioural/RAII.md:89
#, fuzzy
msgid ""
"The core aim of the borrow checker is to ensure that references to data do "
"not\n"
"outlive that data. The RAII guard pattern works because the guard object\n"
"contains a reference to the underlying resource and only exposes such\n"
"references. Rust ensures that the guard cannot outlive the underlying "
"resource\n"
"and that references to the resource mediated by the guard cannot outlive "
"the\n"
"guard. To see how this works it is helpful to examine the signature of "
"`deref`\n"
"without lifetime elision:"
msgstr ""
"借用チェッカーの主な目的は、データへの参照がそのデータより長くならないように"
"することです。\n"
"を保証することです。RAIIガードパターンが機能するのは、ガードオブジェクト\n"
"が基本リソースへの参照を含み、そのような参照のみを公開するからです。\n"
"参照のみを公開するためです。Rustは、ガードが基礎となるリソース\n"
"また、ガードによって媒介されるリソースへの参照がガードより長くなることはあり"
"ません。\n"
"ガードより長くなることはありません。これがどのように機能するかを見るには、"
"`deref`のシグネチャを調べると便利です。\n"
"のシグネチャを見てみましょう："

#: src/patterns/behavioural/RAII.md:97
#, fuzzy
msgid ""
"```rust,ignore\n"
"fn deref<'a>(&'a self) -> &'a T {\n"
"    //..\n"
"}\n"
"```"
msgstr ""
"錆,無視\n"
"fn deref<'a>(&'a self) -> &'a T {.\n"
"    //..\n"
"}\n"
"```"

#: src/patterns/behavioural/RAII.md:103
#, fuzzy
msgid ""
"The returned reference to the resource has the same lifetime as `self` "
"(`'a`).\n"
"The borrow checker therefore ensures that the lifetime of the reference to "
"`T`\n"
"is shorter than the lifetime of `self`."
msgstr ""
"リソースへの参照は `self` (`'a`) と同じ有効期間を持ちます。\n"
"したがって、ボローチェッカーは `T` への参照の有効期限が `self` の有効期限より"
"も短いことを保証します。\n"
"への参照の有効期限が `self` の有効期限よりも短いことを保証します。"

#: src/patterns/behavioural/RAII.md:107
#, fuzzy
msgid ""
"Note that implementing `Deref` is not a core part of this pattern, it only "
"makes\n"
"using the guard object more ergonomic. Implementing a `get` method on the "
"guard\n"
"works just as well."
msgstr ""
"Deref`の実装はこのパターンの核心部分ではありません。\n"
"をより人間工学的に使えるようにするだけです。ガードに `get` メソッドを実装する"
"ことは\n"
"メソッドを実装しても同じように動作します。"

#: src/patterns/behavioural/RAII.md:113
#, fuzzy
msgid "[Finalisation in destructors idiom](../../idioms/dtor-finally.md)"
msgstr "[デストラクタの最終化イディオム](../../idioms/dtor-finally.md)"

#: src/patterns/behavioural/RAII.md:115
#, fuzzy
msgid ""
"RAII is a common pattern in C++: [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii),\n"
"[wikipedia][wikipedia]."
msgstr ""
"RAIIはC++では一般的なパターンです: [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii)、\n"
"[wikipedia][ウィキペディア]。"

#: src/patterns/behavioural/RAII.md:120
#, fuzzy
msgid ""
"[Style guide entry](https://doc.rust-lang.org/1.0.0/style/ownership/raii."
"html)\n"
"(currently just a placeholder)."
msgstr ""
"[スタイルガイドエントリー](https://doc.rust-lang.org/1.0.0/style/ownership/"
"raii.html)\n"
"(現在は単なるプレースホルダー）。"

#: src/patterns/behavioural/strategy.md:1
#, fuzzy
msgid "# Strategy (aka Policy)"
msgstr "# 戦略"

#: src/patterns/behavioural/strategy.md:5
#, fuzzy
msgid ""
"The [Strategy design pattern](https://en.wikipedia.org/wiki/"
"Strategy_pattern)\n"
"is a technique that enables separation of concerns.\n"
"It also allows to decouple software modules through [Dependency Inversion]"
"(https://en.wikipedia.org/wiki/Dependency_inversion_principle)."
msgstr ""
"ストラテジー・デザイン・パターン](https://en.wikipedia.org/wiki/"
"Strategy_pattern)\n"
"は、関心事の分離を可能にするテクニックです。\n"
"また、[依存関係の反転](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)によって、ソフトウェアモジュールを分離すること"
"もできます。"

#: src/patterns/behavioural/strategy.md:9
#, fuzzy
msgid ""
"The basic idea behind the Strategy pattern is that, given an algorithm "
"solving\n"
"a particular problem, we define only the skeleton of the algorithm at an "
"abstract\n"
"level, and we separate the specific algorithm’s implementation into "
"different parts."
msgstr ""
"Strategyパターンの基本的な考え方は、特定の問題を解くアルゴリズムが与えられた"
"ときに\n"
"特定の問題を解決するアルゴリズムが与えられた場合、抽象的なレベルではアルゴリ"
"ズムの骨組みだけを定義し\n"
"で定義し、具体的なアルゴリズムの実装は別の部分に分離するというものです。"

#: src/patterns/behavioural/strategy.md:13
#, fuzzy
msgid ""
"In this way, a client using the algorithm may choose a specific "
"implementation,\n"
"while the general algorithm workflow remains the same. In other words, the "
"abstract\n"
"specification of the class does not depend on the specific implementation of "
"the\n"
"derived class, but specific implementation must adhere to the abstract "
"specification.\n"
"This is why we call it \"Dependency Inversion\"."
msgstr ""
"このように、アルゴリズムを使用するクライアントは、特定の実装を選択することが"
"できます、\n"
"一方、一般的なアルゴリズムのワークフローは変わりません。言い換えれば\n"
"クラスの抽象仕様は派生クラスの具体的な実装に依存しません。\n"
"しかし、特定の実装は抽象仕様に従わなければなりません。\n"
"これが「依存関係の逆転」と呼ばれる理由です。"

#: src/patterns/behavioural/strategy.md:21
#, fuzzy
msgid ""
"Imagine we are working on a project that generates reports every month.\n"
"We need the reports to be generated in different formats (strategies), e."
"g.,\n"
"in `JSON` or `Plain Text` formats.\n"
"But things vary over time, and we don't know what kind of requirement we may "
"get\n"
"in the future. For example, we may need to generate our report in a "
"completely new\n"
"format, or just modify one of the existing formats."
msgstr ""
"毎月レポートを作成するプロジェクトに取り組んでいるとします。\n"
"レポートをさまざまな形式（ストラテジー）で生成する必要があります、\n"
"JSON`や`Plain Text`形式などです。\n"
"しかし、物事は時間の経過とともに変化します。\n"
"将来どんな要求が来るかわかりません。例えば、まったく新しい形式でレポートを生"
"成する必要があるかもしれません。\n"
"あるいは、既存のフォーマットの1つを変更するだけかもしれません。"

#: src/patterns/behavioural/strategy.md:30
#, fuzzy
msgid ""
"In this example our invariants (or abstractions) are `Formatter` and "
"`Report`, while `Text` and `Json` are our strategy structs. These "
"strategies\n"
"have to implement the `Formatter` trait."
msgstr ""
"この例では、 `Context`、`Formatter`、`Report` が不変量（または抽象化）で"
"す、\n"
"と `Report` で、`Text` と `Json` がストラテジーの構造体です。これらのストラテ"
"ジ\n"
"は `Formatter` 特性を実装する必要があります。"

#: src/patterns/behavioural/strategy.md:33
#, fuzzy
msgid ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"type Data = HashMap<String, u32>;\n"
"\n"
"trait Formatter {\n"
"    fn format(&self, data: &Data, buf: &mut String);\n"
"}\n"
"\n"
"struct Report;\n"
"\n"
"impl Report {\n"
"    // Write should be used but we kept it as String to ignore error "
"handling\n"
"    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
"        // backend operations...\n"
"        let mut data = HashMap::new();\n"
"        data.insert(\"one\".to_string(), 1);\n"
"        data.insert(\"two\".to_string(), 2);\n"
"        // generate report\n"
"        g.format(&data, s);\n"
"    }\n"
"}\n"
"\n"
"struct Text;\n"
"impl Formatter for Text {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        for (k, v) in data {\n"
"            let entry = format!(\"{} {}\\n\", k, v);\n"
"            buf.push_str(&entry);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json;\n"
"impl Formatter for Json {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        buf.push('[');\n"
"        for (k, v) in data.into_iter() {\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
"            buf.push_str(&entry);\n"
"            buf.push(',');\n"
"        }\n"
"        if !data.is_empty() {\n"
"            buf.pop(); // remove extra , at the end\n"
"        }\n"
"        buf.push(']');\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut s = String::from(\"\");\n"
"    Report::generate(Text, &mut s);\n"
"    assert!(s.contains(\"one 1\"));\n"
"    assert!(s.contains(\"two 2\"));\n"
"\n"
"    s.clear(); // reuse the same buffer\n"
"    Report::generate(Json, &mut s);\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"std::collections::HashMapを使用します；\n"
"\n"
"type Data = HashMap<String, u32> ；\n"
"\n"
"trait Formatter {\n"
"    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String)；\n"
"}\n"
"\n"
"struct Report；\n"
"\n"
"impl Report {\n"
"    // Writeを使用すべきですが、エラー処理を無視するためにStringのままにして"
"います。\n"
"    fn generate<T: Formatter>(g: T, s: &amp;mut String) { // バックエンドの操"
"作...\n"
"        // バックエンドの操作\n"
"        mut data = HashMap::new()；\n"
"        data.insert(\"one\".to_string(), 1)；\n"
"        data.insert(\"two\".to_string(), 2)；\n"
"        // レポートを生成\n"
"        g.format(&amp;data, s)；\n"
"    }\n"
"}\n"
"\n"
"struct Text；\n"
"テキスト用フォーマッタ\n"
"    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) { { { (k, v "
"in data)\n"
"        for (k, v) in data { {.\n"
"            let entry = format!(\"{} {} ˶\", k, v)；\n"
"            buf.push_str(&amp;entry)；\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json；\n"
"Json 用のフォーマッタ\n"
"    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) { { buf.\n"
"        buf.push('[')；\n"
"        for (k, v) in data.into_iter() { { {.\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v)；\n"
"            buf.push_str(&amp;entry)；\n"
"            buf.push(',')；\n"
"        }\n"
"        if !data.is_empty() { if !\n"
"            buf.pop(); // 最後の余分な , を削除。\n"
"        }\n"
"        buf.push(']')；\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    mut s = String::from(\"\")；\n"
"    Report::generate(Text, &amp;mut s)；\n"
"    assert!(s.contains(\"one 1\"))；\n"
"    assert!(s.contains(\"two 2\"))；\n"
"\n"
"    s.clear(); // 同じバッファを再利用\n"
"    Report::generate(Json, &amp;mut s)；\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#))；\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#))；\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:97
#, fuzzy
msgid ""
"The main advantage is separation of concerns. For example, in this case "
"`Report`\n"
"does not know anything about specific implementations of `Json` and `Text`,\n"
"whereas the output implementations does not care about how data is "
"preprocessed,\n"
"stored, and fetched. The only thing they have to know is a specific\n"
"trait to implement and its method defining the concrete algorithm "
"implementation processing\n"
"the result, i.e., `Formatter` and `format(...)`."
msgstr ""
"主な利点は関心の分離です。例えば、この場合 `Report`\n"
"は `Json` と `Text` の特定の実装については何も知りません、\n"
"一方、出力の実装はデータがどのように前処理され\n"
"保存され、フェッチされます。彼らが知っていなければならないのは、コンテキスト"
"と、実装する特定の\n"
"つまり、`Formatter` と `run` です。"

#: src/patterns/behavioural/strategy.md:106
#, fuzzy
msgid ""
"For each strategy there must be implemented at least one module, so number "
"of modules\n"
"increases with number of strategies. If there are many strategies to choose "
"from\n"
"then users have to know how strategies differ from one another."
msgstr ""
"各戦略には少なくとも1つのモジュールが実装されていなければならないので、モ"
"ジュールの数は戦略の数だけ増えます。\n"
"は戦略の数だけ増えます。ストラテジーがたくさんある場合\n"
"ストラテジーがたくさんある場合、ユーザーはストラテジーとストラテジーの違いを"
"知らなければなりません。"

#: src/patterns/behavioural/strategy.md:112
#, fuzzy
msgid ""
"In the previous example all strategies are implemented in a single file.\n"
"Ways of providing different strategies includes:"
msgstr ""
"前の例では、すべての戦略は1つのファイルに実装されています。\n"
"異なるストラテジーを提供する方法には次のようなものがあります："

#: src/patterns/behavioural/strategy.md:115
#, fuzzy
msgid ""
"- All in one file (as shown in this example, similar to being separated as "
"modules)\n"
"- Separated as modules, E.g. `formatter::json` module, `formatter::text` "
"module\n"
"- Use compiler feature flags, E.g. `json` feature, `text` feature\n"
"- Separated as crates, E.g. `json` crate, `text` crate"
msgstr ""
"- 一つのファイルにまとめたもの (この例のように、モジュールとして分離したもの"
"と同じです)\n"
"- モジュールとして分離、例 `formatter::json` モジュール、 `formatter::text` "
"モジュール\n"
"- コンパイラの機能フラグを使う (例 `json` 機能、 `text` 機能)\n"
"- クレートとして分離 (例 `json` クレート、 `text` クレート)"

#: src/patterns/behavioural/strategy.md:120
#, fuzzy
msgid ""
"Serde crate is a good example of the `Strategy` pattern in action. Serde "
"allows\n"
"[full customization](https://serde.rs/custom-serialization.html) of the "
"serialization\n"
"behavior by manually implementing `Serialize` and `Deserialize` traits for "
"our\n"
"type. For example, we could easily swap `serde_json` with `serde_cbor` since "
"they\n"
"expose similar methods. Having this makes the helper crate `serde_transcode` "
"much\n"
"more useful and ergonomic."
msgstr ""
"Serdeクレートは `Strategy` パターンが実際に使われている良い例です。Serdeで"
"は\n"
"[完全なカスタマイズ](https://serde.rs/custom-serialization.html) が可能で"
"す。\n"
"シリアライズ動作の[フルカスタマイズ](_COPY_) が可能です。\n"
"を手動で実装することで、シリアライズの動作を完全にカスタマイズすることができ"
"ます。例えば、 `serde_json` と `serde_cbor` を簡単に入れ替えることができま"
"す。\n"
"と入れ替えることができます。これにより、ヘルパー木箱 `serde_transcode` がより"
"便利で人間工学的なものになります。\n"
"をより便利で人間工学的なものにします。"

#: src/patterns/behavioural/strategy.md:127
#, fuzzy
msgid ""
"However, we don't need to use traits in order to design this pattern in Rust."
msgstr ""
"しかし、Rustでこのパターンを設計するためにtraitを使う必要はありません。"

#: src/patterns/behavioural/strategy.md:129
#, fuzzy
msgid ""
"The following toy example demonstrates the idea of the Strategy pattern "
"using Rust\n"
"`closures`:"
msgstr ""
"次のおもちゃの例は、Rustを使ったStrategyパターンのアイデアを示しています。\n"
"closures`です："

#: src/patterns/behavioural/strategy.md:132
#, fuzzy
msgid ""
"```rust\n"
"struct Adder;\n"
"impl Adder {\n"
"    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
"    where\n"
"        F: Fn(u8, u8) -> u8,\n"
"    {\n"
"        f(x, y)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let arith_adder = |x, y| x + y;\n"
"    let bool_adder = |x, y| {\n"
"        if x == 1 || y == 1 {\n"
"            1\n"
"        } else {\n"
"            0\n"
"        }\n"
"    };\n"
"    let custom_adder = |x, y| 2 * x + y;\n"
"\n"
"    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
"    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
"    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"struct Adder；\n"
"impl 加算器 {\n"
"    pub fn add<F>(x: u8, y: u8, f: F) -&gt; u8\n"
"    ここで\n"
"        F: Fn(u8, u8) -&gt; u8、\n"
"    {\n"
"        f(x, y)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let arith_adder = |x, y| x + y；\n"
"    let bool_adder = |x, y| { もし x == 1 || y == 1 ならば\n"
"        if x == 1 || y == 1 {.\n"
"            1\n"
"        } else {\n"
"            0\n"
"        }\n"
"    };\n"
"    let custom_adder = |x, y| 2 * x + y；\n"
"\n"
"    assert_eq!(9, Adder::add(4, 5, arith_adder))；\n"
"    assert_eq!(0, Adder::add(0, 0, bool_adder))；\n"
"    assert_eq!(5, Adder::add(1, 3, custom_adder))；\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:160
#, fuzzy
msgid "In fact, Rust already uses this idea for `Options`'s `map` method:"
msgstr ""
"実際、Rustはすでに `Options` の `map` メソッドでこのアイデアを使っています："

#: src/patterns/behavioural/strategy.md:162
#, fuzzy
msgid ""
"```rust\n"
"fn main() {\n"
"    let val = Some(\"Rust\");\n"
"\n"
"    let len_strategy = |s: &str| s.len();\n"
"    assert_eq!(4, val.map(len_strategy).unwrap());\n"
"\n"
"    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
"    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"fn main() {\n"
"    let val = Some(\"Rust\")；\n"
"\n"
"    let len_strategy = |s: &str| s.len()；\n"
"    assert_eq!(4, val.map(len_strategy).unwrap())；\n"
"\n"
"    let first_byte_strategy = |s: &str| s.bytes().next().unwrap()；\n"
"    assert_eq!(82, val.map(first_byte_strategy).unwrap())；\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:176
#, fuzzy
msgid ""
"- [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [Dependency Injection](https://en.wikipedia.org/wiki/"
"Dependency_injection)\n"
"- [Policy Based Design](https://en.wikipedia.org/wiki/Modern_C+"
"+_Design#Policy-based_design)"
msgstr ""
"- [戦略パターン](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [依存性の注入](https://en.wikipedia.org/wiki/Dependency_injection)\n"
"- [ポリシーベースの設計](https://en.wikipedia.org/wiki/Modern_C+"
"+_Design#Policy-based_design)"

#: src/patterns/behavioural/visitor.md:1
#, fuzzy
msgid "# Visitor"
msgstr "# ビジター"

#: src/patterns/behavioural/visitor.md:5
#, fuzzy
msgid ""
"A visitor encapsulates an algorithm that operates over a heterogeneous\n"
"collection of objects. It allows multiple different algorithms to be "
"written\n"
"over the same data without having to modify the data (or their primary\n"
"behaviour)."
msgstr ""
"ビジターは、異種オブジェクトのコレクションを操作するアルゴリズムをカプセル化"
"します。\n"
"アルゴリズムをカプセル化します。これにより、複数の異なるアルゴリズムを\n"
"を変更することなく、同じデータに対して複数の異なるアルゴリズムを書くことがで"
"きます。\n"
"挙動)を変更することなく、同じデータに対して複数の異なるアルゴリズムを書くこと"
"ができます。"

#: src/patterns/behavioural/visitor.md:10
#, fuzzy
msgid ""
"Furthermore, the visitor pattern allows separating the traversal of\n"
"a collection of objects from the operations performed on each object."
msgstr ""
"さらに、訪問者パターンでは、オブジェクトの集合の走査を、各オブジェクトに対し"
"て実行される操作から分離することができます。\n"
"を分離することができます。"

#: src/patterns/behavioural/visitor.md:15
#, fuzzy
msgid ""
"```rust,ignore\n"
"// The data we will visit\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Expr),\n"
"        Let(Name, Expr),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract visitor\n"
"mod visit {\n"
"    use ast::*;\n"
"\n"
"    pub trait Visitor<T> {\n"
"        fn visit_name(&mut self, n: &Name) -> T;\n"
"        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
"        fn visit_expr(&mut self, e: &Expr) -> T;\n"
"    }\n"
"}\n"
"\n"
"use visit::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - walks the AST interpreting it as "
"code.\n"
"struct Interpreter;\n"
"impl Visitor<i64> for Interpreter {\n"
"    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
"    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
"        match *s {\n"
"            Stmt::Expr(ref e) => self.visit_expr(e),\n"
"            Stmt::Let(..) => unimplemented!(),\n"
"        }\n"
"    }\n"
"\n"
"    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
"        match *e {\n"
"            Expr::IntLit(n) => n,\n"
"            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + self."
"visit_expr(rhs),\n"
"            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - self."
"visit_expr(rhs),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"ラスト,無視\n"
"// 訪問するデータ\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Expr)、\n"
"        Let(Name, Expr)、\n"
"    }\n"
"\n"
"    pub struct 名前 {\n"
"        値：文字列、\n"
"    }\n"
"\n"
"    pub enum Expr { }.\n"
"        IntLit(i64)、\n"
"        Add(Box<Expr>, Box<Expr>)、\n"
"        Sub(Box<Expr>, Box<Expr>)、\n"
"    }\n"
"}\n"
"\n"
"// 抽象ビジター\n"
"mod visit {\n"
"    ast::*を使用します；\n"
"\n"
"    pub trait ビジター<T> {\n"
"        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T；\n"
"        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T；\n"
"        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T；\n"
"    }\n"
"}\n"
"\n"
"use visit::*；\n"
"use ast::*；\n"
"\n"
"// 具体的な実装例 - ASTをコードとして解釈します。\n"
"struct Interpreter；\n"
"impl Visitor<i64> for インタプリタ {.\n"
"    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 { panic!() }.\n"
"    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {\n"
"        マッチ *s {\n"
"            Stmt::Expr(ref e) =&gt; self.visit_expr(e)、\n"
"            Stmt::Let(..) =&gt; 未実装！()、\n"
"        }\n"
"    }\n"
"\n"
"    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {.\n"
"        マッチ *e {\n"
"            Expr::IntLit(n) =&gt; n、\n"
"            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self."
"visit_expr(rhs)、\n"
"            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self."
"visit_expr(rhs)、\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/behavioural/visitor.md:69
#, fuzzy
msgid ""
"One could implement further visitors, for example a type checker, without "
"having\n"
"to modify the AST data."
msgstr ""
"ASTデータを変更することなく、例えば型チェッカーなど、さらなる訪問者を実装する"
"ことができます。\n"
"を実装することができます。"

#: src/patterns/behavioural/visitor.md:74
#, fuzzy
msgid ""
"The visitor pattern is useful anywhere that you want to apply an algorithm "
"to\n"
"heterogeneous data. If data is homogeneous, you can use an iterator-like "
"pattern.\n"
"Using a visitor object (rather than a functional approach) allows the "
"visitor to\n"
"be stateful and thus communicate information between nodes."
msgstr ""
"ビジター・パターンは、異種データにアルゴリズムを適用したい場合に便利です。\n"
"異種データにアルゴリズムを適用したい場合に便利です。データが均質であれば、イ"
"テレータのようなパターンを使うことができます。\n"
"関数型アプローチではなく）ビジター・オブジェクトを使用することで、ビジターは"
"ステートフルになり、ノード間で情報を伝達することができます。\n"
"ステートフルであるため、ノード間で情報を伝達できます。"

#: src/patterns/behavioural/visitor.md:81
#, fuzzy
msgid ""
"It is common for the `visit_*` methods to return void (as opposed to in the\n"
"example). In that case it is possible to factor out the traversal code and "
"share\n"
"it between algorithms (and also to provide noop default methods). In Rust, "
"the\n"
"common way to do this is to provide `walk_*` functions for each datum. For\n"
"example,"
msgstr ""
"visit_*`メソッドがvoidを返すのは一般的です（例とは異なります）。\n"
"を返すのが一般的です。）この場合、トラバーサルコードを分解してアルゴリズム間"
"で共有することができます。\n"
"また、noopデフォルトメソッドを提供することもできます）。Rustでは\n"
"各 datum に対して `walk_*` 関数を提供するのが一般的です。例えば\n"
"例えば"

#: src/patterns/behavioural/visitor.md:87
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
"    match *e {\n"
"        Expr::IntLit(_) => {},\n"
"        Expr::Add(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"        Expr::Sub(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆,無視\n"
"pub fn walk_expr(visitor: &mut Visitor, e: &Expr) { {.\n"
"    e { にマッチ\n"
"        Expr::IntLit(_) => {}、\n"
"        Expr::Add(ref lhs, ref rhs) => {.\n"
"            visitor.visit_expr(lhs)；\n"
"            visitor.visit_expr(rhs)；\n"
"        }\n"
"        Expr::Sub(ref lhs, ref rhs) => { { visitor.visit_expr(lhs); visitor."
"visit_expr(rhs); }.\n"
"            visitor.visit_expr(lhs)；\n"
"            visitor.visit_expr(rhs)；\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/behavioural/visitor.md:103
#, fuzzy
msgid ""
"In other languages (e.g., Java) it is common for data to have an `accept` "
"method\n"
"which performs the same duty."
msgstr ""
"他の言語（例えばJava）では、データには `accept` メソッドがあるのが普通で"
"す。\n"
"メソッドを持つのが一般的です。"

#: src/patterns/behavioural/visitor.md:108
#, fuzzy
msgid "The visitor pattern is a common pattern in most OO languages."
msgstr "訪問者パターンは、ほとんどのOO言語で一般的なパターンです。"

#: src/patterns/behavioural/visitor.md:110
#, fuzzy
msgid "[Wikipedia article](https://en.wikipedia.org/wiki/Visitor_pattern)"
msgstr "[ウィキペディア記事](https://en.wikipedia.org/wiki/Visitor_pattern)"

#: src/patterns/behavioural/visitor.md:112
#, fuzzy
msgid ""
"The [fold](../creational/fold.md) pattern is similar to visitor but "
"produces\n"
"a new version of the visited data structure."
msgstr ""
"fold](../creational/fold.md)パターンはvisitorに似ていますが、訪問したデータ構"
"造の新しいバージョンを生成します。\n"
"を生成します。"

#: src/patterns/creational/intro.md:1
#, fuzzy
msgid "# Creational Patterns"
msgstr "# 創造的パターン"

#: src/patterns/creational/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern):"
msgstr "Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/patterns/creational/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that deal with object creation mechanisms, trying to "
"create objects\n"
"> in a manner suitable to the situation. The basic form of object creation "
"could\n"
"> result in design problems or in added complexity to the design. Creational "
"design\n"
"> patterns solve this problem by somehow controlling this object creation."
msgstr ""
"> オブジェクト生成のメカニズムを扱い、状況に適した方法でオブジェクトを生成し"
"ようとするデザインパターン。\n"
"> 状況に適した方法でオブジェクト生成の基本形は\n"
"> 設計上の問題が発生したり、設計が複雑になったりします。創造的デザイン\n"
"> パターンは、このオブジェクト生成を何らかの方法で制御することで、この問題を"
"解決します。"

#: src/patterns/creational/builder.md:1
#, fuzzy
msgid "# Builder"
msgstr "# ビルダー"

#: src/patterns/creational/builder.md:5
#, fuzzy
msgid "Construct an object with calls to a builder helper."
msgstr "ビルダー・ヘルパーの呼び出しでオブジェクトを構築します。"

#: src/patterns/creational/builder.md:9
#, fuzzy
msgid ""
"```rust\n"
"#[derive(Debug, PartialEq)]\n"
"pub struct Foo {\n"
"    // Lots of complicated fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl Foo {\n"
"    // This method will help users to discover the builder\n"
"    pub fn builder() -> FooBuilder {\n"
"        FooBuilder::default()\n"
"    }\n"
"}\n"
"\n"
"#[derive(Default)]\n"
"pub struct FooBuilder {\n"
"    // Probably lots of optional fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl FooBuilder {\n"
"    pub fn new(/* ... */) -> FooBuilder {\n"
"        // Set the minimally required fields of Foo.\n"
"        FooBuilder {\n"
"            bar: String::from(\"X\"),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(mut self, bar: String) -> FooBuilder {\n"
"        // Set the name on the builder itself, and return the builder by "
"value.\n"
"        self.bar = bar;\n"
"        self\n"
"    }\n"
"\n"
"    // If we can get away with not consuming the Builder here, that is an\n"
"    // advantage. It means we can use the FooBuilder as a template for "
"constructing\n"
"    // many Foos.\n"
"    pub fn build(self) -> Foo {\n"
"        // Create a Foo from the FooBuilder, applying all settings in "
"FooBuilder\n"
"        // to Foo.\n"
"        Foo { bar: self.bar }\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn builder_test() {\n"
"    let foo = Foo {\n"
"        bar: String::from(\"Y\"),\n"
"    };\n"
"    let foo_from_builder: Foo = FooBuilder::new().name(String::from(\"Y\"))."
"build();\n"
"    assert_eq!(foo, foo_from_builder);\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"#[derive(Debug, PartialEq)] です。\n"
"pub struct Foo {\n"
"    // 複雑なフィールドがたくさんあります。\n"
"    bar：文字列、\n"
"}\n"
"\n"
"impl Foo {\n"
"    // このメソッドは、ユーザがビルダを発見するのに役立ちます。\n"
"    pub fn builder() -> FooBuilder { FooBuilder::default()\n"
"        FooBuilder::default()\n"
"    }\n"
"}\n"
"\n"
"#[derive(Default)]\n"
"pub struct FooBuilder {\n"
"    // おそらくオプションのフィールドがたくさんあります。\n"
"    bar：文字列、\n"
"}\n"
"\n"
"impl FooBuilder { 以下のようになります。\n"
"    pub fn new(/* ... */) -> FooBuilder { // Foo の最低限必要なフィールドを設"
"定します。\n"
"        // Foo の最低限必要なフィールドを設定します。\n"
"        FooBuilder {\n"
"            bar：String::from(\"X\")、\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(mut self, bar: String) -> FooBuilder {.\n"
"        // ビルダ自身に名前を設定し、その値でビルダを返します。\n"
"        self.bar = bar；\n"
"        self\n"
"    }\n"
"\n"
"    ここでビルダーを消費せずに済むなら、それは // 利点です。\n"
"    // 利点です。つまり、FooBuilderを多くのFooを構築するためのテンプレートと"
"して使えるということです。\n"
"    // 多くのFooを構築するためのテンプレートとして使えるということです。\n"
"    pub fn build(self) -> Foo { // FooからFooを生成します。\n"
"        FooBuilder のすべての設定を Foo に適用して、 // FooBuilder から Foo "
"を作成します。\n"
"        // を Foo に適用します。\n"
"        Foo { bar: self.bar }.\n"
"    }\n"
"}\n"
"\n"
"#テスト\n"
"fn builder_test() {\n"
"    let foo = Foo {\n"
"        bar：String::from(\"Y\")、\n"
"    };\n"
"    let foo_from_builder：Foo = FooBuilder::new().name(String::from(\"Y\"))."
"build()；\n"
"    assert_eq!(foo, foo_from_builder)；\n"
"}\n"
"```"

#: src/patterns/creational/builder.md:65
#, fuzzy
msgid ""
"Useful when you would otherwise require many constructors or where\n"
"construction has side effects."
msgstr ""
"多くのコンストラクタが必要な場合や、コンストラクタの構築に副作用がある場合に"
"便利です。\n"
"の構築に副作用がある場合などに便利です。"

#: src/patterns/creational/builder.md:70
#, fuzzy
msgid "Separates methods for building from other methods."
msgstr "構築のためのメソッドを他のメソッドから分離します。"

#: src/patterns/creational/builder.md:72
#, fuzzy
msgid "Prevents proliferation of constructors."
msgstr "コンストラクタの増殖を防ぎます。"

#: src/patterns/creational/builder.md:74
#, fuzzy
msgid ""
"Can be used for one-liner initialisation as well as more complex "
"construction."
msgstr "ワンライナーの初期化にも、より複雑な構築にも使用できます。"

#: src/patterns/creational/builder.md:78
#, fuzzy
msgid ""
"More complex than creating a struct object directly, or a simple "
"constructor\n"
"function."
msgstr ""
"構造体オブジェクトを直接作成したり、単純なコンストラクタ関数を使用するよりも"
"複雑です。\n"
"関数よりも複雑です。"

#: src/patterns/creational/builder.md:83
#, fuzzy
msgid ""
"This pattern is seen more frequently in Rust (and for simpler objects) than "
"in\n"
"many other languages because Rust lacks overloading. Since you can only have "
"a\n"
"single method with a given name, having multiple constructors is less nice "
"in\n"
"Rust than in C++, Java, or others."
msgstr ""
"Rustにはオーバーロードがないため、このパターンは他の多くの言語よりも頻繁に見"
"られます。\n"
"なぜならRustにはオーバーロードがないからです。というのも、Rust にはオーバー"
"ロードがないからです。\n"
"コンストラクタを複数持つことは、C++ や Java などと比べて\n"
"Rust では複数のコンストラクタを持つことは、C++ や Java などと比べてあまり良い"
"ことではありません。"

#: src/patterns/creational/builder.md:88
#, fuzzy
msgid ""
"This pattern is often used where the builder object is useful in its own "
"right,\n"
"rather than being just a builder. For example, see\n"
"[`std::process::Command`](https://doc.rust-lang.org/std/process/struct."
"Command.html)\n"
"is a builder for [`Child`](https://doc.rust-lang.org/std/process/struct."
"Child.html)\n"
"(a process). In these cases, the `T` and `TBuilder` naming pattern is not "
"used."
msgstr ""
"このパターンは、ビルダーオブジェクトがそれ自体で有用である場合によく使われま"
"す、\n"
"このパターンは、ビルダーオブジェクトが単なるビルダーとしてではなく、それ自体"
"として有用である場合によく使われます。例えば\n"
"[std::process::コマンド`](https://doc.rust-lang.org/std/process/struct."
"Command.html)\n"
"は [`Child`](https://doc.rust-lang.org/std/process/struct.Child.html) のビル"
"ダーです。\n"
"(プロセス) のビルダーです。このような場合、 `T` と `TBuilder` の命名パターン"
"は使用されません。"

#: src/patterns/creational/builder.md:94
#, fuzzy
msgid ""
"The example takes and returns the builder by value. It is often more "
"ergonomic\n"
"(and more efficient) to take and return the builder as a mutable reference. "
"The\n"
"borrow checker makes this work naturally. This approach has the advantage "
"that\n"
"one can write code like"
msgstr ""
"この例ではビルダーを値で受け取り返します。多くの場合\n"
"(より効率的です）。この\n"
"ボローチェッカーはこれを自然に動作させます。このアプローチには\n"
"のようなコードを書くことができます。"

#: src/patterns/creational/builder.md:99
#, fuzzy
msgid ""
"```rust,ignore\n"
"let mut fb = FooBuilder::new();\n"
"fb.a();\n"
"fb.b();\n"
"let f = fb.build();\n"
"```"
msgstr ""
"錆、無視\n"
"let mut fb = FooBuilder::new()；\n"
"fb.a()；\n"
"fb.b()；\n"
"let f = fb.build()；\n"
"```"

#: src/patterns/creational/builder.md:106
#, fuzzy
msgid "as well as the `FooBuilder::new().a().b().build()` style."
msgstr ""
"と同じように、`FooBuilder::new().a().b().build()`というスタイルもあります。"

#: src/patterns/creational/builder.md:110
#, fuzzy
msgid ""
"- [Description in the style guide](https://web.archive.org/"
"web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders."
"html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder), a crate for "
"automatically\n"
"  implementing this pattern while avoiding the boilerplate.\n"
"- [Constructor pattern](../../idioms/ctor.md) for when construction is "
"simpler.\n"
"- [Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/"
"Builder_pattern)\n"
"- [Construction of complex values](https://web.archive.org/"
"web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety."
"html#c-builder)"
msgstr ""
"- [スタイルガイドの説明](https://web.archive.org/web/20210104103100/https://"
"doc.rust-lang.org/1.12.0/style/ownership/builders.html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder)は、このパターンを"
"自動的に実装するためのクレートです。\n"
"  このパターンを自動的に実装するためのクレートです。\n"
"- [コンストラクタのパターン](../../idioms/ctor.md) は、よりシンプルに構築する"
"ためのものです。\n"
"- [Builder パターン (wikipedia)](https://en.wikipedia.org/wiki/"
"Builder_pattern)\n"
"- [複雑な値の構築](https://web.archive.org/web/20210104103000/https://rust-"
"lang.github.io/api-guidelines/type-safety.html#c-builder)"

#: src/patterns/creational/fold.md:1
#, fuzzy
msgid "# Fold"
msgstr "# フォールド"

#: src/patterns/creational/fold.md:5
#, fuzzy
msgid ""
"Run an algorithm over each item in a collection of data to create a new "
"item,\n"
"thus creating a whole new collection."
msgstr ""
"データのコレクション内の各項目に対してアルゴリズムを実行し、新しい項目を作成"
"します、\n"
"こうして、まったく新しいコレクションを作成します。"

#: src/patterns/creational/fold.md:8
#, fuzzy
msgid ""
"The etymology here is unclear to me. The terms 'fold' and 'folder' are used\n"
"in the Rust compiler, although it appears to me to be more like a map than "
"a\n"
"fold in the usual sense. See the discussion below for more details."
msgstr ""
"この語源は私には不明です。フォールド」と「フォルダ」という用語は、Rustコンパ"
"イラで使われています。\n"
"Rustコンパイラーでは「fold」と「folder」という用語が使われています。\n"
"よりもマップに近いように見えます。詳しくは以下の議論を参照してください。"

#: src/patterns/creational/fold.md:14
#, fuzzy
msgid ""
"```rust,ignore\n"
"// The data we will fold, a simple AST.\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>),\n"
"        Let(Box<Name>, Box<Expr>),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract folder\n"
"mod fold {\n"
"    use ast::*;\n"
"\n"
"    pub trait Folder {\n"
"        // A leaf node just returns the node itself. In some cases, we can "
"do this\n"
"        // to inner nodes too.\n"
"        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
"        // Create a new inner node by folding its children.\n"
"        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
"            match *s {\n"
"                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),\n"
"                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e))),\n"
"            }\n"
"        }\n"
"        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
"    }\n"
"}\n"
"\n"
"use fold::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - renames every name to 'foo'.\n"
"struct Renamer;\n"
"impl Folder for Renamer {\n"
"    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
"        Box::new(Name { value: \"foo\".to_owned() })\n"
"    }\n"
"    // Use the default methods for the other nodes.\n"
"}\n"
"```"
msgstr ""
"ラスト,無視\n"
"// 折り畳むデータ、単純なAST。\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>)、\n"
"        Let(Box<Name>, Box<Expr>)、\n"
"    }\n"
"\n"
"    pub struct 名前 {\n"
"        値：文字列、\n"
"    }\n"
"\n"
"    pub enum Expr { }.\n"
"        IntLit(i64)、\n"
"        Add(Box<Expr>, Box<Expr>)、\n"
"        Sub(Box<Expr>, Box<Expr>)、\n"
"    }\n"
"}\n"
"\n"
"// 抽象フォルダ\n"
"mod fold {\n"
"    use ast::*；\n"
"\n"
"    pub trait フォルダ {\n"
"        // リーフノードは、単にノード自身を返します。場合によっては\n"
"        // 内部ノードにも\n"
"        fn fold_name(&amp;mut self, n: Box<Name>) -&gt; Box<Name> { n }.\n"
"        // 子ノードを折りたたんで新しい内部ノードを作成します。\n"
"        fn fold_stmt(&amp;mut self, s: Box<Stmt>) -&gt; Box<Stmt> {.\n"
"            マッチ *s {\n"
"                Stmt::Expr(e) =&gt; Box::new(Stmt::Expr(self."
"fold_expr(e)))、\n"
"                Stmt::Let(n, e) =&gt; Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e)))、\n"
"            }\n"
"        }\n"
"        fn fold_expr(&amp;mut self, e: Box<Expr>) -&gt; Box<Expr> { ...}\n"
"    }\n"
"}\n"
"\n"
"use fold::*；\n"
"use ast::*；\n"
"\n"
"// 具体的な実装例 - すべての名前を 'foo' にリネームします。\n"
"struct Renamer；\n"
"リネーム用フォルダ\n"
"    fn fold_name(&amp;mut self, n: Box<Name>) -&gt; Box<Name> {.\n"
"        Box::new(Name { value：\"foo\".to_owned() })\n"
"    }\n"
"    // 他のノードにはデフォルトのメソッドを使用します。\n"
"}\n"
"```"

#: src/patterns/creational/fold.md:65
#, fuzzy
msgid ""
"The result of running the `Renamer` on an AST is a new AST identical to the "
"old\n"
"one, but with every name changed to `foo`. A real life folder might have "
"some\n"
"state preserved between nodes in the struct itself."
msgstr ""
"ASTに対して `Renamer` を実行した結果は、古いASTと同じ新しいASTになります。\n"
"ですが、すべての名前が `foo` に変更されています。実際のフォルダでは\n"
"構造体のノード間で保存されます。"

#: src/patterns/creational/fold.md:69
#, fuzzy
msgid ""
"A folder can also be defined to map one data structure to a different (but\n"
"usually similar) data structure. For example, we could fold an AST into a "
"HIR\n"
"tree (HIR stands for high-level intermediate representation)."
msgstr ""
"フォルダーは、あるデータ構造を別の（しかし通常は類似した）データ構造にマッピ"
"ングするために定義することもできます。\n"
"通常は似たような）データ構造にマッピングするために定義することもできます。例"
"えば、ASTをHIR\n"
"ツリーに折り畳むことができます（HIRは高水準中間表現の略です）。"

#: src/patterns/creational/fold.md:75
#, fuzzy
msgid ""
"It is common to want to map a data structure by performing some operation "
"on\n"
"each node in the structure. For simple operations on simple data "
"structures,\n"
"this can be done using `Iterator::map`. For more complex operations, "
"perhaps\n"
"where earlier nodes can affect the operation on later nodes, or where "
"iteration\n"
"over the data structure is non-trivial, using the fold pattern is more\n"
"appropriate."
msgstr ""
"データ構造内の各ノードに対して何らかの操作を行うことで、データ構造をマッピン"
"グしたいことはよくあることです。\n"
"構造体の各ノードに対して何らかの操作を実行することで単純なデータ構造に対する"
"単純な操作の場合\n"
"これは `Iterator::map` を使って行うことができます。より複雑な操作の場合は\n"
"前のノードが後のノードの操作に影響するような複雑な操作や、データ構造に対する"
"反復が\n"
"より複雑な操作の場合は、fold パターンを使用するのが適切です。\n"
"より適切です。"

#: src/patterns/creational/fold.md:82
#, fuzzy
msgid ""
"Like the visitor pattern, the fold pattern allows us to separate traversal "
"of a\n"
"data structure from the operations performed to each node."
msgstr ""
"visitorパターンと同様に、foldパターンでもデータ構造の走査を各ノードに対して行"
"われる操作から分離することができます。\n"
"データ構造の走査を各ノードに対する操作から分離することができます。"

#: src/patterns/creational/fold.md:87
#, fuzzy
msgid ""
"Mapping data structures in this fashion is common in functional languages. "
"In OO\n"
"languages, it would be more common to mutate the data structure in place. "
"The\n"
"'functional' approach is common in Rust, mostly due to the preference for\n"
"immutability. Using fresh data structures, rather than mutating old ones, "
"makes\n"
"reasoning about the code easier in most circumstances."
msgstr ""
"このような方法でデータ構造をマッピングすることは、関数型言語では一般的です。"
"OO\n"
"言語では、データ構造をその場で変異させるのが一般的でしょう。関数型」アプロー"
"チは\n"
"Rustでは「関数型」アプローチが一般的です。\n"
"不変性を好むためです。古いデータ構造を変異させるのではなく、新しいデータ構造"
"を使用することで、ほとんどの状況でコードに関する推論が容易になります。\n"
"ほとんどの場合、コードに関する推論が容易になります。"

#: src/patterns/creational/fold.md:93
#, fuzzy
msgid ""
"The trade-off between efficiency and reusability can be tweaked by changing "
"how\n"
"nodes are accepted by the `fold_*` methods."
msgstr ""
"効率と再利用性のトレードオフは、`fold_*` メソッドでノードを受け入れる方法を変"
"更することで調整できます。\n"
"メソッドがどのようにノードを受け入れるかを変更することで、効率と再利用性のト"
"レードオフを調整することができます。"

#: src/patterns/creational/fold.md:96
#, fuzzy
msgid ""
"In the above example we operate on `Box` pointers. Since these own their "
"data\n"
"exclusively, the original copy of the data structure cannot be re-used. On "
"the\n"
"other hand if a node is not changed, reusing it is very efficient."
msgstr ""
"上の例では `Box` ポインタを操作しています。これらはそのデータ\n"
"を排他的に所有するため、データ構造の元のコピーを再利用することはできません。"
"一方\n"
"一方、ノードが変更されなければ、それを再利用することは非常に効率的です。"

#: src/patterns/creational/fold.md:100
#, fuzzy
msgid ""
"If we were to operate on borrowed references, the original data structure "
"can be\n"
"reused; however, a node must be cloned even if unchanged, which can be\n"
"expensive."
msgstr ""
"借りてきた参照を操作するのであれば、元のデータ構造を再利用することができま"
"す。\n"
"しかし、ノードは変更されていなくてもクローン化する必要があり、コストがかかり"
"ます。\n"
"高価になります。"

#: src/patterns/creational/fold.md:104
#, fuzzy
msgid ""
"Using a reference counted pointer gives the best of both worlds - we can "
"reuse\n"
"the original data structure, and we don't need to clone unchanged nodes. "
"However,\n"
"they are less ergonomic to use and mean that the data structures cannot be\n"
"mutable."
msgstr ""
"参照カウントされたポインタを使用すると、元のデータ構造を再利用でき、変更され"
"ていないノードをクローンする必要がないため、両方の利点が得られます。\n"
"元のデータ構造を再利用でき、変更されていないノードをクローンする必要がありま"
"せん。しかし\n"
"これらは人間工学的に使いにくく、データ構造を変更できないことを意味します。\n"
"を変更できないことを意味します。"

#: src/patterns/creational/fold.md:111
#, fuzzy
msgid ""
"Iterators have a `fold` method, however this folds a data structure into a\n"
"value, rather than into a new data structure. An iterator's `map` is more "
"like\n"
"this fold pattern."
msgstr ""
"イテレーターには `fold` メソッドがありますが、これはデータ構造を新しいデータ"
"構造にフォールドするのではありません。\n"
"値に折り返します。イテレータの `map` は次のようなものです。\n"
"この折りたたみパターンに似ています。"

#: src/patterns/creational/fold.md:115
#, fuzzy
msgid ""
"In other languages, fold is usually used in the sense of Rust's iterators,\n"
"rather than this pattern. Some functional languages have powerful constructs "
"for\n"
"performing flexible maps over data structures."
msgstr ""
"他の言語では、foldは通常Rustのイテレータの意味で使われます、\n"
"のような意味で使われます。関数型言語の中には、データ構造に対して柔軟なマップ"
"を行うための強力な\n"
"があります。"

#: src/patterns/creational/fold.md:119
#, fuzzy
msgid ""
"The [visitor](../behavioural/visitor.md) pattern is closely related to "
"fold.\n"
"They share the concept of walking a data structure performing an operation "
"on\n"
"each node. However, the visitor does not create a new data structure nor "
"consume\n"
"the old one."
msgstr ""
"visitor](../behavioural/visitor.md)パターンはfoldと密接に関連しています。\n"
"この2つのパターンは、データ構造を歩きながら各ノードに対して\n"
"という概念を共有しています。しかし、visitorは新しいデータ構造を作成したり、古"
"いデータ構造を消費したりはしません。\n"
"を消費することはありません。"

#: src/patterns/structural/intro.md:1
#, fuzzy
msgid "# Structural Patterns"
msgstr "# ♪構造パターン"

#: src/patterns/structural/intro.md:3
#, fuzzy
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern):"
msgstr "Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern)より："

#: src/patterns/structural/intro.md:5
#, fuzzy
msgid ""
"> Design patterns that ease the design by identifying a simple way to "
"realize relationships\n"
"> among entities."
msgstr ""
"> エンティティ間の関係を実現する簡単な方法を特定することで、設計を容易にする"
"デザインパターン。\n"
"> エンティティ間の"

#: src/patterns/structural/compose-structs.md:1
msgid "# Struct decomposition for independent borrowing"
msgstr ""

#: src/patterns/structural/compose-structs.md:5
#, fuzzy
msgid ""
"Sometimes a large struct will cause issues with the borrow checker - "
"although\n"
"fields can be borrowed independently, sometimes the whole struct ends up "
"being\n"
"used at once, preventing other uses. A solution might be to decompose the "
"struct\n"
"into several smaller structs. Then compose these together into the original\n"
"struct. Then each struct can be borrowed separately and have more flexible\n"
"behaviour."
msgstr ""
"大きな構造体では、借用チェッカーで問題が発生することがあります。\n"
"フィールドは個別に借用できますが、構造体全体が一度に使用されてしまうことがあ"
"ります。\n"
"が一度に使用されてしまい、他の使用が妨げられることがあります。解決策として"
"は、構造体\n"
"を複数の小さな構造体に分解することです。次に、これらを元の\n"
"構造体にまとめます。そうすれば、各構造体を個別に借用でき、より柔軟な動作が可"
"能になります。\n"
"振る舞いができるようになります。"

#: src/patterns/structural/compose-structs.md:12
#, fuzzy
msgid ""
"This will often lead to a better design in other ways: applying this design\n"
"pattern often reveals smaller units of functionality."
msgstr ""
"このデザイン・パターンを適用することで、より小さな機能単位が明らかになること"
"がよくあります。\n"
"このデザイン・パターンを適用することで、機能の単位が小さくなることがよくあり"
"ます。"

#: src/patterns/structural/compose-structs.md:17
#, fuzzy
msgid ""
"Here is a contrived example of where the borrow checker foils us in our plan "
"to\n"
"use a struct:"
msgstr ""
"ここでは、借用チェッカーが次のような計画で失敗した例を示します。\n"
"構造体を使用する計画で失敗した例です："

#: src/patterns/structural/compose-structs.md:20
msgid ""
"```rust\n"
"struct Database {\n"
"    connection_string: String,\n"
"    timeout: u32,\n"
"    pool_size: u32,\n"
"}\n"
"\n"
"fn print_database(database: &Database) {\n"
"    println!(\"Connection string: {}\", database.connection_string);\n"
"    println!(\"Timeout: {}\", database.timeout);\n"
"    println!(\"Pool size: {}\", database.pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut db = Database {\n"
"        connection_string: \"initial string\".to_string(),\n"
"        timeout: 30,\n"
"        pool_size: 100,\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(&db);  // Immutable borrow of `db` happens here\n"
"    // *connection_string = \"new string\".to_string();  // Mutable borrow "
"is used\n"
"                                                       // here\n"
"}\n"
"```"
msgstr ""

#: src/patterns/structural/compose-structs.md:47
#, fuzzy
msgid ""
"We can apply this design pattern and refactor `Database` into three smaller\n"
"structs, thus solving the borrow checking issue:"
msgstr ""
"このデザインパターンを適用して、`A`を2つの小さな構造体にリファクタリングする"
"ことができます。\n"
"にリファクタリングすることができます："

#: src/patterns/structural/compose-structs.md:50
msgid ""
"```rust\n"
"// Database is now composed of three structs - ConnectionString, Timeout and "
"PoolSize.\n"
"// Let's decompose it into smaller structs\n"
"#[derive(Debug, Clone)]\n"
"struct ConnectionString(String);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct Timeout(u32);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct PoolSize(u32);\n"
"\n"
"// We then compose these smaller structs back into `Database`\n"
"struct Database {\n"
"    connection_string: ConnectionString,\n"
"    timeout: Timeout,\n"
"    pool_size: PoolSize,\n"
"}\n"
"\n"
"// print_database can then take ConnectionString, Timeout and Poolsize "
"struct instead\n"
"fn print_database(connection_str: ConnectionString, \n"
"                  timeout: Timeout, \n"
"                  pool_size: PoolSize) {\n"
"    println!(\"Connection string: {:?}\", connection_str);\n"
"    println!(\"Timeout: {:?}\", timeout);\n"
"    println!(\"Pool size: {:?}\", pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    // Initialize the Database with the three structs\n"
"    let mut db = Database {\n"
"        connection_string: ConnectionString(\"localhost\".to_string()),\n"
"        timeout: Timeout(30),\n"
"        pool_size: PoolSize(100),\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
"    *connection_string = ConnectionString(\"new string\".to_string());\n"
"}\n"
"```"
msgstr ""

#: src/patterns/structural/compose-structs.md:94
msgid ""
"This pattern is most useful, when you have a struct that ended up with a lot "
"of\n"
"fields that you want to borrow independently. Thus having a more flexible\n"
"behaviour in the end."
msgstr ""

#: src/patterns/structural/compose-structs.md:100
#, fuzzy
msgid ""
"Decomposition of structs lets you work around limitations in the borrow "
"checker.\n"
"And it often produces a better design."
msgstr "借入チェッカーの制限を回避することができます。"

#: src/patterns/structural/compose-structs.md:105
#, fuzzy
msgid ""
"It can lead to more verbose code. And sometimes, the smaller structs are "
"not\n"
"good abstractions, and so we end up with a worse design. That is probably a\n"
"'code smell', indicating that the program should be refactored in some way."
msgstr ""
"小さな構造体が良い抽象化でないために、より悪い設計になってしまうこともありま"
"す。\n"
"になってしまうことがあります。これはおそらく「コード臭」であり、プログラムを"
"何らかの方法でリファクタリングする必要があることを示します。\n"
"何らかの方法でリファクタリングする必要があることを示します。"

#: src/patterns/structural/compose-structs.md:111
#, fuzzy
msgid ""
"This pattern is not required in languages that don't have a borrow checker, "
"so\n"
"in that sense is unique to Rust. However, making smaller units of "
"functionality\n"
"often leads to cleaner code: a widely acknowledged principle of software\n"
"engineering, independent of the language."
msgstr ""
"このパターンは、借用チェッカーを持たない言語では必要ありません。\n"
"その意味ではRust独自のものです。しかし、機能の単位を小さくすると\n"
"ソフトウェア工学の原則としては、言語とは関係なく広く認められています。\n"
"ソフトウェア工学の原則であり、言語とは無関係です。"

#: src/patterns/structural/compose-structs.md:116
#, fuzzy
msgid ""
"This pattern relies on Rust's borrow checker to be able to borrow fields\n"
"independently of each other. In the example, the borrow checker knows that "
"`a.b`\n"
"and `a.c` are distinct and can be borrowed independently, it does not try "
"to\n"
"borrow all of `a`, which would make this pattern useless."
msgstr ""
"このパターンは、Rustのボローン・チェッカーがフィールドを互いに独立して借用で"
"きることに依存しています。\n"
"を互いに独立に借用できるようにするためです。この例では、借用チェッカーは `a."
"b` と `a.c` が別個のものであり、独立して借用できることを知っています。\n"
"と `a.c` は別物であり、独立して借用できることを知っています。\n"
"a` のすべてを借用しようとはしません。"

#: src/patterns/structural/small-crates.md:1
#, fuzzy
msgid "# Prefer small crates"
msgstr "# 小さな木箱を好む"

#: src/patterns/structural/small-crates.md:5
#, fuzzy
msgid "Prefer small crates that do one thing well."
msgstr "1つのことがよくできる小型のクレートを好みます。"

#: src/patterns/structural/small-crates.md:7
#, fuzzy
msgid ""
"Cargo and crates.io make it easy to add third-party libraries, much more so "
"than\n"
"in say C or C++. Moreover, since packages on crates.io cannot be edited or "
"removed\n"
"after publication, any build that works now should continue to work in the "
"future.\n"
"We should take advantage of this tooling, and use smaller, more fine-grained "
"dependencies."
msgstr ""
"Cargoとcrates.ioは、サードパーティ・ライブラリの追加を、CやC++よりもはるかに"
"簡単にします。\n"
"CやC++よりもずっと。さらに、crates.io上のパッケージは、公開後に編集したり削除"
"したりすることができないので\n"
"また、crates.io上のパッケージは公開後に編集したり削除したりすることができない"
"ので、現在動作しているビルドは将来も動作し続けるはずです。\n"
"私たちはこのツールを活用し、より小さく、より細かい依存関係を使うべきです。"

#: src/patterns/structural/small-crates.md:14
#, fuzzy
msgid ""
"- Small crates are easier to understand, and encourage more modular code.\n"
"- Crates allow for re-using code between projects.\n"
"  For example, the `url` crate was developed as part of the Servo browser "
"engine,\n"
"  but has since found wide use outside the project.\n"
"- Since the compilation unit\n"
"  of Rust is the crate, splitting a project into multiple crates can allow "
"more of\n"
"  the code to be built in parallel."
msgstr ""
"- 小さなクレートは理解しやすく、よりモジュール化されたコードを促進します。\n"
"- クレートはプロジェクト間でのコードの再利用を可能にします。\n"
"  例えば、`url`クレートはServoブラウザエンジンの一部として開発されました、\n"
"  はServoブラウザエンジンの一部として開発されました。\n"
"- Rustのコンパイル単位は\n"
"  Rustのコンパイル単位はクレートなので、プロジェクトを複数のクレートに分割す"
"ることで、より多くのコードを並列にビルドすることができます。\n"
"  を並列にビルドすることができます。"

#: src/patterns/structural/small-crates.md:24
#, fuzzy
msgid ""
"- This can lead to \"dependency hell\", when a project depends on multiple "
"conflicting\n"
"  versions of a crate at the same time. For example, the `url` crate has "
"both versions\n"
"  1.0 and 0.5. Since the `Url` from `url:1.0` and the `Url` from `url:0.5` "
"are\n"
"  different types, an HTTP client that uses `url:0.5` would not accept `Url` "
"values\n"
"  from a web scraper that uses `url:1.0`.\n"
"- Packages on crates.io are not curated. A crate may be poorly written, "
"have\n"
"  unhelpful documentation, or be outright malicious.\n"
"- Two small crates may be less optimized than one large one, since the "
"compiler\n"
"  does not perform link-time optimization (LTO) by default."
msgstr ""
"- これは「依存性地獄」につながる可能性があります。\n"
"  依存地獄 \"になる可能性があります。例えば、`url`クレートにはバージョン\n"
"  1.0 と 0.5 があります。url:1.0`の `Url` と `url:0.5` の `Url` はタイプが異"
"なるため、`url:1.0` を使用する HTTP クライアントは `Url` を使用することができ"
"ません。\n"
"  の `Url` は異なる型なので、`url:0.5` を使用する HTTP クライアントは `Url` "
"値を受け付けません。\n"
"  を使用する HTTP クライアントは `url:1.0` を使用するウェブスクレーパーから"
"の `Url` 値を受け付けません。\n"
"- crates.io のパッケージはキュレーションされていません。crate.ioのパッケージ"
"はキュレーションされていません。\n"
"  助けにならないドキュメントがあったり、悪意があったりします。\n"
"- コンパイラはリンク時最適化(Link-time Optimization)を行わないので、2つの小さ"
"なクレートは1つの大きなクレートよりも最適化されていないかもしれません。\n"
"  はデフォルトでリンク時最適化（LTO）を実行しないからです。"

#: src/patterns/structural/small-crates.md:36
#, fuzzy
msgid ""
"The [`url`](https://crates.io/crates/url) crate provides tools for working "
"with\n"
"URLs."
msgstr ""
"url`](https://crates.io/crates/url)クレートは\n"
"ツールを提供します。"

#: src/patterns/structural/small-crates.md:39
#, fuzzy
msgid ""
"The [`num_cpus`](https://crates.io/crates/num_cpus) crate provides a "
"function to\n"
"query the number of CPUs on a machine."
msgstr ""
"num_cpus`](https://crates.io/crates/num_cpus)クレートはマシンのCPU数を問い合"
"わせる関数を提供します。\n"
"関数を提供します。"

#: src/patterns/structural/small-crates.md:42
#, fuzzy
msgid ""
"The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"for converting `&T` to `&[T]`. (Historical example)"
msgstr ""
"ref_slice`](https://crates.io/crates/ref_slice) は `&T` を `&[T]` に変換する"
"関数を提供します。\n"
"を提供します。"

#: src/patterns/structural/small-crates.md:47
#, fuzzy
msgid "- [crates.io: The Rust community crate host](https://crates.io/)"
msgstr "- [crates.io: Rustコミュニティのクレートホスト](https://crates.io/)"

#: src/patterns/structural/unsafe-mods.md:1
#, fuzzy
msgid "# Contain unsafety in small modules"
msgstr "# 安全でないものを小さなモジュールに閉じ込める"

#: src/patterns/structural/unsafe-mods.md:5
#, fuzzy
msgid ""
"If you have `unsafe` code, create the smallest possible module that can "
"uphold\n"
"the needed invariants to build a minimal safe interface upon the unsafety. "
"Embed\n"
"this into a larger module that contains only safe code and presents an "
"ergonomic\n"
"interface. Note that the outer module can contain unsafe functions and "
"methods\n"
"that call directly into the unsafe code. Users may use this to gain speed "
"benefits."
msgstr ""
"安全でないコードがある場合、安全でないコードの上に最小限の安全なインターフェ"
"イスを構築するために、必要な不変性を保持できる可能な限り小さなモジュールを作"
"成します。\n"
"安全でないコードに最小限の安全なインターフェイスを構築するために必要な不変量"
"を維持できる、可能な限り小さなモジュールを作ってください。これを\n"
"これを、安全なコードだけを含み、人間工学的なインターフェイスを持つ、より大き"
"なモジュールに組み込んでください。\n"
"インターフェースを提供します。外側のモジュールには、安全でないコードに直接呼"
"び出す安全でない関数やメソッド\n"
"を含むことができることに注意してください。ユーザはこれを使用して、スピードの"
"利点を得ることができます。"

#: src/patterns/structural/unsafe-mods.md:13
#, fuzzy
msgid ""
"- This restricts the unsafe code that must be audited\n"
"- Writing the outer module is much easier, since you can count on the "
"guarantees\n"
"  of the inner module"
msgstr ""
"- これにより、監査が必要な安全でないコードが制限されます。\n"
"- アウター・モジュールを書くのはずっと簡単です。\n"
"  内部モジュールの"

#: src/patterns/structural/unsafe-mods.md:19
#, fuzzy
msgid ""
"- Sometimes, it may be hard to find a suitable interface.\n"
"- The abstraction may introduce inefficiencies."
msgstr ""
"- 適切なインターフェースを見つけるのが難しい場合もあります。\n"
"- 抽象化は非効率をもたらすかもしれません。"

#: src/patterns/structural/unsafe-mods.md:24
#, fuzzy
msgid ""
"- The [`toolshed`](https://docs.rs/toolshed) crate contains its unsafe "
"operations\n"
"  in submodules, presenting a safe interface to users.\n"
"- `std`'s `String` class is a wrapper over `Vec<u8>` with the added "
"invariant\n"
"  that the contents must be valid UTF-8. The operations on `String` ensure "
"this\n"
"  behavior.\n"
"  However, users have the option of using an `unsafe` method to create a "
"`String`,\n"
"  in which case the onus is on them to guarantee the validity of the "
"contents."
msgstr ""
"- toolshed`](https://docs.rs/toolshed)クレートは、安全でない操作をサブモ"
"ジュールに含んでいます。\n"
"  をサブモジュールに含めることで、ユーザーに安全なインターフェイスを提供しま"
"す。\n"
"- std` の `String` クラスは `Vec<u8>` のラッパーです。\n"
"  のラッパーです。String` に対する操作はこの動作を保証します。\n"
"  の操作はこの動作を保証します。\n"
"  しかし、ユーザは `String` を作成するために `unsafe` メソッドを使用すること"
"ができます、\n"
"  を作成するオプションがあります。"

#: src/patterns/structural/unsafe-mods.md:34
#, fuzzy
msgid ""
"- [Ralf Jung's Blog about invariants in unsafe code](https://www.ralfj.de/"
"blog/2018/08/22/two-kinds-of-invariants.html)"
msgstr ""
"- [安全でないコードにおける不変量に関するラルフ・ユングのブログ](https://www."
"ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html)"

#: src/patterns/ffi/intro.md:1
#, fuzzy
msgid "# FFI Patterns"
msgstr "# ♪FFIパターン"

#: src/patterns/ffi/intro.md:3
#, fuzzy
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid "
"traps\n"
"for inexperienced users of unsafe Rust."
msgstr ""
"FFIコードの書き方は、それだけで1つのコースになります。\n"
"しかし、ここにはいくつかのイディオムがあり、安全でないRustの経験の浅いユー"
"ザーの罠を避けることができます。\n"
"安全でないRustの経験の浅いユーザーのための罠を避けることができます。"

#: src/patterns/ffi/intro.md:7
#, fuzzy
msgid ""
"This section contains design patterns that may be useful when doing FFI."
msgstr ""
"このセクションでは、FFIを行う際に役立つデザイン・パターンを紹介します。"

#: src/patterns/ffi/intro.md:9
#, fuzzy
msgid ""
"1. [Object-Based API](./export.md) design that has good memory safety "
"characteristics,\n"
"   and a clean boundary of what is safe and what is unsafe\n"
"\n"
"2. [Type Consolidation into Wrappers](./wrappers.md) - group multiple Rust "
"types\n"
"   together into an opaque \"object\""
msgstr ""
"1.[オブジェクト・ベースAPI](./export.md)は、メモリ安全性に優れた設計です、\n"
"   そして、何が安全で何が安全でないかの境界を明確にします。\n"
"\n"
"2.[型のラッパーへの統合](./wrappers.md) - 複数のRust型を不透明な「オブジェク"
"ト\n"
"   複数のRust型を不透明な \"オブジェクト\""

#: src/patterns/ffi/export.md:1
#, fuzzy
msgid "# Object-Based APIs"
msgstr "# オブジェクトベースのAPI"

#: src/patterns/ffi/export.md:5
#, fuzzy
msgid ""
"When designing APIs in Rust which are exposed to other languages, there are "
"some\n"
"important design principles which are contrary to normal Rust API design:"
msgstr ""
"他の言語に公開されるAPIをRustで設計する場合、通常のRust API設計に反する重要な"
"設計原則がいくつかあります。\n"
"通常のRust API設計に反する重要な設計原則があります："

#: src/patterns/ffi/export.md:8
#, fuzzy
msgid ""
"1. All Encapsulated types should be _owned_ by Rust, _managed_ by the user,\n"
"   and _opaque_.\n"
"2. All Transactional data types should be _owned_ by the user, and "
"_transparent_.\n"
"3. All library behavior should be functions acting upon Encapsulated types.\n"
"4. All library behavior should be encapsulated into types not based on "
"structure,\n"
"   but _provenance/lifetime_."
msgstr ""
"1.カプセル化された型はすべてRustが所有し、ユーザーが管理すべきものです、\n"
"   そして _opaque_ です。\n"
"2.すべてのトランザクションデータ型は、ユーザが所有し、透過的であるべきで"
"す。\n"
"3.すべてのライブラリの動作は、カプセル化された型に作用する関数であるべきで"
"す。\n"
"4.すべてのライブラリの動作は、構造に基づく型ではなく、_provenance/lifetime_型"
"にカプセル化されるべきです、\n"
"   ではなく、_provenance/lifetime_にカプセル化されるべきです。"

#: src/patterns/ffi/export.md:17
#, fuzzy
msgid ""
"Rust has built-in FFI support to other languages.\n"
"It does this by providing a way for crate authors to provide C-compatible "
"APIs\n"
"through different ABIs (though that is unimportant to this practice)."
msgstr ""
"Rustには、他の言語へのFFIサポートが組み込まれています。\n"
"これは、クレート作者が異なるABIを通じてC互換のAPIを提供する方法を提供すること"
"で実現します。\n"
"を提供する方法を提供することで、これを実現しています（この実践には重要ではあ"
"りませんが）。"

#: src/patterns/ffi/export.md:21
#, fuzzy
msgid ""
"Well-designed Rust FFI follows C API design principles, while compromising "
"the\n"
"design in Rust as little as possible. There are three goals with any foreign "
"API:"
msgstr ""
"うまく設計されたRust FFIは、C言語のAPI設計の原則に従いつつ、Rustの設計を可能"
"な限り損なわないようにします。\n"
"の設計を可能な限り損なわないようにします。海外のAPIには3つのゴールがありま"
"す："

#: src/patterns/ffi/export.md:24
#, fuzzy
msgid ""
"1. Make it easy to use in the target language.\n"
"2. Avoid the API dictating internal unsafety on the Rust side as much as "
"possible.\n"
"3. Keep the potential for memory unsafety and Rust `undefined behaviour` as "
"small\n"
"   as possible."
msgstr ""
"1.ターゲット言語で使いやすいように。\n"
"2.APIがRust側で内部的な安全性の欠如を指示することはできるだけ避けましょう。\n"
"3.メモリの安全性やRustの`未定義な振る舞い`の可能性をできるだけ小さくするこ"
"と。\n"
"   をできるだけ小さくします。"

#: src/patterns/ffi/export.md:29
#, fuzzy
msgid ""
"Rust code must trust the memory safety of the foreign language beyond a "
"certain\n"
"point. However, every bit of `unsafe` code on the Rust side is an "
"opportunity for\n"
"bugs, or to exacerbate `undefined behaviour`."
msgstr ""
"Rustコードは、外国語のメモリ安全性を一定以上信頼しなければなりません。\n"
"を信頼しなければなりません。しかし、Rust側の「安全でない」コードは、バグや"
"「未定義の動作」を悪化させる可能性があります。\n"
"バグを発生させたり、「未定義の動作」を悪化させたりする可能性があります。"

#: src/patterns/ffi/export.md:33
#, fuzzy
msgid ""
"For example, if a pointer provenance is wrong, that may be a segfault due "
"to\n"
"invalid memory access. But if it is manipulated by unsafe code, it could "
"become\n"
"full-blown heap corruption."
msgstr ""
"例えば、ポインタの出所が間違っている場合、それは無効なメモリ・アクセスによる"
"セグメ ント・フォルトかもしれません。\n"
"によるセグメンテーション・フォールトかもしれません。しかし、それが安全でない"
"コードによって操作された場合、本格的なヒープ破壊になる可能性があります。\n"
"本格的なヒープ破壊になる可能性があります。"

#: src/patterns/ffi/export.md:37
#, fuzzy
msgid ""
"The Object-Based API design allows for writing shims that have good memory "
"safety\n"
"characteristics, and a clean boundary of what is safe and what is `unsafe`."
msgstr ""
"オブジェクトベースのAPI設計により、メモリ安全性に優れたシムを書くことができま"
"す。\n"
"を書くことができます。"

#: src/patterns/ffi/export.md:42
#, fuzzy
msgid ""
"The POSIX standard defines the API to access an on-file database, known as "
"[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/"
"ndbm.h).\n"
"It is an excellent example of an \"object-based\" API."
msgstr ""
"POSIX標準では、[DBM](https://web.archive.org/web/20210105035602/https://www."
"mankier.com/0p/ndbm.h)として知られるオンファイル・データベースにアクセスする"
"ためのAPIを定義しています。\n"
"これは「オブジェクトベース」APIの優れた例です。"

#: src/patterns/ffi/export.md:45
#, fuzzy
msgid ""
"Here is the definition in C, which hopefully should be easy to read for "
"those\n"
"involved in FFI. The commentary below should help explain it for those who\n"
"miss the subtleties."
msgstr ""
"以下はC言語による定義です。\n"
"FFIに携わっている人には読みやすいと思います。以下の解説は、FFIに関わる人々に"
"とって読みやすいものであることを願っています。\n"
"以下の解説は、微妙な点を見逃した人のための説明に役立つはずです。"

#: src/patterns/ffi/export.md:49
#, fuzzy
msgid ""
"```C\n"
"struct DBM;\n"
"typedef struct { void *dptr, size_t dsize } datum;\n"
"\n"
"int     dbm_clearerr(DBM *);\n"
"void    dbm_close(DBM *);\n"
"int     dbm_delete(DBM *, datum);\n"
"int     dbm_error(DBM *);\n"
"datum   dbm_fetch(DBM *, datum);\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"DBM    *dbm_open(const char *, int, mode_t);\n"
"int     dbm_store(DBM *, datum, datum, int);\n"
"```"
msgstr ""
"```C\n"
"struct DBM；\n"
"typedef struct { void *dptr, size_t dsize } datum；\n"
"\n"
"int dbm_clearerr(DBM *)；\n"
"void dbm_close(DBM *)；\n"
"int dbm_delete(DBM *, datum)；\n"
"int dbm_error(DBM *)；\n"
"datum dbm_fetch(DBM *, datum)；\n"
"datum dbm_firstkey(DBM *)；\n"
"datum dbm_nextkey(DBM *)；\n"
"DBM *dbm_open(const char *, int, mode_t)；\n"
"int dbm_store(DBM *, datum, datum, int)；\n"
"```"

#: src/patterns/ffi/export.md:64
#, fuzzy
msgid "This API defines two types: `DBM` and `datum`."
msgstr "このAPIは2つの型を定義しています：DBM` と `datum` 。"

#: src/patterns/ffi/export.md:66
#, fuzzy
msgid ""
"The `DBM` type was called an \"encapsulated\" type above.\n"
"It is designed to contain internal state, and acts as an entry point for "
"the\n"
"library's behavior."
msgstr ""
"DBM`型は上で「カプセル化された」型と呼ばれました。\n"
"DBM`型は内部状態を含むように設計されており、ライブラリの動作のエントリポイン"
"トとして動作します。\n"
"ライブラリの動作のエントリポイントとして動作します。"

#: src/patterns/ffi/export.md:70
#, fuzzy
msgid ""
"It is completely opaque to the user, who cannot create a `DBM` themselves "
"since\n"
"they don't know its size or layout. Instead, they must call `dbm_open`, and "
"that\n"
"only gives them _a pointer to one_."
msgstr ""
"DBMのサイズやレイアウトを知らないので、ユーザは自分で`DBM`を作成することがで"
"きません。\n"
"を自分で作成することはできません。その代わりに、 `dbm_open` を呼び出す必要が"
"あります。\n"
"を呼び出さなければなりません。"

#: src/patterns/ffi/export.md:74
#, fuzzy
msgid ""
"This means all `DBM`s are \"owned\" by the library in a Rust sense.\n"
"The internal state of unknown size is kept in memory controlled by the "
"library,\n"
"not the user. The user can only manage its life cycle with `open` and "
"`close`,\n"
"and perform operations on it with the other functions."
msgstr ""
"つまり、すべての `DBM` は Rust 的な意味でライブラリが「所有」していることにな"
"る。\n"
"サイズ不明の内部状態はライブラリが管理するメモリに保持されます、\n"
"が管理するメモリに保持されます。ユーザは `open` と `close` によってのみ "
"`DBM` のライフサイクルを管理することができます、\n"
"でライフサイクルを管理し、他の関数で操作を行うことができます。"

#: src/patterns/ffi/export.md:79
#, fuzzy
msgid ""
"The `datum` type was called a \"transactional\" type above.\n"
"It is designed to facilitate the exchange of information between the library "
"and\n"
"its user."
msgstr ""
"datum`型は上で \"トランザクション \"型と呼ばれました。\n"
"これはライブラリと利用者の間の情報交換を容易にするために設計されています。\n"
"型と呼ばれるものです。"

#: src/patterns/ffi/export.md:83
#, fuzzy
msgid ""
"The database is designed to store \"unstructured data\", with no pre-defined "
"length\n"
"or meaning. As a result, the `datum` is the C equivalent of a Rust slice: a "
"bunch\n"
"of bytes, and a count of how many there are. The main difference is that "
"there is\n"
"no type information, which is what `void` indicates."
msgstr ""
"データベースは、あらかじめ長さや意味が定義されていない「非構造化データ」を保"
"存するように設計されています。\n"
"を保存するように設計されています。その結果、`datum` は C の Rust のスライスに"
"相当します。\n"
"バイトの束であり、その数をカウントします。主な違いは\n"
"これは `void` が示すものです。"

#: src/patterns/ffi/export.md:88
#, fuzzy
msgid ""
"Keep in mind that this header is written from the library's point of view.\n"
"The user likely has some type they are using, which has a known size.\n"
"But the library does not care, and by the rules of C casting, any type "
"behind a\n"
"pointer can be cast to `void`."
msgstr ""
"このヘッダーはライブラリーの視点から書かれていることに留意してください。\n"
"ユーザは、サイズが既知の型を使用している可能性が高いです。\n"
"しかし、ライブラリはそんなことは気にしません。\n"
"にキャストすることができます。"

#: src/patterns/ffi/export.md:93
#, fuzzy
msgid ""
"As noted earlier, this type is _transparent_ to the user. But also, this "
"type is\n"
"_owned_ by the user.\n"
"This has subtle ramifications, due to that pointer inside it.\n"
"The question is, who owns the memory that pointer points to?"
msgstr ""
"前述したように、このタイプはユーザーにとって「透明」です。しかしまた、この型"
"は\n"
"ユーザーによって所有されます。\n"
"このことは、ポインタの内部にあるポインタによって、微妙な影響を及ぼします。\n"
"問題は、そのポインタが指すメモリは誰のものなのか、ということです。"

#: src/patterns/ffi/export.md:98
#, fuzzy
msgid ""
"The answer for best memory safety is, \"the user\".\n"
"But in cases such as retrieving a value, the user does not know how to "
"allocate\n"
"it correctly (since they don't know how long the value is). In this case, "
"the library\n"
"code is expected to use the heap that the user has access to -- such as the "
"C library\n"
"`malloc` and `free` -- and then _transfer ownership_ in the Rust sense."
msgstr ""
"最高のメモリ安全性の答えは「ユーザー」です。\n"
"しかし、値を取得するような場合、ユーザーは（値の長さを知らないので）どのよう"
"に値を正しく確保すればよいのかわかりません。\n"
"を正しく割り当てる方法を知りません。この場合、ライブラリ\n"
"のコードは、ユーザがアクセスできるヒープを使用することが期待されます。\n"
"malloc`や`free`を使用し、Rustの意味での_所有権移転_を行います。"

#: src/patterns/ffi/export.md:104
#, fuzzy
msgid ""
"This may all seem speculative, but this is what a pointer means in C.\n"
"It means the same thing as Rust: \"user defined lifetime.\"\n"
"The user of the library needs to read the documentation in order to use it "
"correctly.\n"
"That said, there are some decisions that have fewer or greater consequences "
"if users\n"
"do it wrong. Minimizing those are what this best practice is about, and the "
"key\n"
"is to _transfer ownership of everything that is transparent_."
msgstr ""
"これはすべて推測の域を出ませんが、これがC言語におけるポインタの意味です。\n"
"Rustと同じ意味です：\"ユーザー定義寿命\"。\n"
"ライブラリのユーザーは、それを正しく使うためにドキュメントを読む必要がありま"
"す。\n"
"とはいえ、ユーザーが間違った使い方をした場合に、より少ない、あるいはより大き"
"な結果をもたらす決定もあります。\n"
"とはいえ、ユーザーが間違った使い方をした場合に、より少ない、あるいはより大き"
"な結果をもたらす決定もあります。それらを最小限にすることが、このベストプラク"
"ティスの目的であり、鍵なのです。\n"
"透明性のあるすべてのものの所有権を移譲することです。"

#: src/patterns/ffi/export.md:113
#, fuzzy
msgid ""
"This minimizes the number of memory safety guarantees the user must uphold "
"to a\n"
"relatively small number:"
msgstr ""
"これにより、ユーザが保持しなければならないメモリ安全性保証の数を、比較的少数"
"に抑えることができます。\n"
"比較的少数になります："

#: src/patterns/ffi/export.md:116
#, fuzzy
msgid ""
"1. Do not call any function with a pointer not returned by `dbm_open` "
"(invalid\n"
"   access or corruption).\n"
"2. Do not call any function on a pointer after close (use after free).\n"
"3. The `dptr` on any `datum` must be `NULL`, or point to a valid slice of "
"memory\n"
"   at the advertised length."
msgstr ""
"1.dbm_open`が返していないポインタを持つ関数を呼んではいけません (無効なアクセ"
"スや破損)。\n"
"   アクセスや破損）。\n"
"2.クローズ後のポインタに対して関数を呼び出さないでください（free の後に使用し"
"てください）。\n"
"3.datum` の `dptr` は `NULL` でなければなりません。\n"
"   を指していなければなりません。"

#: src/patterns/ffi/export.md:122
#, fuzzy
msgid ""
"In addition, it avoids a lot of pointer provenance issues.\n"
"To understand why, let us consider an alternative in some depth: key "
"iteration."
msgstr ""
"さらに、ポインタの証明に関する多くの問題を回避することができます。\n"
"その理由を理解するために、代替案であるキーの反復についてもう少し深く考えてみ"
"ましょう。"

#: src/patterns/ffi/export.md:125
#, fuzzy
msgid ""
"Rust is well known for its iterators.\n"
"When implementing one, the programmer makes a separate type with a bounded "
"lifetime\n"
"to its owner, and implements the `Iterator` trait."
msgstr ""
"Rustはイテレータでよく知られています。\n"
"イテレータを実装する場合、プログラマは、その所有者のライフタイムを制限した別"
"の型\n"
"を持ち、 `Iterator` トレイトを実装します。"

#: src/patterns/ffi/export.md:129
#, fuzzy
msgid "Here is how iteration would be done in Rust for `DBM`:"
msgstr "以下は `DBM` の Rust での反復処理の方法です："

#: src/patterns/ffi/export.md:131
#, fuzzy
msgid ""
"```rust,ignore\n"
"struct Dbm { ... }\n"
"\n"
"impl Dbm {\n"
"    /* ... */\n"
"    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
"    /* ... */\n"
"}\n"
"\n"
"struct DbmKeysIter<'it> {\n"
"    owner: &'it Dbm,\n"
"}\n"
"\n"
"impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
"```"
msgstr ""
"錆、無視\n"
"struct Dbm { ...}\n"
"\n"
"impl Dbm { .\n"
"    /* ... */\n"
"    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ...}\n"
"    /* ... */\n"
"}\n"
"\n"
"struct DbmKeysIter<'it> {\n"
"    owner: &'it Dbm、\n"
"}\n"
"\n"
"impl<'it> DbmKeysIter<'it> のイテレータ { ...}\n"
"```"

#: src/patterns/ffi/export.md:147
#, fuzzy
msgid ""
"This is clean, idiomatic, and safe. thanks to Rust's guarantees.\n"
"However, consider what a straightforward API translation would look like:"
msgstr ""
"Rustの保証のおかげで、これはクリーンでイディオム的で安全です。\n"
"しかし、素直なAPI翻訳がどのようなものかを考えてみましょう："

#: src/patterns/ffi/export.md:150
#, fuzzy
msgid ""
"```rust,ignore\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_next(\n"
"    iter: *mut DbmKeysIter,\n"
"    key_out: *const datum\n"
") -> libc::c_int {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter { // "
"このAPIはヤバいです!\n"
"    // このAPIは悪いアイデアです！実際のアプリケーションでは、代わりにオブ"
"ジェクトベースの設計を使用してください。\n"
"}\n"
"#[no_mangle］\n"
"pub extern \"C\" fn dbm_iter_next(\n"
"    iter： *mut DbmKeysIter、\n"
"    key_out： *const datum\n"
") -> libc::c_int {.\n"
"    // この API は悪いアイデアです！実際のアプリケーションでは、代わりにオブ"
"ジェクトベースの設計を使用してください。\n"
"}\n"
"#[no_mangle］\n"
"pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) { // このAPIはマズイ!\n"
"    // このAPIは悪いアイデアです！実際のアプリケーションでは、代わりにオブ"
"ジェクトベースの設計を使用してください。\n"
"}\n"
"```"

#: src/patterns/ffi/export.md:168
#, fuzzy
msgid ""
"This API loses a key piece of information: the lifetime of the iterator must "
"not\n"
"exceed the lifetime of the `Dbm` object that owns it. A user of the library "
"could\n"
"use it in a way which causes the iterator to outlive the data it is "
"iterating on,\n"
"resulting in reading uninitialized memory."
msgstr ""
"このAPIは重要な情報を失っています。\n"
"イテレータの有効期限はそれを所有する `Dbm` オブジェクトの有効期限を超えてはい"
"けません。ライブラリのユーザは\n"
"イテレータの寿命がそれを所有する `Dbm` オブジェクトの寿命を超えてはいけませ"
"ん、\n"
"その結果、初期化されていないメモリを読み込むことになります。"

#: src/patterns/ffi/export.md:173
#, fuzzy
msgid ""
"This example written in C contains a bug that will be explained afterwards:"
msgstr "C言語で書かれたこの例にはバグがありますが、それは後で説明します："

#: src/patterns/ffi/export.md:175
#, fuzzy
msgid ""
"```C\n"
"int count_key_sizes(DBM *db) {\n"
"    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!\n"
"    datum key;\n"
"    int len = 0;\n"
"\n"
"    if (!dbm_iter_new(db)) {\n"
"        dbm_close(db);\n"
"        return -1;\n"
"    }\n"
"\n"
"    int l;\n"
"    while ((l = dbm_iter_next(owner, &key)) >= 0) { // an error is indicated "
"by -1\n"
"        free(key.dptr);\n"
"        len += key.dsize;\n"
"        if (l == 0) { // end of the iterator\n"
"            dbm_close(owner);\n"
"        }\n"
"    }\n"
"    if l >= 0 {\n"
"        return -1;\n"
"    } else {\n"
"        return len;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```C\n"
"int count_key_sizes(DBM *db) { // この関数は使わないでください。\n"
"    // この関数は使わないでください。微妙な、しかし重大なバグがあります！\n"
"    datum key；\n"
"    int len = 0；\n"
"\n"
"    if (!dbm_iter_new(db)) { { dbm_iter_new(db)\n"
"        dbm_close(db)；\n"
"        return -1；\n"
"    }\n"
"\n"
"    int l；\n"
"    while ((l = dbm_iter_next(owner, &key)) >= 0) { // エラーは -1 で示されま"
"す。\n"
"        free(key.dptr)；\n"
"        len += key.dsize；\n"
"        if (l == 0) { // イテレータの終了\n"
"            dbm_close(owner)；\n"
"        }\n"
"    }\n"
"    if l >= 0 { // イテレータの終了\n"
"        return -1；\n"
"    } else {\n"
"        len を返します；\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/export.md:202
#, fuzzy
msgid ""
"This bug is a classic. Here's what happens when the iterator returns the\n"
"end-of-iteration marker:"
msgstr ""
"このバグは古典的なものです。イテレータが\n"
"を返したときに起こります："

#: src/patterns/ffi/export.md:205
#, fuzzy
msgid ""
"1. The loop condition sets `l` to zero, and enters the loop because `0 >= "
"0`.\n"
"2. The length is incremented, in this case by zero.\n"
"3. The if statement is true, so the database is closed. There should be a "
"break\n"
"   statement here.\n"
"4. The loop condition executes again, causing a `next` call on the closed "
"object."
msgstr ""
"1.ループ条件は `l` をゼロに設定し、`0 >= 0` なのでループに入ります。\n"
"2.この場合、長さはゼロずつ増加します。\n"
"3.if文は真なので、データベースは閉じられます。ここでブレーク\n"
"   文があるはずです。\n"
"4.ループ条件が再度実行され、クローズされたオブジェクトに対して `next` が呼び"
"出されます。"

#: src/patterns/ffi/export.md:211
#, fuzzy
msgid ""
"The worst part about this bug?\n"
"If the Rust implementation was careful, this code will work most of the "
"time!\n"
"If the memory for the `Dbm` object is not immediately reused, an internal "
"check\n"
"will almost certainly fail, resulting in the iterator returning a `-1` "
"indicating\n"
"an error. But occasionally, it will cause a segmentation fault, or even "
"worse,\n"
"nonsensical memory corruption!"
msgstr ""
"このバグで最悪なのは？\n"
"Rustの実装が慎重であれば、このコードはほとんどの場合動作します！\n"
"もし `Dbm` オブジェクトのメモリがすぐに再利用されなければ、内部チェックはほぼ"
"確実に失敗します。\n"
"のメモリがすぐに再利用されない場合、内部チェックはほぼ確実に失敗し、イテレー"
"タはエラーを示す `-1` を返します。\n"
"を返します。しかし、時にはセグメンテーションフォールトを引き起こすこともあり"
"ます、\n"
"無意味なメモリ破壊を引き起こすこともあります！"

#: src/patterns/ffi/export.md:218
#, fuzzy
msgid ""
"None of this can be avoided by Rust.\n"
"From its perspective, it put those objects on its heap, returned pointers to "
"them,\n"
"and gave up control of their lifetimes. The C code simply must \"play nice\"."
msgstr ""
"Rustはこのどれも避けることができません。\n"
"Rustの観点では、これらのオブジェクトをヒープに置き、それらへのポインタを返し"
"ました、\n"
"そしてそれらの寿命の制御を放棄しました。Cのコードは単に「いい子ぶる」必要があ"
"るだけです。"

#: src/patterns/ffi/export.md:222
#, fuzzy
msgid ""
"The programmer must read and understand the API documentation.\n"
"While some consider that par for the course in C, a good API design can "
"mitigate\n"
"this risk. The POSIX API for `DBM` did this by _consolidating the ownership_ "
"of\n"
"the iterator with its parent:"
msgstr ""
"プログラマーはAPIドキュメントを読み、理解しなければなりません。\n"
"C言語では当然のことだと考える人もいますが、優れたAPI設計はこのリスクを軽減す"
"ることができます。\n"
"このリスクを軽減することができます。DBM`のPOSIX APIでは、イテレータの所有権を"
"その親に統合しています。\n"
"イテレータの所有権をその親に統合することです："

#: src/patterns/ffi/export.md:227
#, fuzzy
msgid ""
"```C\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"```"
msgstr ""
"```C\n"
"datum dbm_firstkey(DBM *)；\n"
"datum dbm_nextkey(DBM *)；\n"
"```"

#: src/patterns/ffi/export.md:232
#, fuzzy
msgid ""
"Thus, all the lifetimes were bound together, and such unsafety was prevented."
msgstr ""
"こうして、すべての寿命が結ばれ、そのような安全性の欠如が防がれたのです。"

#: src/patterns/ffi/export.md:236
#, fuzzy
msgid ""
"However, this design choice also has a number of drawbacks, which should be\n"
"considered as well."
msgstr ""
"しかし、この設計の選択にはいくつかの欠点もあります。\n"
"も考慮する必要があります。"

#: src/patterns/ffi/export.md:239
#, fuzzy
msgid ""
"First, the API itself becomes less expressive.\n"
"With POSIX DBM, there is only one iterator per object, and every call "
"changes\n"
"its state. This is much more restrictive than iterators in almost any "
"language,\n"
"even though it is safe. Perhaps with other related objects, whose lifetimes "
"are\n"
"less hierarchical, this limitation is more of a cost than the safety."
msgstr ""
"まず、API自体の表現力が低下します。\n"
"POSIX DBMでは、1つのオブジェクトにつきイテレータは1つしかありません。\n"
"の状態を変更します。これはほとんどすべての言語のイテレータよりもはるかに制限"
"的です、\n"
"たとえ安全であってもです。おそらく他の関連オブジェクトでは、その寿命はそれほ"
"ど階層的ではありません。\n"
"この制限は、安全性よりもコストになります。"

#: src/patterns/ffi/export.md:245
#, fuzzy
msgid ""
"Second, depending on the relationships of the API's parts, significant "
"design effort\n"
"may be involved. Many of the easier design points have other patterns "
"associated\n"
"with them:"
msgstr ""
"第二に、APIの部品の関係によっては、設計に多大な労力\n"
"が必要になるかもしれません。簡単な設計ポイントの多くには、他のパターンがあり"
"ます。\n"
"があります："

#: src/patterns/ffi/export.md:249
#, fuzzy
msgid ""
"- [Wrapper Type Consolidation](./wrappers.md) groups multiple Rust types "
"together\n"
"  into an opaque \"object\"\n"
"\n"
"- [FFI Error Passing](../../idioms/ffi/errors.md) explains error handling "
"with integer\n"
"  codes and sentinel return values (such as `NULL` pointers)\n"
"\n"
"- [Accepting Foreign Strings](../../idioms/ffi/accepting-strings.md) allows "
"accepting\n"
"  strings with minimal unsafe code, and is easier to get right than\n"
"  [Passing Strings to FFI](../../idioms/ffi/passing-strings.md)"
msgstr ""
"- [ラッパー・タイプの統合](./wrappers.md)は、複数のRustタイプを不透明な \"オ"
"ブジェクト\n"
"  を不透明な \"オブジェクト\"\n"
"\n"
"- [FFI Error Passing](../../idioms/ffi/errors.md) 整数コードとセンチネル戻り"
"値 (`NULL` ポインタなど) によるエラー処理について説明しています。\n"
"  コードとセンチネル戻り値 (`NULL` ポインタなど) によるエラー処理について説明"
"しています。\n"
"\n"
"- [文字列の受け入れ](../../idioms/ffi/accepting-strings.md) は、安全でない"
"コードを最小限に抑えて文字列を受け入れることができます。\n"
"  よりも簡単です。\n"
"  [FFIに文字列を渡す](../../idioms/ffi/passing-strings.md) よりも簡単に正しく"
"できます。"

#: src/patterns/ffi/export.md:259
#, fuzzy
msgid ""
"However, not every API can be done this way.\n"
"It is up to the best judgement of the programmer as to who their audience is."
msgstr ""
"しかし、すべてのAPIがこの方法でできるわけではありません。\n"
"利用者が誰であるかは、プログラマーの最善の判断次第です。"

#: src/patterns/ffi/wrappers.md:1
#, fuzzy
msgid "# Type Consolidation into Wrappers"
msgstr "# ラッパーへのタイプ統合"

#: src/patterns/ffi/wrappers.md:5
#, fuzzy
msgid ""
"This pattern is designed to allow gracefully handling multiple related "
"types,\n"
"while minimizing the surface area for memory unsafety."
msgstr ""
"このパターンは、関連する複数の型を優雅に扱えるように設計されています、\n"
"を優雅に扱えるように設計されています。"

#: src/patterns/ffi/wrappers.md:8
#, fuzzy
msgid ""
"One of the cornerstones of Rust's aliasing rules is lifetimes.\n"
"This ensures that many patterns of access between types can be memory safe,\n"
"data race safety included."
msgstr ""
"Rustのエイリアシングルールの基礎の1つは、ライフタイムです。\n"
"これにより、型間のアクセスの多くのパターンがメモリセーフになります、\n"
"データレースの安全性も含まれます。"

#: src/patterns/ffi/wrappers.md:12
#, fuzzy
msgid ""
"However, when Rust types are exported to other languages, they are usually "
"transformed\n"
"into pointers. In Rust, a pointer means \"the user manages the lifetime of "
"the pointee.\"\n"
"It is their responsibility to avoid memory unsafety."
msgstr ""
"しかし、Rustの型が他の言語にエクスポートされる場合、通常はポインタに変換され"
"ます。\n"
"に変換されます。Rustでは、ポインタは \"ユーザーがポインタのライフタイムを管理"
"する \"ことを意味します。\n"
"メモリの安全性が損なわれないようにするのは、ユーザーの責任です。"

#: src/patterns/ffi/wrappers.md:16
#, fuzzy
msgid ""
"Some level of trust in the user code is thus required, notably around use-"
"after-free\n"
"which Rust can do nothing about. However, some API designs place higher "
"burdens\n"
"than others on the code written in the other language."
msgstr ""
"そのため、ユーザーコードにはある程度の信頼が必要です。\n"
"については特にそうです。しかし、APIの設計によっては、他方の言語で書かれたコー"
"ドに、他方よりも高い負担を強いるものもあります。\n"
"しかし、APIの設計によっては、他の言語で書かれたコードよりも高い負担を強いるも"
"のもあります。"

#: src/patterns/ffi/wrappers.md:20
#, fuzzy
msgid ""
"The lowest risk API is the \"consolidated wrapper\", where all possible "
"interactions\n"
"with an object are folded into a \"wrapper type\", while keeping the Rust "
"API clean."
msgstr ""
"最もリスクの低いAPIは「連結ラッパー」です。\n"
"RustのAPIをクリーンに保ちながら、オブジェクトとの可能なやりとりはすべて "
"\"ラッパー型 \"に折り畳まれます。"

#: src/patterns/ffi/wrappers.md:25
#, fuzzy
msgid ""
"To understand this, let us look at a classic example of an API to export: "
"iteration\n"
"through a collection."
msgstr ""
"これを理解するために、エクスポートするAPIの典型的な例を見てみましょう。\n"
"です。"

#: src/patterns/ffi/wrappers.md:28
#, fuzzy
msgid "That API looks like this:"
msgstr "そのAPIは次のようなものです："

#: src/patterns/ffi/wrappers.md:30
#, fuzzy
msgid ""
"1. The iterator is initialized with `first_key`.\n"
"2. Each call to `next_key` will advance the iterator.\n"
"3. Calls to `next_key` if the iterator is at the end will do nothing.\n"
"4. As noted above, the iterator is \"wrapped into\" the collection (unlike "
"the native\n"
"   Rust API)."
msgstr ""
"1.イテレータは `first_key` で初期化されます。\n"
"2.next_key` を呼び出すたびにイテレータが進みます。\n"
"3.イテレータが末尾にある場合に `next_key` を呼び出しても何も起こりません。\n"
"4.上で述べたように、イテレータはコレクションに \"包まれます\" (Rust ネイティ"
"ブ API とは異なります)。\n"
"   Rust API とは異なります)。"

#: src/patterns/ffi/wrappers.md:36
#, fuzzy
msgid ""
"If the iterator implements `nth()` efficiently, then it is possible to make "
"it\n"
"ephemeral to each function call:"
msgstr ""
"もしイテレータが `nth()` を効率的に実装していれば、各関数呼び出しに対してイテ"
"レータを\n"
"をエフェメラルにすることが可能です："

#: src/patterns/ffi/wrappers.md:39
#, fuzzy
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"}\n"
"\n"
"impl MySetWrapper {\n"
"    pub fn first_key(&mut self) -> Option<&Key> {\n"
"        self.iter_next = 0;\n"
"        self.next_key()\n"
"    }\n"
"    pub fn next_key(&mut self) -> Option<&Key> {\n"
"        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
"            self.iter_next += 1;\n"
"            Some(next)\n"
"        } else {\n"
"            None\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"struct MySetWrapper {\n"
"    myset：MySet、\n"
"    iter_next: usize、\n"
"}\n"
"\n"
"impl MySetWrapper { 以下のようになります。\n"
"    pub fn first_key(&mut self) -> Option<&Key> { 次のようになります。\n"
"        self.iter_next = 0；\n"
"        self.next_key()\n"
"    }\n"
"    pub fn next_key(&mut self) -> Option<&Key> { もし let Some(next) = "
"self.\n"
"        let Some(next) = self.myset.keys().nth(self.iter_next) { if\n"
"            self.iter_next += 1；\n"
"            Some(next)\n"
"        } else {\n"
"            None\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:61
#, fuzzy
msgid "As a result, the wrapper is simple and contains no `unsafe` code."
msgstr "その結果、ラッパーはシンプルで、`安全でない`コードを含んでいません。"

#: src/patterns/ffi/wrappers.md:65
#, fuzzy
msgid ""
"This makes APIs safer to use, avoiding issues with lifetimes between types.\n"
"See [Object-Based APIs](./export.md) for more on the advantages and "
"pitfalls\n"
"this avoids."
msgstr ""
"これにより、APIをより安全に使用できるようになり、型間のライフタイムの問題を避"
"けることができます。\n"
"オブジェクトベースのAPI](./export.md)を参照してください。\n"
"を参照してください。"

#: src/patterns/ffi/wrappers.md:71
#, fuzzy
msgid ""
"Often, wrapping types is quite difficult, and sometimes a Rust API "
"compromise\n"
"would make things easier."
msgstr ""
"多くの場合、型のラッピングは非常に難しく、Rust APIを妥協することで\n"
"を妥協することで、より簡単になります。"

#: src/patterns/ffi/wrappers.md:74
#, fuzzy
msgid ""
"As an example, consider an iterator which does not efficiently implement "
"`nth()`.\n"
"It would definitely be worth putting in special logic to make the object "
"handle\n"
"iteration internally, or to support a different access pattern efficiently "
"that\n"
"only the Foreign Function API will use."
msgstr ""
"例として、効率的に `nth()` を実装していないイテレータを考えてみましょう。\n"
"を効率的に実装していないイテレータを考えてみましょう。\n"
"イテレータを内部的に処理させるか、あるいは外部関数APIだけが使用する別のアクセ"
"スパターンを効率的にサポートするために、特別なロジックを入れる価値がありま"
"す。\n"
"のみが使用する別のアクセスパターンを効率的にサポートします。"

#: src/patterns/ffi/wrappers.md:79
#, fuzzy
msgid "### Trying to Wrap Iterators (and Failing)"
msgstr "### イテレータのラップに挑戦（そして失敗）"

#: src/patterns/ffi/wrappers.md:81
#, fuzzy
msgid ""
"To wrap any type of iterator into the API correctly, the wrapper would need "
"to\n"
"do what a C version of the code would do: erase the lifetime of the "
"iterator,\n"
"and manage it manually."
msgstr ""
"どのようなタイプのイテレータでもAPIに正しくラップするためには、ラッパーはC"
"バージョンのコードが行うようなこと、つまりイテレータのライフタイムを消去する"
"必要があります。\n"
"イテレータのライフタイムを消去します、\n"
"そしてそれを手動で管理します。"

#: src/patterns/ffi/wrappers.md:85
#, fuzzy
msgid "Suffice it to say, this is _incredibly_ difficult."
msgstr "言うまでもないことですが、これは信じられないほど難しいことです。"

#: src/patterns/ffi/wrappers.md:87
#, fuzzy
msgid "Here is an illustration of just _one_ pitfall."
msgstr "ここで、たったひとつの落とし穴をご紹介しましょう。"

#: src/patterns/ffi/wrappers.md:89
#, fuzzy
msgid "A first version of `MySetWrapper` would look like this:"
msgstr "MySetWrapper`の最初のバージョンは次のようになります："

#: src/patterns/ffi/wrappers.md:91
#, fuzzy
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"    // created from a transmuted Box<KeysIter + 'self>\n"
"    iterator: Option<NonNull<KeysIter<'static>>>,\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"struct MySetWrapper {\n"
"    myset：MySet、\n"
"    iter_next: usize、\n"
"    // Box<KeysIter+'self>を変換して作成。\n"
"    iterator：Option<NonNull<KeysIter<'static>>>、\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:100
#, fuzzy
msgid ""
"With `transmute` being used to extend a lifetime, and a pointer to hide it,\n"
"it's ugly already. But it gets even worse: _any other operation can cause\n"
"Rust `undefined behaviour`_."
msgstr ""
"transmute`は寿命の延長に使われ、ポインタはそれを隠すのに使われます、\n"
"もう醜い。しかし、さらに悪くなります：他の操作が\n"
"Rust の `未定義の動作`_ を引き起こします。"

#: src/patterns/ffi/wrappers.md:104
#, fuzzy
msgid ""
"Consider that the `MySet` in the wrapper could be manipulated by other\n"
"functions during iteration, such as storing a new value to the key it was\n"
"iterating over. The API doesn't discourage this, and in fact some similar C\n"
"libraries expect it."
msgstr ""
"ラッパー内の `MySet` は、反復処理中に他の関数によって操作される可能性がありま"
"す。\n"
"ラッパー内の `MySet` は、イテレーション中に他の関数によって操作される可能性が"
"あります。\n"
"に新しい値を格納するなどです。APIはこれを推奨していません。\n"
"ライブラリではそれを想定しています。"

#: src/patterns/ffi/wrappers.md:109
#, fuzzy
msgid "A simple implementation of `myset_store` would be:"
msgstr "myset_store`の簡単な実装は次のようになります："

#: src/patterns/ffi/wrappers.md:111
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub fn myset_store(\n"
"        myset: *mut MySetWrapper,\n"
"        key: datum,\n"
"        value: datum) -> libc::c_int {\n"
"\n"
"        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.\n"
"\n"
"        let myset: &mut MySet = unsafe { // SAFETY: whoops, UB occurs in "
"here!\n"
"            &mut (*myset).myset\n"
"        };\n"
"\n"
"        /* ...check and cast key and value data... */\n"
"\n"
"        match myset.store(casted_key, casted_value) {\n"
"            Ok(_) => 0,\n"
"            Err(e) => e.into()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"pub mod unsafe_module {\n"
"\n"
"    // その他のモジュールの内容\n"
"\n"
"    pub fn myset_store(\n"
"        myset： *mut MySetWrapper、\n"
"        key: datum、\n"
"        value: datum) -> libc::c_int {.\n"
"\n"
"        // このコードは使用しないでください。プロルベムのデモは安全ではありま"
"せん。\n"
"\n"
"        let myset: &mut MySet = unsafe { // 安全: おっと、ここでUBが発生しま"
"した！\n"
"            &mut (*myset).myset\n"
"        };\n"
"\n"
"        /* ...キーと値のデータをチェックし、キャスト... */\n"
"\n"
"        mat myset.store(casted_key, casted_value) { にマッチします。\n"
"            Ok(_) => 0、\n"
"            Err(e) => e.into()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:137
#, fuzzy
msgid ""
"If the iterator exists when this function is called, we have violated one of "
"Rust's\n"
"aliasing rules. According to Rust, the mutable reference in this block must "
"have\n"
"_exclusive_ access to the object. If the iterator simply exists, it's not "
"exclusive,\n"
"so we have `undefined behaviour`! "
msgstr ""
"この関数が呼ばれたときにイテレータが存在していた場合、Rustの\n"
"のエイリアシングルールに違反しています。Rustによると、このブロック内のミュー"
"タブル参照はオブジェクトに対して\n"
"オブジェクトへの排他的アクセスでなければなりません。イテレータが単に存在する"
"だけなら、それは排他的ではありません、\n"
"そのため、`未定義の動作`が発生します！"

#: src/patterns/ffi/wrappers.md:142
#, fuzzy
msgid ""
"To avoid this, we must have a way of ensuring that mutable reference really "
"is exclusive.\n"
"That basically means clearing out the iterator's shared reference while it "
"exists,\n"
"and then reconstructing it. In most cases, that will still be less efficient "
"than\n"
"the C version."
msgstr ""
"これを避けるには、ミュータブル参照が本当に排他的であることを保証する方法を持"
"たなければなりません。\n"
"これは基本的に、イテレータの共有参照が存在する間にそれを消去し、それを再構築"
"することを意味します、\n"
"そしてそれを再構築します。たいていの場合、それでもCのバージョンより効率は悪く"
"なります。\n"
"よりも効率が悪くなります。"

#: src/patterns/ffi/wrappers.md:147
#, fuzzy
msgid ""
"Some may ask: how can C do this more efficiently?\n"
"The answer is, it cheats. Rust's aliasing rules are the problem, and C "
"simply ignores\n"
"them for its pointers. In exchange, it is common to see code that is "
"declared\n"
"in the manual as \"not thread safe\" under some or all circumstances. In "
"fact,\n"
"the [GNU C library](https://manpages.debian.org/buster/manpages/attributes.7."
"en.html)\n"
"has an entire lexicon dedicated to concurrent behavior!"
msgstr ""
"C言語はどうすればもっと効率的にできるのか？\n"
"答えはズルです。Rustのエイリアシングルールが問題なのです。\n"
"を無視するだけです。その代わりに、マニュアルで「スレッドセーフではない」と宣"
"言されているコードが\n"
"マニュアルで「スレッドセーフではない」と宣言されているコードをよく見かけま"
"す。実際\n"
"GNU Cライブラリ](https://manpages.debian.org/buster/manpages/attributes.7.en."
"html)\n"
"には、並行動作に特化した辞書全体があります！"

#: src/patterns/ffi/wrappers.md:154
#, fuzzy
msgid ""
"Rust would rather make everything memory safe all the time, for both safety "
"and\n"
"optimizations that C code cannot attain. Being denied access to certain "
"shortcuts\n"
"is the price Rust programmers need to pay."
msgstr ""
"Rustはむしろ、安全性とCコードでは達成できない最適化の両方を実現するために、す"
"べてを常にメモリセーフにします。\n"
"Cのコードでは達成できない最適化を行うためです。特定のショートカットへのアクセ"
"スを拒否されることは\n"
"は、Rustプログラマが支払わなければならない代償です。"

#: src/patterns/ffi/wrappers.md:158
#, fuzzy
msgid ""
"For the C programmers out there scratching their heads, the iterator need\n"
"not be read _during_ this code cause the UB. The exclusivity rule also "
"enables\n"
"compiler optimizations which may cause inconsistent observations by the "
"iterator's\n"
"shared reference (e.g. stack spills or reordering instructions for "
"efficiency).\n"
"These observations may happen _any time after_ the mutable reference is "
"created."
msgstr ""
"頭を悩ませているCプログラマーのために言っておくと、イテレータはこのコード中に"
"読む必要はありません。\n"
"を読む必要はありません。また、排他的ルールによって\n"
"コンパイラの最適化によって、イテレータの共有参照に矛盾が生じる可能性がありま"
"す。\n"
"共有参照（例えば、スタックこぼれや効率化のための命令の並べ替えなど）によっ"
"て、矛盾した観測を引き起こす可能性のあるコンパイラの最適化も可能になりま"
"す。\n"
"このようなオブザベーションは、ミュータブル参照が生成された後いつでも発生する"
"可能性があります。"

#: src/anti_patterns/index.md:1
#, fuzzy
msgid "# Anti-patterns"
msgstr "# アンチパターン"

#: src/anti_patterns/index.md:3
#, fuzzy
msgid ""
"An [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) is a solution "
"to\n"
"a \"recurring problem that is usually ineffective and risks being highly\n"
"counterproductive\". Just as valuable as knowing how to solve a problem, is\n"
"knowing how _not_ to solve it. Anti-patterns give us great counter-examples "
"to\n"
"consider relative to design patterns. Anti-patterns are not confined to "
"code.\n"
"For example, a process can be an anti-pattern, too."
msgstr ""
"アンチパターン](https://en.wikipedia.org/wiki/Anti-pattern)とは\n"
"通常、効果がなく、非常に逆効果になる危険性のある、繰り返し起こる問題」に対す"
"る解決策。\n"
"逆効果になる危険がある」解決策のことです。問題を解決する方法を知ることと同じ"
"くらい価値があるのは\n"
"どのように解決しないかを知ることです。アンチパターンは、デザインパターンと比"
"較して考慮すべき素晴らしい反例を与えてくれます。\n"
"デザインパターンに関連して考えるべき素晴らしい反例を与えてくれます。アンチパ"
"ターンはコードに限ったことではありません。\n"
"例えば、プロセスもアンチパターンになりえます。"

#: src/anti_patterns/borrow_clone.md:1
#, fuzzy
msgid "# Clone to satisfy the borrow checker"
msgstr "# 借り手チェッカーを満足させるクローン"

#: src/anti_patterns/borrow_clone.md:5
#, fuzzy
msgid ""
"The borrow checker prevents Rust users from developing otherwise unsafe code "
"by\n"
"ensuring that either: only one mutable reference exists, or potentially many "
"but\n"
"all immutable references exist. If the code written does not hold true to "
"these\n"
"conditions, this anti-pattern arises when the developer resolves the "
"compiler\n"
"error by cloning the variable."
msgstr ""
"ボローン・チェッカーは、以下のいずれかによって、Rustユーザーが安全でないコー"
"ドを開発するのを防ぎます。\n"
"ミュータブルな参照が1つだけ存在するか、潜在的には多数存在する可能性があるけれ"
"ども\n"
"すべての不変参照が存在すること。もし書かれたコードがこれらの条件を満たさない"
"場合、このアンチパターンが発生します。\n"
"このアンチパターンは、開発者が変数のクローンを作成することでコンパイラのエ"
"ラーを解決するときに発生します。\n"
"エラーを解決するときに発生します。"

#: src/anti_patterns/borrow_clone.md:13
#, fuzzy
msgid ""
"```rust\n"
"// define any variable\n"
"let mut x = 5;\n"
"\n"
"// Borrow `x` -- but clone it first\n"
"let y = &mut (x.clone());\n"
"\n"
"// without the x.clone() two lines prior, this line would fail on compile "
"as\n"
"// x has been borrowed\n"
"// thanks to x.clone(), x was never borrowed, and this line will run.\n"
"println!(\"{}\", x);\n"
"\n"
"// perform some action on the borrow to prevent rust from optimizing this\n"
"//out of existence\n"
"*y += 1;\n"
"```"
msgstr ""
"ラスト\n"
"// 変数の定義\n"
"mut x = 5；\n"
"\n"
"// `x` を借用 -- ただし最初にクローンを作成\n"
"let y = &mut (x.clone())；\n"
"\n"
"// 2行前の x.clone() がなければ、この行はコンパイルで失敗します。\n"
"// x は借用されました。\n"
"// x.clone()のおかげでxは借用されなかったので、この行は実行されます。\n"
"println!(\"{}\", x)；\n"
"\n"
"// borrowに対して何らかのアクションを実行し、rustによる最適化を防ぎます。\n"
"// 存在しない\n"
"*y += 1;\n"
"```"

#: src/anti_patterns/borrow_clone.md:32
#, fuzzy
msgid ""
"It is tempting, particularly for beginners, to use this pattern to resolve\n"
"confusing issues with the borrow checker. However, there are serious\n"
"consequences. Using `.clone()` causes a copy of the data to be made. Any "
"changes\n"
"between the two are not synchronized -- as if two completely separate "
"variables\n"
"exist."
msgstr ""
"特に初心者の方は、このパターンを使って借入チェッカーとの混乱した問題を解決し"
"たくなることでしょう。\n"
"特に初心者の方にとっては、このパターンを使って借入チェッカーで混乱した問題を"
"解決したくなるものです。しかし、深刻な\n"
"があります。.clone()`を使うと、データのコピーが作成されます。この2つの間の変"
"更は同期されません。\n"
"この2つの間の変更は同期されません。\n"
"が存在するかのように。"

#: src/anti_patterns/borrow_clone.md:38
#, fuzzy
msgid ""
"There are special cases -- `Rc<T>` is designed to handle clones "
"intelligently.\n"
"It internally manages exactly one copy of the data, and cloning it will "
"only\n"
"clone the reference."
msgstr ""
"Rc<T>` はクローンをインテリジェントに扱うように設計されています。\n"
"内部的にデータのコピーを1つだけ管理しており、クローンを作成しても参照がクロー"
"ンされるだけです。\n"
"参照だけをクローンします。"

#: src/anti_patterns/borrow_clone.md:42
#, fuzzy
msgid ""
"There is also `Arc<T>` which provides shared ownership of a value of type T\n"
"that is allocated in the heap. Invoking `.clone()` on `Arc` produces a new "
"`Arc`\n"
"instance, which points to the same allocation on the heap as the source "
"`Arc`,\n"
"while increasing a reference count."
msgstr ""
"また、ヒープに確保されたT型値の共有オーナーシップを提供する `Arc<T>` もありま"
"す。\n"
"型の値の共有所有権を提供します。Arc` に対して `.clone()` を呼び出すと、新し"
"い `Arc` インスタンスが生成されます。\n"
"インスタンスが生成されます、\n"
"を生成します。"

#: src/anti_patterns/borrow_clone.md:47
#, fuzzy
msgid ""
"In general, clones should be deliberate, with full understanding of the\n"
"consequences. If a clone is used to make a borrow checker error disappear,\n"
"that's a good indication this anti-pattern may be in use."
msgstr ""
"一般的にクローンは、その結果を十分に理解した上で、意図的に行われるべきもので"
"す。\n"
"を十分に理解した上で行われるべきです。もし、借用チェッカーのエラーを消すため"
"にクローンが使われるのであれば、それはこのアンチパターンが使われている可能性"
"を示しています、\n"
"それは、このアンチパターンが使われている可能性を示す良い兆候です。"

#: src/anti_patterns/borrow_clone.md:51
#, fuzzy
msgid ""
"Even though `.clone()` is an indication of a bad pattern, sometimes\n"
"**it is fine to write inefficient code**, in cases such as when:"
msgstr ""
".clone()`は悪いパターンの表れですが、以下のような場合には、**非効率なコードを"
"書いてもよい**こともあります。\n"
"**.clone()`は悪いパターンであることを示しています："

#: src/anti_patterns/borrow_clone.md:54
#, fuzzy
msgid ""
"- the developer is still new to ownership\n"
"- the code doesn't have great speed or memory constraints\n"
"  (like hackathon projects or prototypes)\n"
"- satisfying the borrow checker is really complicated, and you prefer to\n"
"  optimize readability over performance"
msgstr ""
"- 開発者がまだオーナーになったばかり\n"
"- コードの速度やメモリに大きな制約がない場合\n"
"  (ハッカソンプロジェクトやプロトタイプのように)\n"
"- 借用チェッカーを満足させるのは本当に複雑で、次のようなことを好みます。\n"
"  パフォーマンスよりも読みやすさを最適化したい"

#: src/anti_patterns/borrow_clone.md:60
#, fuzzy
msgid ""
"If an unnecessary clone is suspected, The [Rust Book's chapter on Ownership]"
"(https://doc.rust-lang.org/book/ownership.html)\n"
"should be understood fully before assessing whether the clone is required or "
"not."
msgstr ""
"不必要なクローンが疑われる場合、【ラストブックのオーナーシップの章】(https://"
"doc.rust-lang.org/book/ownership.html)\n"
"を十分に理解した上で、クローンが必要かどうかを判断してください。"

#: src/anti_patterns/borrow_clone.md:63
#, fuzzy
msgid ""
"Also be sure to always run `cargo clippy` in your project, which will detect "
"some\n"
"cases in which `.clone()` is not necessary, like [1](https://rust-lang."
"github.io/rust-clippy/master/index.html#redundant_clone),\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_on_copy),\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) or "
"[4](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_double_ref)."
msgstr ""
"また、プロジェクト内で常に `cargo clippy` を実行するようにしてください。\n"
".clone()`が不要なケースを検出してくれます、\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_on_copy)、\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone)、[4]"
"(https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref) "
"のように、`.clone()'が不要なケースも検出されます。"

#: src/anti_patterns/borrow_clone.md:70
#, fuzzy
msgid ""
"- [`mem::{take(_), replace(_)}` to keep owned values in changed enums](../"
"idioms/mem-replace.md)\n"
"- [`Rc<T>` documentation, which handles .clone() intelligently](http://doc."
"rust-lang.org/std/rc/)\n"
"- [`Arc<T>` documentation, a thread-safe reference-counting pointer](https://"
"doc.rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Tricks with ownership in Rust](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"
msgstr ""
"- [`mem::{take(_), replace(_)}`で変更された列挙型の所有値を保持](../idioms/"
"mem-replace.md)\n"
"- [.clone() をインテリジェントに扱う `Rc<T>` ドキュメント](http://doc.rust-"
"lang.org/std/rc/)\n"
"- [スレッドセーフな参照カウントポインタ `Arc<T>` ドキュメント](https://doc."
"rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Rust における所有権のトリック](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"

#: src/anti_patterns/deny-warnings.md:1
#, fuzzy
msgid "# `#![deny(warnings)]`"
msgstr "# `#![deny(warnings)]`。"

#: src/anti_patterns/deny-warnings.md:5
#, fuzzy
msgid ""
"A well-intentioned crate author wants to ensure their code builds without\n"
"warnings. So they annotate their crate root with the following:"
msgstr ""
"善意の木枠作成者は、自分たちのコードが警告なしでビルドされることを保証したい"
"のです。\n"
"を保証したいと考えています。そこで、彼らはcrateルートに次のような注釈を付けま"
"す："

#: src/anti_patterns/deny-warnings.md:10
#, fuzzy
msgid ""
"```rust\n"
"#![deny(warnings)]\n"
"\n"
"// All is well.\n"
"```"
msgstr ""
"ラスト\n"
"#![deny(warnings)]。\n"
"\n"
"// 全て順調です。\n"
"```"

#: src/anti_patterns/deny-warnings.md:18
#, fuzzy
msgid "It is short and will stop the build if anything is amiss."
msgstr "これは短く、何か問題があればビルドを停止します。"

#: src/anti_patterns/deny-warnings.md:20
#, fuzzy
msgid "## Drawbacks"
msgstr "#欠点"

#: src/anti_patterns/deny-warnings.md:22
#, fuzzy
msgid ""
"By disallowing the compiler to build with warnings, a crate author opts out "
"of\n"
"Rust's famed stability. Sometimes new features or old misfeatures need a "
"change\n"
"in how things are done, thus lints are written that `warn` for a certain "
"grace\n"
"period before being turned to `deny`."
msgstr ""
"コンパイラが警告付きでビルドするのを禁止することで、クレート作成者は\n"
"Rustの有名な安定性から外れることになります。時には、新しい機能や古い誤動作を"
"修正する必要があります。\n"
"そのため、リントは `deny` になる前に一定の猶予期間 `warn` するように書かれて"
"います。\n"
"を`deny`にする前に、一定の猶予期間`warn`するように書かれています。"

#: src/anti_patterns/deny-warnings.md:27
#, fuzzy
msgid ""
"For example, it was discovered that a type could have two `impl`s with the "
"same\n"
"method. This was deemed a bad idea, but in order to make the transition "
"smooth,\n"
"the `overlapping-inherent-impls` lint was introduced to give a warning to "
"those\n"
"stumbling on this fact, before it becomes a hard error in a future release."
msgstr ""
"例えば、ある型が同じメソッドを持つ2つの`impl`を持つことができることが発見され"
"ました。\n"
"メソッドを2つ持つことができることがわかりました。これは悪いアイデアだと判断さ"
"れましたが、スムーズに移行するために、`overlapping-inherent-impls`というlint"
"が導入されました、\n"
"を導入し、この事実につまずいた人に警告を与えるようにしました。\n"
"将来のリリースでハードエラーになる前に。"

#: src/anti_patterns/deny-warnings.md:32
#, fuzzy
msgid ""
"Also sometimes APIs get deprecated, so their use will emit a warning where\n"
"before there was none."
msgstr ""
"また、APIが非推奨になることもあります。\n"
"が表示されます。"

#: src/anti_patterns/deny-warnings.md:35
#, fuzzy
msgid ""
"All this conspires to potentially break the build whenever something changes."
msgstr ""
"これらはすべて、何かが変わるたびにビルドを壊してしまう可能性があります。"

#: src/anti_patterns/deny-warnings.md:37
#, fuzzy
msgid ""
"Furthermore, crates that supply additional lints (e.g. [rust-clippy]) can "
"no\n"
"longer be used unless the annotation is removed. This is mitigated with\n"
"[--cap-lints]. The `--cap-lints=warn` command line argument, turns all "
"`deny`\n"
"lint errors into warnings."
msgstr ""
"さらに、追加のリントを提供するクレート（[rust-clippy]など）は、アノテーション"
"を削除しない限り使用できなくなりました。\n"
"アノテーションが削除されない限り使用できません。これは\n"
"[-cap-lints]で軽減できます。cap-lints=warn`コマンドライン引数を指定すると、す"
"べての `deny`\n"
"lint エラーを警告に変えます。"

#: src/anti_patterns/deny-warnings.md:42
#: src/functional/generics-type-classes.md:227
#, fuzzy
msgid "## Alternatives"
msgstr "## 代替案"

#: src/anti_patterns/deny-warnings.md:44
#, fuzzy
msgid ""
"There are two ways of tackling this problem: First, we can decouple the "
"build\n"
"setting from the code, and second, we can name the lints we want to deny\n"
"explicitly."
msgstr ""
"この問題に対処する方法は2つあります。\n"
"設定をコードから切り離すことができます。\n"
"を明示的に指定します。"

#: src/anti_patterns/deny-warnings.md:48
#, fuzzy
msgid "The following command line will build with all warnings set to `deny`:"
msgstr "次のコマンドラインは、すべての警告を `deny` に設定してビルドします："

#: src/anti_patterns/deny-warnings.md:50
#, fuzzy
msgid "`RUSTFLAGS=\"-D warnings\" cargo build`"
msgstr "RUSTFLAGS=\"-D warnings\" カーゴビルド`."

#: src/anti_patterns/deny-warnings.md:52
#, fuzzy
msgid ""
"This can be done by any individual developer (or be set in a CI tool like\n"
"Travis, but remember that this may break the build when something changes)\n"
"without requiring a change to the code."
msgstr ""
"これは個々の開発者が行うことができます（あるいは\n"
"TravisのようなCIツールで設定することもできます。）\n"
"コードに変更を加える必要はありません。"

#: src/anti_patterns/deny-warnings.md:56
#, fuzzy
msgid ""
"Alternatively, we can specify the lints that we want to `deny` in the code.\n"
"Here is a list of warning lints that is (hopefully) safe to deny (as of "
"Rustc 1.48.0):"
msgstr ""
"あるいは、コード中で `deny` したいリントを指定することもできます。\n"
"以下は、(できれば) 拒否しても問題ない警告リントのリストです (Rustc 1.48.0 現"
"在)："

#: src/anti_patterns/deny-warnings.md:59
#, fuzzy
msgid ""
"```rust,ignore\n"
"#![deny(bad_style,\n"
"       const_err,\n"
"       dead_code,\n"
"       improper_ctypes,\n"
"       non_shorthand_field_patterns,\n"
"       no_mangle_generic_items,\n"
"       overflowing_literals,\n"
"       path_statements,\n"
"       patterns_in_fns_without_body,\n"
"       private_in_public,\n"
"       unconditional_recursion,\n"
"       unused,\n"
"       unused_allocation,\n"
"       unused_comparisons,\n"
"       unused_parens,\n"
"       while_true)]\n"
"```"
msgstr ""
"錆、無視\n"
"#![deny(bad_style、\n"
"       const_err、\n"
"       dead_code、\n"
"       improper_ctypes、\n"
"       non_shorthand_field_patterns、\n"
"       no_mangle_generic_items、\n"
"       overflowing_literals、\n"
"       path_statements、\n"
"       pattern_in_fns_without_body、\n"
"       private_in_public、\n"
"       無条件再帰、\n"
"       unused、\n"
"       unused_allocation、\n"
"       unused_comparisons、\n"
"       unused_parens、\n"
"       while_true)] を参照してください。\n"
"```"

#: src/anti_patterns/deny-warnings.md:78
#, fuzzy
msgid ""
"In addition, the following `allow`ed lints may be a good idea to `deny`:"
msgstr "さらに、以下の`allow`されたリントは`deny`するのがよいでしょう："

#: src/anti_patterns/deny-warnings.md:80
#, fuzzy
msgid ""
"```rust,ignore\n"
"#![deny(missing_debug_implementations,\n"
"       missing_docs,\n"
"       trivial_casts,\n"
"       trivial_numeric_casts,\n"
"       unused_extern_crates,\n"
"       unused_import_braces,\n"
"       unused_qualifications,\n"
"       unused_results)]\n"
"```"
msgstr ""
"``rust,ignore\n"
"#![deny(missing_debug_implementations、\n"
"       missing_docs、\n"
"       trivial_casts、\n"
"       trivial_numeric_casts、\n"
"       unused_extern_crates、\n"
"       unused_import_braces、\n"
"       unused_qualifications、\n"
"       unused_results)] を参照してください。\n"
"```"

#: src/anti_patterns/deny-warnings.md:91
#, fuzzy
msgid "Some may also want to add `missing-copy-implementations` to their list."
msgstr ""
"また、`missing-copy-implementations`をリストに加えたい人もいるでしょう。"

#: src/anti_patterns/deny-warnings.md:93
#, fuzzy
msgid ""
"Note that we explicitly did not add the `deprecated` lint, as it is fairly\n"
"certain that there will be more deprecated APIs in the future."
msgstr ""
"deprecated`のlintを明示的に追加していないことに注意してください。\n"
"将来的に非推奨のAPIが増えることは確実だからです。"

#: src/anti_patterns/deny-warnings.md:98
#, fuzzy
msgid ""
"- [A collection of all clippy lints](https://rust-lang.github.io/rust-clippy/"
"master)\n"
"- [deprecate attribute] documentation\n"
"- Type `rustc -W help` for a list of lints on your system. Also type\n"
"  `rustc --help` for a general list of options\n"
"- [rust-clippy] is a collection of lints for better Rust code"
msgstr ""
"- [すべてのクリッピーリントのコレクション](https://rust-lang.github.io/rust-"
"clippy/master)\n"
"- [非推奨属性] ドキュメント\n"
"- rustc -W help` と入力するとシステム上の lints のリストが表示されます。ま"
"た\n"
"  rustc --help` と入力すると一般的なオプションのリストが表示されます。\n"
"- [rust-clippy] はより良い Rust コードのための lints のコレクションです。"

#: src/anti_patterns/deref.md:1
#, fuzzy
msgid "# `Deref` polymorphism"
msgstr "# `Deref` ポリモーフィズム"

#: src/anti_patterns/deref.md:5
#, fuzzy
msgid ""
"Misuse the `Deref` trait to emulate inheritance between structs, and thus "
"reuse\n"
"methods."
msgstr ""
"構造体間の継承をエミュレートするために `Deref` 特性を悪用して、メソッドを再利"
"用しています。\n"
"メソッドを再利用します。"

#: src/anti_patterns/deref.md:10
#, fuzzy
msgid ""
"Sometimes we want to emulate the following common pattern from OO languages "
"such\n"
"as Java:"
msgstr ""
"JavaのようなOO言語から、次のような一般的なパターンをエミュレートしたいことが"
"あります。\n"
"をエミュレートしたいことがあります："

#: src/anti_patterns/deref.md:13
#, fuzzy
msgid ""
"```java\n"
"class Foo {\n"
"    void m() { ... }\n"
"}\n"
"\n"
"class Bar extends Foo {}\n"
"\n"
"public static void main(String[] args) {\n"
"    Bar b = new Bar();\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""
"java\n"
"クラス Foo {\n"
"    void m() { ...}\n"
"}\n"
"\n"
"クラス Bar extends Foo [0］\n"
"\n"
"public static void main(String[] args) {\n"
"    Bar b = new Bar()；\n"
"    b.m()；\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:26
#, fuzzy
msgid "We can use the deref polymorphism anti-pattern to do so:"
msgstr "そのためにderefポリモーフィズムのアンチパターンを使うことができます："

#: src/anti_patterns/deref.md:28
#, fuzzy
msgid ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo,\n"
"}\n"
"\n"
"impl Deref for Bar {\n"
"    type Target = Foo;\n"
"    fn deref(&self) -> &Foo {\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} };\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"std::ops::Derefを使用します；\n"
"\n"
"struct Foo [0］\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo、\n"
"}\n"
"\n"
"impl Deref for Bar { 以下のようになります。\n"
"    型 Target = Foo；\n"
"    fn deref(&self) -> &Foo { 以下のようになります。\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} }；\n"
"    b.m()；\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:56
#, fuzzy
msgid ""
"There is no struct inheritance in Rust. Instead we use composition and "
"include\n"
"an instance of `Foo` in `Bar` (since the field is a value, it is stored "
"inline,\n"
"so if there were fields, they would have the same layout in memory as the "
"Java\n"
"version (probably, you should use `#[repr(C)]` if you want to be sure))."
msgstr ""
"Rustには構造体の継承はありません。代わりにコンポジションを使用し\n"
"フィールドは値なので、インラインで格納されます、\n"
"フィールドがあったとしても、Javaバージョンと同じメモリレイアウトになりま"
"す。\n"
"おそらく、念のため `#[repr(C)]` を使うべきです）。"

#: src/anti_patterns/deref.md:61
#, fuzzy
msgid ""
"In order to make the method call work we implement `Deref` for `Bar` with "
"`Foo`\n"
"as the target (returning the embedded `Foo` field). That means that when we\n"
"dereference a `Bar` (for example, using `*`) then we will get a `Foo`. That "
"is\n"
"pretty weird. Dereferencing usually gives a `T` from a reference to `T`, "
"here we\n"
"have two unrelated types. However, since the dot operator does implicit\n"
"dereferencing, it means that the method call will search for methods on "
"`Foo` as\n"
"well as `Bar`."
msgstr ""
"メソッドコールを動作させるために、`Bar` に対して `Foo` をターゲットとして "
"`Deref` を実装します（埋め込まれた `Foo` フィールドを返します）。\n"
"をターゲットとして実装します（埋め込まれた `Foo` フィールドを返します）。つま"
"り\n"
"例えば、`*` を使って）`Bar` を参照解除すると、`Foo` が返されるということで"
"す。これは\n"
"はかなり奇妙です。デリファレンスは通常 `T` への参照から `T` を返します。\n"
"への参照から `T` を返します。しかし、ドット演算子は暗黙的に\n"
"のメソッドを検索することになります。\n"
"のメソッドを検索することになります。"

#: src/anti_patterns/deref.md:71
#, fuzzy
msgid "You save a little boilerplate, e.g.,"
msgstr "ちょっとした定型文を節約できます、"

#: src/anti_patterns/deref.md:73
#, fuzzy
msgid ""
"```rust,ignore\n"
"impl Bar {\n"
"    fn m(&self) {\n"
"        self.f.m()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"impl Bar {\n"
"    fn m(&self) {\n"
"        self.f.m()\n"
"    }\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:83
#, fuzzy
msgid ""
"Most importantly this is a surprising idiom - future programmers reading "
"this in\n"
"code will not expect this to happen. That's because we are misusing the "
"`Deref`\n"
"trait rather than using it as intended (and documented, etc.). It's also "
"because\n"
"the mechanism here is completely implicit."
msgstr ""
"最も重要なことは、これは驚くべきイディオムであるということです。\n"
"コードでこれを読む将来のプログラマーは、このようなことが起こるとは思わないで"
"しょう。それは、私たちが `Deref`\n"
"の特性を間違って使っているからです。また\n"
"このメカニズムは完全に暗黙的なものだからです。"

#: src/anti_patterns/deref.md:88
#, fuzzy
msgid ""
"This pattern does not introduce subtyping between `Foo` and `Bar` like\n"
"inheritance in Java or C++ does. Furthermore, traits implemented by `Foo` "
"are\n"
"not automatically implemented for `Bar`, so this pattern interacts badly "
"with\n"
"bounds checking and thus generic programming."
msgstr ""
"このパターンでは、JavaやC++の継承のように`Foo`と`Bar`の間にサブタイプは導入さ"
"れません。\n"
"や C++ の継承のように、`Foo` と `Bar` の間に部分型を導入することはありませ"
"ん。さらに、 `Foo` で実装された trait は自動的に `Bar` で実装されるわけではあ"
"りません。\n"
"で実装された trait は自動的に `Bar` に実装されるわけではないので、このパター"
"ンは境界チェックや\n"
"そのため、このパターンは境界チェックやジェネリックプログラミングとの相互作用"
"が悪くなります。"

#: src/anti_patterns/deref.md:93
#, fuzzy
msgid ""
"Using this pattern gives subtly different semantics from most OO languages "
"with\n"
"regards to `self`. Usually it remains a reference to the sub-class, with "
"this\n"
"pattern it will be the 'class' where the method is defined."
msgstr ""
"このパターンを使うと、`self`に関して、ほとんどのOO言語とは微妙に異なるセマン"
"ティクスが得られます。\n"
"self`に関して、ほとんどのOO言語とは微妙に異なるセマンティクスを与えます。通常"
"はサブクラスへの参照のままです。\n"
"パターンではメソッドが定義されている 'クラス' になります。"

#: src/anti_patterns/deref.md:97
#, fuzzy
msgid ""
"Finally, this pattern only supports single inheritance, and has no notion "
"of\n"
"interfaces, class-based privacy, or other inheritance-related features. So, "
"it\n"
"gives an experience that will be subtly surprising to programmers used to "
"Java\n"
"inheritance, etc."
msgstr ""
"最後に、このパターンは単一継承のみをサポートし、インターフェイスの概念はあり"
"ません。\n"
"インターフェイス、クラスベースのプライバシー、その他の継承に関連する機能はあ"
"りません。そのため\n"
"Javaの継承などに慣れているプログラマにとっては、微妙に驚くような体験になるで"
"しょう。\n"
"継承などに慣れているプログラマにとっては、微妙に驚くような経験をすることにな"
"ります。"

#: src/anti_patterns/deref.md:104
#, fuzzy
msgid ""
"There is no one good alternative. Depending on the exact circumstances it "
"might\n"
"be better to re-implement using traits or to write out the facade methods "
"to\n"
"dispatch to `Foo` manually. We do intend to add a mechanism for inheritance\n"
"similar to this to Rust, but it is likely to be some time before it reaches\n"
"stable Rust. See these [blog](http://aturon.github.io/blog/2015/09/18/"
"reuse/)\n"
"[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-"
"structs-part-4-extended-enums-and-thin-traits/)\n"
"and this [RFC issue](https://github.com/rust-lang/rfcs/issues/349) for more "
"details."
msgstr ""
"良い選択肢は一つもありません。状況によっては\n"
"にディスパッチするためのファサードメソッドを手作業で書き出すほうがよいかもし"
"れません。\n"
"にディスパッチするためのファサードメソッドを手作業で書き出す方が良いかもしれ"
"ません。このような継承の仕組みをRustに追加する予定です。\n"
"に似た継承の仕組みをRustに追加する予定です。\n"
"に到達するまでにはまだ時間がかかりそうです。ブログ](http://aturon.github.io/"
"blog/2015/09/18/reuse/)\n"
"[投稿](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-"
"structs-part-4-extended-enums-and-thin-traits/)\n"
"およびこの [RFC issue](https://github.com/rust-lang/rfcs/issues/349) を参照し"
"てください。"

#: src/anti_patterns/deref.md:112
#, fuzzy
msgid ""
"The `Deref` trait is designed for the implementation of custom pointer "
"types.\n"
"The intention is that it will take a pointer-to-`T` to a `T`, not convert\n"
"between different types. It is a shame that this isn't (probably cannot be)\n"
"enforced by the trait definition."
msgstr ""
"Deref` 特性はカスタムポインタ型の実装のために設計されています。\n"
"これは、ポインタから `T` を `T` に変換するもので、異なる型間の変換を行うもの"
"ではありません。\n"
"へのポインタを `T` に変換することを意図しています。これが（おそらくできない）"
"のは残念です。\n"
"によって強制されないのは残念です。"

#: src/anti_patterns/deref.md:117
#, fuzzy
msgid ""
"Rust tries to strike a careful balance between explicit and implicit "
"mechanisms,\n"
"favouring explicit conversions between types. Automatic dereferencing in the "
"dot\n"
"operator is a case where the ergonomics strongly favour an implicit "
"mechanism,\n"
"but the intention is that this is limited to degrees of indirection, not\n"
"conversion between arbitrary types."
msgstr ""
"Rustは、明示的なメカニズムと暗黙的なメカニズムのバランスを慎重に取ろうとして"
"います、\n"
"型間の明示的な変換を優先します。ドット\n"
"演算子での自動再参照は、人間工学的に暗黙的な機構を強く支持するケースです、\n"
"しかし、これは間接的なものに限定されており、任意の型間の変換を行うものではあ"
"りません。\n"
"任意の型間の変換ではありません。"

#: src/anti_patterns/deref.md:125
#, fuzzy
msgid ""
"- [Collections are smart pointers idiom](../idioms/deref.md).\n"
"- Delegation crates for less boilerplate like [delegate](https://crates.io/"
"crates/delegate)\n"
"  or [ambassador](https://crates.io/crates/ambassador)\n"
"- [Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."
msgstr ""
"- [Collections are smart pointers idiom](../idioms/deref.md).\n"
"- delegate](https://crates.io/crates/delegate)のような、より定型的でないデリ"
"ゲーション・クレート。\n"
"  または [ambassador](https://crates.io/crates/ambassador)\n"
"- [Deref` 特性のドキュメント](https://doc.rust-lang.org/std/ops/trait.Deref."
"html)."

#: src/functional/index.md:1
#, fuzzy
msgid "# Functional Usage of Rust"
msgstr "# ラストの機能的使用法"

#: src/functional/index.md:3
#, fuzzy
msgid ""
"Rust is an imperative language, but it follows many\n"
"[functional programming](https://en.wikipedia.org/wiki/"
"Functional_programming) paradigms."
msgstr ""
"Rustは命令型言語ですが、多くの[関数型プログラミング]()パラダイムに従っていま"
"す。\n"
"[関数型プログラミング](https://en.wikipedia.org/wiki/Functional_programming)"
"のパラダイムに従っています。"

#: src/functional/index.md:6
#, fuzzy
msgid ""
"> In computer science, _functional programming_ is a programming paradigm "
"where\n"
"> programs are constructed by applying and composing functions.\n"
"> It is a declarative programming paradigm in which function definitions "
"are\n"
"> trees of expressions that each return a value, rather than a sequence of\n"
"> imperative statements which change the state of the program."
msgstr ""
"> コンピュータ・サイエンスにおいて、関数型プログラミングとは、関数を適用し、"
"組み合わせることでプログラムを構成するプログラミング・パラダイムです。\n"
"> 関数の適用と組み合わせによってプログラムが構築されます。\n"
"> 宣言的なプログラミングパラダイムであり、関数の定義が一連の式ではなく\n"
"> 関数の定義が、一連の命令文ではなく、それぞれ値を返す式のツリーである宣言型"
"プログラミングのパラダイムです。\n"
"> プログラムの状態を変更する命令文の連続ではなく、関数定義がそれぞれ値を返す"
"式のツリーである宣言的プログラミングパラダイムです。"

#: src/functional/paradigms.md:1
#, fuzzy
msgid "# Programming paradigms"
msgstr "# プログラミングパラダイム"

#: src/functional/paradigms.md:3
#, fuzzy
msgid ""
"One of the biggest hurdles to understanding functional programs when coming\n"
"from an imperative background is the shift in thinking. Imperative programs\n"
"describe **how** to do something, whereas declarative programs describe\n"
"**what** to do. Let's sum the numbers from 1 to 10 to show this."
msgstr ""
"関数型プログラムを理解する上で、命令型プログラム出身者にとって最大のハードル"
"のひとつは、考え方の転換です。\n"
"それは考え方の転換です。命令型プログラムは\n"
"は何かをする**方法**を記述するのに対し、宣言型プログラムは\n"
"**宣言型プログラムは「何をするか」を記述します。これを示すために1から10までの"
"数字を合計してみましょう。"

#: src/functional/paradigms.md:8
#, fuzzy
msgid "## Imperative"
msgstr "## ♪ インペラティブ"

#: src/functional/paradigms.md:10
#, fuzzy
msgid ""
"```rust\n"
"let mut sum = 0;\n"
"for i in 1..11 {\n"
"    sum += i;\n"
"}\n"
"println!(\"{}\", sum);\n"
"```"
msgstr ""
"ラスト\n"
"mut sum = 0；\n"
"for i in 1.\n"
"    sum += i；\n"
"}\n"
"println!(\"{}\", sum)；\n"
"```"

#: src/functional/paradigms.md:18
#, fuzzy
msgid ""
"With imperative programs, we have to play compiler to see what is "
"happening.\n"
"Here, we start with a `sum` of `0`.\n"
"Next, we iterate through the range from 1 to 10.\n"
"Each time through the loop, we add the corresponding value in the range.\n"
"Then we print it out."
msgstr ""
"命令型プログラムでは、何が起こっているのかを確認するためにコンパイラを動かす"
"必要があります。\n"
"ここでは、まず`sum`を`0`とします。\n"
"次に、1から10までの範囲を繰り返します。\n"
"ループの各回で、範囲内の対応する値を加算します。\n"
"そしてそれを出力します。"

#: src/functional/paradigms.md:24
#, fuzzy
msgid ""
"| `i` | `sum` |\n"
"| :-: | :---: |\n"
"|  1  |   1   |\n"
"|  2  |   3   |\n"
"|  3  |   6   |\n"
"|  4  |  10   |\n"
"|  5  |  15   |\n"
"|  6  |  21   |\n"
"|  7  |  28   |\n"
"|  8  |  36   |\n"
"|  9  |  45   |\n"
"| 10  |  55   |"
msgstr ""
"| `i` | `sum`\n"
"| :-:| :---:|\n"
"| 1 | 1 |\n"
"| 2 | 3 |\n"
"| 3 | 6 |\n"
"| 4 | 10 |\n"
"| 5 | 15 |\n"
"| 6 | 21 |\n"
"| 7 | 28 |\n"
"| 8 | 36 |\n"
"| 9 | 45 |\n"
"| 10 | 55 |"

#: src/functional/paradigms.md:37
#, fuzzy
msgid ""
"This is how most of us start out programming. We learn that a program is a "
"set\n"
"of steps."
msgstr ""
"私たちの多くは、こうしてプログラミングを始めます。プログラムは\n"
"ステップの"

#: src/functional/paradigms.md:40
#, fuzzy
msgid "## Declarative"
msgstr "## 宣言的"

#: src/functional/paradigms.md:42
#, fuzzy
msgid ""
"```rust\n"
"println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
"```"
msgstr ""
"ラスト\n"
"println!(\"{}\", (1..11).fold(0, |a, b| a + b))；\n"
"```"

#: src/functional/paradigms.md:46
#, fuzzy
msgid ""
"Whoa! This is really different! What's going on here?\n"
"Remember that with declarative programs we are describing **what** to do,\n"
"rather than **how** to do it. `fold` is a function that [composes](https://"
"en.wikipedia.org/wiki/Function_composition)\n"
"functions. The name is a convention from Haskell."
msgstr ""
"おっ！これは本当に違うどうなってるの？\n"
"宣言型プログラムでは、**どのように**実行するかではなく、**何を**実行するかを"
"記述していることを覚えておいてください、\n"
"ではなく、**どのように**行うかを記述していることを思い出してください。fold`は"
"関数を[合成](https://en.wikipedia.org/wiki/Function_composition)する関数で"
"す。\n"
"関数を構成する関数です。この名前はHaskellからの慣例です。"

#: src/functional/paradigms.md:51
#, fuzzy
msgid ""
"Here, we are composing functions of addition (this closure: `|a, b| a + b`)\n"
"with a range from 1 to 10. The `0` is the starting point, so `a` is `0` at\n"
"first. `b` is the first element of the range, `1`. `0 + 1 = 1` is the "
"result.\n"
"So now we `fold` again, with `a = 1`, `b = 2` and so `1 + 2 = 3` is the "
"next\n"
"result. This process continues until we get to the last element in the "
"range,\n"
"`10`."
msgstr ""
"ここでは、足し算の関数（このクロージャ：`|a, b| a + b`）を1から10までの範囲で"
"合成しています。\n"
"を1から10までの範囲で合成しています。0`は開始点なので、`a`は最初は`0`です。\n"
"の最初の要素です。b` は範囲の最初の要素である `1` です。0 + 1 = 1` が結果で"
"す。\n"
"ということで、また `a` を `1`、`b` を `2`と `fold` して、`1 + 2 = 3` が次の結"
"果です。\n"
"となります。このプロセスは範囲の最後の要素まで続きます、\n"
"`10`."

#: src/functional/paradigms.md:58
#, fuzzy
msgid ""
"| `a` | `b` | result |\n"
"| :-: | :-: | :----: |\n"
"|  0  |  1  |   1    |\n"
"|  1  |  2  |   3    |\n"
"|  3  |  3  |   6    |\n"
"|  6  |  4  |   10   |\n"
"| 10  |  5  |   15   |\n"
"| 15  |  6  |   21   |\n"
"| 21  |  7  |   28   |\n"
"| 28  |  8  |   36   |\n"
"| 36  |  9  |   45   |\n"
"| 45  | 10  |   55   |"
msgstr ""
"| a` | `b` | 結果\n"
"| :-:| :-:| :----:|\n"
"| 0 | 1 | 1 |\n"
"| 1 | 2 | 3 |\n"
"| 3 | 3 | 6 |\n"
"| 6 | 4 | 10 |\n"
"| 10 | 5 | 15 |\n"
"| 15 | 6 | 21 |\n"
"| 21 | 7 | 28 |\n"
"| 28 | 8 | 36 |\n"
"| 36 | 9 | 45 |\n"
"| 45 | 10 | 55 |"

#: src/functional/generics-type-classes.md:1
#, fuzzy
msgid "# Generics as Type Classes"
msgstr "# 型クラスとしてのジェネリック"

#: src/functional/generics-type-classes.md:5
#, fuzzy
msgid ""
"Rust's type system is designed more like functional languages (like "
"Haskell)\n"
"rather than imperative languages (like Java and C++). As a result, Rust can "
"turn\n"
"many kinds of programming problems into \"static typing\" problems. This is "
"one\n"
"of the biggest wins of choosing a functional language, and is critical to "
"many\n"
"of Rust's compile time guarantees."
msgstr ""
"Rustの型システムは、（JavaやC++のような）命令型言語ではなく、（Haskellのよう"
"な）関数型言語のように設計されています。\n"
"のような関数型言語のように設計されています。その結果、Rustは\n"
"多くのプログラミング問題を「静的型付け」の問題に変えることができます。これ"
"は\n"
"関数型言語を選択する最大の利点の1つであり、Rustの多くのコンパイル時\n"
"Rustのコンパイル時保証の多くにとって重要です。"

#: src/functional/generics-type-classes.md:11
#, fuzzy
msgid ""
"A key part of this idea is the way generic types work. In C++ and Java, for\n"
"example, generic types are a meta-programming construct for the compiler.\n"
"`vector<int>` and `vector<char>` in C++ are just two different copies of "
"the\n"
"same boilerplate code for a `vector` type (known as a `template`) with two\n"
"different types filled in."
msgstr ""
"この考え方の重要な部分は、ジェネリック型の動作方法です。たとえばC++やJavaで"
"は\n"
"例えばC++やJavaでは、ジェネリック型はコンパイラのメタプログラミング構文で"
"す。\n"
"C++ における `vector<int>` と `vector<char>` は、`vector` 型のための同じ定型"
"的なコードの2つの異なるコピーにすぎません。\n"
"C++ における `vector  ` と `vector  ` は、`vector` 型（`テンプレート`` として"
"知られています）に対する同じ定型コードに2つの異なる型を追加したものです。\n"
"型が記入されています。"

#: src/functional/generics-type-classes.md:17
#, fuzzy
msgid ""
"In Rust, a generic type parameter creates what is known in functional "
"languages\n"
"as a \"type class constraint\", and each different parameter filled in by an "
"end\n"
"user _actually changes the type_. In other words, `Vec<isize>` and "
"`Vec<char>`\n"
"_are two different types_, which are recognized as distinct by all parts of "
"the\n"
"type system."
msgstr ""
"Rustでは、汎用型パラメータは関数型言語で「型クラス制約」として知られているも"
"のを作成します。\n"
"型クラス制約 \"として関数型言語で知られているものを作成します。\n"
"によって埋められるパラメータが異なるたびに、型が変更されます。言い換えると、"
"`Vec<isize>` と `Vec<char>` は異なる型です。\n"
"は2つの異なる型です。\n"
"型システムのすべての部分によって別個の型として認識されます。"

#: src/functional/generics-type-classes.md:23
#, fuzzy
msgid ""
"This is called **monomorphization**, where different types are created from\n"
"**polymorphic** code. This special behavior requires `impl` blocks to "
"specify\n"
"generic parameters. Different values for the generic type cause different "
"types,\n"
"and different types can have different `impl` blocks."
msgstr ""
"これは**単型化**と呼ばれ、異なる型が**多相**コードから作成されます。\n"
"**ポリモーフィック** コードから異なる型が生成されます。この特別な動作には、"
"`impl`ブロックにジェネリックパラメータを指定する必要があります。\n"
"ジェネリックパラメータを指定する必要があります。ジェネリック型の値が異なる"
"と、異なる型が生成されます、\n"
"そして、異なる型は異なる `impl` ブロックを持つことができます。"

#: src/functional/generics-type-classes.md:28
#, fuzzy
msgid ""
"In object-oriented languages, classes can inherit behavior from their "
"parents.\n"
"However, this allows the attachment of not only additional behavior to\n"
"particular members of a type class, but extra behavior as well."
msgstr ""
"オブジェクト指向言語では、クラスは親から振る舞いを継承することができます。\n"
"しかし、これによって、特定の型クラスのメンバに追加的な振る舞いを与えるだけで"
"なく\n"
"型クラスの特定のメンバだけでなく、余分な振る舞いも追加することができます。"

#: src/functional/generics-type-classes.md:32
#, fuzzy
msgid ""
"The nearest equivalent is the runtime polymorphism in Javascript and "
"Python,\n"
"where new members can be added to objects willy-nilly by any constructor.\n"
"However, unlike those languages, all of Rust's additional methods can be "
"type\n"
"checked when they are used, because their generics are statically defined. "
"That\n"
"makes them more usable while remaining safe."
msgstr ""
"これに最も近いのは、JavascriptやPythonのランタイム・ポリモーフィズムです、\n"
"では、コンストラクタによって新しいメンバを自由にオブジェクトに追加できま"
"す。\n"
"しかし、これらの言語とは異なり、Rustの追加メソッドはすべて、ジェネリックが静"
"的に定義されているため、使用時に型チェックを行うことができます。\n"
"チェックすることができます。そのため\n"
"そのため、安全性を保ちながら、より使いやすくなっています。"

#: src/functional/generics-type-classes.md:40
#, fuzzy
msgid ""
"Suppose you are designing a storage server for a series of lab machines.\n"
"Because of the software involved, there are two different protocols you "
"need\n"
"to support: BOOTP (for PXE network boot), and NFS (for remote mount storage)."
msgstr ""
"あなたは、一連のラボマシン用のストレージサーバーを設計しているとします。\n"
"ソフトウェアが関係するため、次の2つの異なるプロトコルをサポートする必要があり"
"ます。\n"
"があります：BOOTP（PXEネットワークブート用）とNFS（リモートマウントストレージ"
"用）です。"

#: src/functional/generics-type-classes.md:44
#, fuzzy
msgid ""
"Your goal is to have one program, written in Rust, which can handle both of\n"
"them. It will have protocol handlers and listen for both kinds of requests. "
"The\n"
"main application logic will then allow a lab administrator to configure "
"storage\n"
"and security controls for the actual files."
msgstr ""
"あなたの目標は、Rustで書かれた1つのプログラムで、その両方を処理できるようにす"
"ることです。\n"
"です。このプログラムはプロトコルハンドラを持ち、両方のリクエストを待ち受けま"
"す。そして\n"
"メインのアプリケーションロジックは、ラボの管理者が実際のファイルのストレージ"
"とセキュリティ制御を設定できるようにします。\n"
"と実際のファイルのセキュリティ制御を設定できるようにします。"

#: src/functional/generics-type-classes.md:49
#, fuzzy
msgid ""
"The requests from machines in the lab for files contain the same basic\n"
"information, no matter what protocol they came from: an authentication "
"method,\n"
"and a file name to retrieve. A straightforward implementation would look\n"
"something like this:"
msgstr ""
"ラボのマシンからファイルへのリクエストには、どのプロトコルから来たものであっ"
"ても、同じ基本情報\n"
"どのようなプロトコルからのリクエストであっても、基本的な情報は同じです、\n"
"そして取得するファイル名です。認証方法と取得するファイル名です。\n"
"このようになります："

#: src/functional/generics-type-classes.md:54
#, fuzzy
msgid ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"
msgstr ""
"不信,無視\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo)、\n"
"    Bootp(crate::bootp::AuthInfo)、\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf、\n"
"    authentication：AuthInfo、\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:66
#, fuzzy
msgid ""
"This design might work well enough. But now suppose you needed to support\n"
"adding metadata that was _protocol specific_. For example, with NFS, you\n"
"wanted to determine what their mount point was in order to enforce "
"additional\n"
"security rules."
msgstr ""
"このデザインは十分に機能するかもしれません。しかし、次に\n"
"メタデータの追加をサポートする必要があるとします。例えば、NFSで\n"
"例えばNFSの場合、追加のセキュリティ・ルールを適用するために、そのマウント・ポ"
"イントが何であるかを判断したいとします。\n"
"セキュリティ・ルールを適用するために、そのマウント・ポイントが何であるかを決"
"定したいとします。"

#: src/functional/generics-type-classes.md:71
#, fuzzy
msgid ""
"The way the current struct is designed leaves the protocol decision until\n"
"runtime. That means any method that applies to one protocol and not the "
"other\n"
"requires the programmer to do a runtime check."
msgstr ""
"現在の構造体の設計では、プロトコルの決定は実行時まで残されています。\n"
"まで残します。つまり、一方のプロトコルに適用され、もう一方のプロトコルに適用"
"されないメソッドは、プログラマが実行時にチェックする必要があります。\n"
"は、プログラマが実行時にチェックする必要があります。"

#: src/functional/generics-type-classes.md:75
#, fuzzy
msgid "Here is how getting an NFS mount point would look:"
msgstr "NFSマウントポイントの取得は以下のようになります："

#: src/functional/generics-type-classes.md:77
#, fuzzy
msgid ""
"```rust,ignore\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"    mount_point: Option<PathBuf>,\n"
"}\n"
"\n"
"impl FileDownloadRequest {\n"
"    // ... other methods ...\n"
"\n"
"    /// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
"    /// return None.\n"
"    pub fn mount_point(&self) -> Option<&Path> {\n"
"        self.mount_point.as_ref()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"struct FileDownloadRequest {\n"
"    ファイル名: PathBuf、\n"
"    認証：AuthInfo、\n"
"    mount_point：オプション<PathBuf> 、\n"
"}\n"
"\n"
"impl FileDownloadRequest {\n"
"    // ... その他のメソッド\n"
"\n"
"    /// NFSリクエストの場合はNFSマウントポイントを取得します。それ以外の場合"
"は\n"
"    /// None を返します。\n"
"    pub fn mount_point(&amp;self) -&gt; Option<&Path> { 以下のようになりま"
"す。\n"
"        self.mount_point.as_ref()\n"
"    }\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:95
#, fuzzy
msgid ""
"Every caller of `mount_point()` must check for `None` and write code to "
"handle\n"
"it. This is true even if they know only NFS requests are ever used in a "
"given\n"
"code path!"
msgstr ""
"mount_point()`のすべての呼び出し元は `None` をチェックして、それを処理する"
"コードを書かなければなりません。\n"
"をチェックし、それを処理するコードを書かなければなりません。これは、たとえ "
"NFS リクエストしか使われないと知っていたとしても同じです。\n"
"をチェックし、それを処理するコードを書かなければなりません！"

#: src/functional/generics-type-classes.md:99
#, fuzzy
msgid ""
"It would be far more optimal to cause a compile-time error if the different\n"
"request types were confused. After all, the entire path of the user's code,\n"
"including what functions from the library they use, will know whether a "
"request\n"
"is an NFS request or a BOOTP request."
msgstr ""
"もし異なるリクエストタイプが混同されるのであれば、コンパイル時に エラーを発生"
"させる方がはるかに最適でしょう。\n"
"を発生させる方がはるかに最適でしょう。結局のところ、ユーザのコードのパス全体"
"は\n"
"ライブラリのどの関数を使うかを含めて、ユーザのコードのパス全体が、 リクエスト"
"がNFSリクエストなのかBOOTPリクエストなのかを知ることになります。\n"
"が NFS リクエストなのか BOOTP リクエストなのかを知ることができます。"

#: src/functional/generics-type-classes.md:104
#, fuzzy
msgid ""
"In Rust, this is actually possible! The solution is to _add a generic type_ "
"in\n"
"order to split the API."
msgstr ""
"Rustでは、これは実際に可能です！解決策は、APIを分割するためにジェネリック型を"
"追加することです。\n"
"を追加することです。"

#: src/functional/generics-type-classes.md:107
#, fuzzy
msgid "Here is what that looks like:"
msgstr "こんな感じです："

#: src/functional/generics-type-classes.md:109
#, fuzzy
msgid ""
"```rust\n"
"use std::path::{Path, PathBuf};\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFS session management omitted\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // no authentication in bootp\n"
"}\n"
"\n"
"// private module, lest outside users invent their own protocol kinds!\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf};\n"
"    use super::{bootp, nfs};\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        type AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo;\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo,\n"
"        mount_point: PathBuf,\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&self) -> &Path {\n"
"            &self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs {\n"
"        type AuthInfo = nfs::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // no additional metadata\n"
"\n"
"    impl ProtoKind for Bootp {\n"
"        type AuthInfo = bootp::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // keep internal to prevent impls\n"
"pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> {\n"
"    file_name: PathBuf,\n"
"    protocol: P,\n"
"}\n"
"\n"
"// all common API parts go into a generic impl block\n"
"impl<P: ProtoKind> FileDownloadRequest<P> {\n"
"    fn file_path(&self) -> &Path {\n"
"        &self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&self) -> P::AuthInfo {\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// all protocol-specific impls go into their own block\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&self) -> &Path {\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // your code here\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"std::path::{Path, PathBuf}を使用します；\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFSセッション管理省略\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // bootpでの認証はありません。\n"
"}\n"
"\n"
"// 外部ユーザが独自のプロトコルを作らないようにするためです！\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf}；\n"
"    use super::{bootp, nfs}；\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        型 AuthInfo；\n"
"        fn auth_info(&amp;self) -&gt; Self::AuthInfo；\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo、\n"
"        mount_point：PathBuf、\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&amp;self) -&gt; &amp;Path { 以下のようにな"
"ります。\n"
"            &amp;self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs { Nfs::AuthInfo; type AuthInfo = nfs::AuthInfo\n"
"        type AuthInfo = nfs::AuthInfo；\n"
"        fn auth_info(&amp;self) -&gt; Self::AuthInfo { { auth.auth.clone()\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // メタデータの追加はありません。\n"
"\n"
"    impl ProtoKind for Bootp { 以下のようになります。\n"
"        type AuthInfo = bootp::AuthInfo；\n"
"        fn auth_info(&amp;self) -&gt; Self::AuthInfo { 以下のようになりま"
"す。\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // インプットを防ぐために内部を維持します。\n"
"pub use proto_trait::{Nfs, Bootp}; // 呼び出し元が見えるように再エクスポート"
"します。\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> { 以下のようにします。\n"
"    file_name: PathBuf、\n"
"    protocol：P,\n"
"}\n"
"\n"
"// すべての共通 API パーツは、一般的な impl ブロックに入ります。\n"
"impl<P: ProtoKind> FileDownloadRequest<P> { 以下のようになります。\n"
"    FN FILE_PATH(&amp;SELF) -&gt; &amp;PATH { ファイルパス。\n"
"        &amp;self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&amp;self) -&gt; P::AuthInfo { { auth_info()\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// すべてのプロトコル固有のインプットは、それ自身のブロックに入ります。\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&amp;self) -&gt; &amp;Path { {.\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // ここにあなたのコード\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:190
#, fuzzy
msgid ""
"With this approach, if the user were to make a mistake and use the wrong\n"
"type;"
msgstr ""
"このアプローチでは、もしユーザーが間違えて間違ったタイプを使ったとしても\n"
"タイプを使ってしまったとします；"

#: src/functional/generics-type-classes.md:193
#, fuzzy
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?;\n"
"    while let Some(request) = socket.next_request()? {\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\"),\n"
"            _ => {} // continue on...\n"
"        }\n"
"        // Rest of the code here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?\n"
"    while let Some(request) = socket.next_request()?{\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\")、\n"
"            _ => {} // 続けます...\n"
"        }\n"
"        // 残りのコードはこちら\n"
"    }\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:206
#, fuzzy
msgid ""
"They would get a syntax error. The type `FileDownloadRequest<Bootp>` does "
"not\n"
"implement `mount_point()`, only the type `FileDownloadRequest<Nfs>` does. "
"And\n"
"that is created by the NFS module, not the BOOTP module of course!"
msgstr ""
"構文エラーが発生します。型 `FileDownloadRequest<Bootp>` は `mount_point()` を"
"実装していません。\n"
"は `mount_point()` を実装しておらず、`FileDownloadRequest<Nfs>` 型だけが実装"
"しています。また\n"
"これはもちろんBOOTPモジュールではなく、NFSモジュールによって作成されます！"

#: src/functional/generics-type-classes.md:212
#, fuzzy
msgid ""
"First, it allows fields that are common to multiple states to be de-"
"duplicated.\n"
"By making the non-shared fields generic, they are implemented once."
msgstr ""
"第一に、複数のステートに共通するフィールドの重複をなくすことができます。\n"
"非共有フィールドを汎用的なものにすることで、それらは一度だけ実装されます。"

#: src/functional/generics-type-classes.md:215
#, fuzzy
msgid ""
"Second, it makes the `impl` blocks easier to read, because they are broken "
"down\n"
"by state. Methods common to all states are typed once in one block, and "
"methods\n"
"unique to one state are in a separate block."
msgstr ""
"第二に、`impl`ブロックが状態別に分割されているので読みやすくなります。\n"
"ブロックは状態ごとに分解されます。すべてのステートに共通するメソッドは1つのブ"
"ロックに1回型付けされ、1つのステートに固有のメソッドは別のブロックに型付けさ"
"れます。\n"
"は別のブロックになります。"

#: src/functional/generics-type-classes.md:219
#, fuzzy
msgid ""
"Both of these mean there are fewer lines of code, and they are better "
"organized."
msgstr "どちらもコード行数が少なく、整理されています。"

#: src/functional/generics-type-classes.md:223
#, fuzzy
msgid ""
"This currently increases the size of the binary, due to the way "
"monomorphization\n"
"is implemented in the compiler. Hopefully the implementation will be able "
"to\n"
"improve in the future."
msgstr ""
"これは現在、コンパイラの単型化の実装方法によってバイナリのサイズを大きくして"
"います。\n"
"が実装されているためです。将来的に実装が改善されることを願っています。\n"
"将来的に改善されることを願っています。"

#: src/functional/generics-type-classes.md:229
#, fuzzy
msgid ""
"- If a type seems to need a \"split API\" due to construction or partial\n"
"  initialization, consider the\n"
"  [Builder Pattern](../patterns/creational/builder.md) instead.\n"
"\n"
"- If the API between types does not change -- only the behavior does -- "
"then\n"
"  the [Strategy Pattern](../patterns/behavioural/strategy.md) is better "
"used\n"
"  instead."
msgstr ""
"- ある型が、構築や部分的な初期化によって「分割API」を必要とするようであれば\n"
"  を検討してください。\n"
"  [Builderパターン](../patterns/creational/builder.md)を検討してください。\n"
"\n"
"- 型間のAPIが変化しない場合 -- 振る舞いだけが変化する場合 -- は\n"
"  代わりに[Strategyパターン](../patterns/behavioural/strategy.md)を使うのがよ"
"いでしょう。\n"
"  を使うのがよいでしょう。"

#: src/functional/generics-type-classes.md:239
#, fuzzy
msgid "This pattern is used throughout the standard library:"
msgstr "このパターンは標準ライブラリ全体で使われています："

#: src/functional/generics-type-classes.md:241
#, fuzzy
msgid ""
"- `Vec<u8>` can be cast from a String, unlike every other type of `Vec<T>`."
"[^1]\n"
"- They can also be cast into a binary heap, but only if they contain a type\n"
"  that implements the `Ord` trait.[^2]\n"
"- The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
msgstr ""
"- Vec<u8>` は、他の全ての `Vec<T>` の型とは異なり、文字列からキャストすること"
"ができます[^1]。\n"
"- また、バイナリヒープにキャストすることもできます。\n"
"  を実装している場合に限ります[^2]。\n"
"- to_string` メソッドは `str` 型の `Cow` に対してのみ特化されています[^3]。"

#: src/functional/generics-type-classes.md:246
#, fuzzy
msgid "It is also used by several popular crates to allow API flexibility:"
msgstr ""
"また、APIの柔軟性を可能にするために、いくつかの人気のあるクレートで使用されて"
"います："

#: src/functional/generics-type-classes.md:248
#, fuzzy
msgid ""
"- The `embedded-hal` ecosystem used for embedded devices makes extensive use "
"of\n"
"  this pattern. For example, it allows statically verifying the "
"configuration of\n"
"  device registers used to control embedded pins. When a pin is put into a "
"mode,\n"
"  it returns a `Pin<MODE>` struct, whose generic determines the functions\n"
"  usable in that mode, which are not on the `Pin` itself. [^4]\n"
"\n"
"- The `hyper` HTTP client library uses this to expose rich APIs for "
"different\n"
"  pluggable requests. Clients with different connectors have different "
"methods\n"
"  on them as well as different trait implementations, while a core set of\n"
"  methods apply to any connector. [^5]\n"
"\n"
"- The \"type state\" pattern -- where an object gains and loses API based on "
"an\n"
"  internal state or invariant -- is implemented in Rust using the same "
"basic\n"
"  concept, and a slightly different technique. [^6]"
msgstr ""
"- 組み込み機器に使われる`embedded-hal`エコシステムは、このパターンを多用して"
"います。\n"
"  このパターンを多用しています。例えば、組み込みピンの制御に使われる\n"
"  例えば、組み込みピンの制御に使われるデバイスレジスタの構成を静的に検証する"
"ことができます。ピンがあるモードになると\n"
"  ピンがあるモードになると、`Pin<MODE>` 構造体を返します。\n"
"  そのジェネリックは `Pin` 自体にはない、そのモードで使用可能な関数を決定しま"
"す。[^4]\n"
"\n"
"- HTTPクライアントライブラリ `hyper` は、さまざまなプラグイン可能なリクエスト"
"のためのリッチなAPIを公開するためにこれを使っています。\n"
"  を公開しています。異なるコネクタを持つクライアントは異なるメソッド\n"
"  メソッドのコアセットはどのコネクタにも適用されます。\n"
"  メソッドはどのコネクタにも適用されます。[^5]\n"
"\n"
"- 型状態(type state) \"パターン -- 内部状態や不変量に基づいてオブジェクトが"
"APIを得たり失ったりするパターン -- は、Rustでも同じものを使って実装されていま"
"す。\n"
"  オブジェクトが内部状態や不変量に基づいてAPIを得たり失ったりする「型状態」パ"
"ターンは、Rustでも同じ基本概念と少し異なる手法を使って実装されています。\n"
"  型状態\" パターンが実装されています。[^6]"

#: src/functional/generics-type-classes.md:263
#, fuzzy
msgid ""
"See: [impl From\\<CString\\> for Vec\\<u8\\>](https://doc.rust-lang."
"org/1.59.0/src/std/ffi/c_str.rs.html#803-811)"
msgstr ""
"参照：[impl From<CString> for Vec<u8>](https://doc.rust-lang.org/1.59.0/src/"
"std/ffi/c_str.rs.html#803-811)"

#: src/functional/generics-type-classes.md:265
#, fuzzy
msgid ""
"See: [impl\\<T\\> From\\<Vec\\<T, Global\\>\\> for BinaryHeap\\<T\\>]"
"(https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs."
"html#1345-1354)"
msgstr ""
"参照：[impl <T> From<Vec<T, Global>> for BinaryHeap<T>](https://doc.rust-"
"lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354)"

#: src/functional/generics-type-classes.md:267
#, fuzzy
msgid ""
"See: [impl\\<'\\_\\> ToString for Cow\\<'\\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"
msgstr ""
"参照：[impl <' \\_xxxx ToString for Cow<' \\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"

#: src/functional/generics-type-classes.md:269
#, fuzzy
msgid ""
"Example:\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0."
"html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct."
"PA0.html)"
msgstr ""
"例\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0."
"html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct."
"PA0.html)"

#: src/functional/generics-type-classes.md:272
#, fuzzy
msgid ""
"See:\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs."
"rs/hyper/0.14.5/hyper/client/struct.Client.html)"
msgstr ""
"ご覧ください：\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs."
"rs/hyper/0.14.5/hyper/client/struct.Client.html)"

#: src/functional/generics-type-classes.md:275
#, fuzzy
msgid ""
"See:\n"
"[The Case for the Type State Pattern](https://web.archive.org/"
"web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-"
"typestate-pattern-the-typestate-pattern-itself/)\n"
"and\n"
"[Rusty Typestate Series (an extensive thesis)](https://web.archive.org/"
"web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-"
"series/rust-typestate-index)"
msgstr ""
"ご覧ください：\n"
"[型状態パターンのケース](https://web.archive.org/web/20210325065112/https://"
"www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-"
"pattern-itself/)\n"
"そして\n"
"[ラスティ・タイプステート・シリーズ（広範な論文）](https://web.archive.org/"
"web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-"
"series/rust-typestate-index)"

#: src/functional/lenses.md:1
#, fuzzy
msgid "# Lenses and Prisms"
msgstr "# レンズとプリズム"

#: src/functional/lenses.md:3
#, fuzzy
msgid ""
"This is a pure functional concept that is not frequently used in Rust.\n"
"Nevertheless, exploring the concept may be helpful to understand other\n"
"patterns in Rust APIs, such as [visitors](../patterns/behavioural/visitor."
"md).\n"
"They also have niche use cases."
msgstr ""
"これは純粋な関数型の概念で、Rustではあまり使われません。\n"
"とはいえ、この概念を調べることは、[visitor]（.\n"
"visitors](../patterns/behavioural/visitor.md)のようなRust APIにおける他のパ"
"ターンを理解するのに役立つかもしれません。\n"
"これらのパターンにもニッチな使用例があります。"

#: src/functional/lenses.md:8
#, fuzzy
msgid "## Lenses: Uniform Access Across Types"
msgstr "## レンズ種類を問わない均一なアクセス"

#: src/functional/lenses.md:10
#, fuzzy
msgid ""
"A lens is a concept from functional programming languages that allows\n"
"accessing parts of a data type in an abstract, unified way.[^1]\n"
"In basic concept, it is similar to the way Rust traits work with type "
"erasure,\n"
"but it has a bit more power and flexibility."
msgstr ""
"レンズは関数型プログラミング言語の概念で、データ型の一部に抽象的かつ統一的な"
"方法でアクセスすることができます[^1]。\n"
"抽象的で統一された方法でデータ型の一部にアクセスできるようにする関数型プログ"
"ラミング言語の概念です[^1]。\n"
"基本的な概念としては、Rust の trait が型消去を行うのと似ています、\n"
"しかし、もう少し強力で柔軟性があります。"

#: src/functional/lenses.md:15
#, fuzzy
msgid ""
"For example, suppose a bank contains several JSON formats for customer\n"
"data.\n"
"This is because they come from different databases or legacy systems.\n"
"One database contains the data needed to perform credit checks:"
msgstr ""
"たとえば、ある銀行が顧客データ用に複数のJSON形式を用意しているとします。\n"
"形式があるとします。\n"
"これは、異なるデータベースまたはレガシーシステムから来たものだからです。\n"
"あるデータベースには、信用調査を実行するために必要なデータが含まれています："

#: src/functional/lenses.md:20
#, fuzzy
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"dob\": \"2002-02-24\",\n"
"  [...]\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"name\"：\"Jane Doe\"、\n"
"  \"dob\"：\"2002-02-24\",\n"
"  [...]\n"
"  \"customer_id\"：1048576332,\n"
"}\n"
"```"

#: src/functional/lenses.md:28
#, fuzzy
msgid "Another one contains the account information:"
msgstr "もうひとつは口座情報："

#: src/functional/lenses.md:30
#, fuzzy
msgid ""
"```json\n"
"{ \"customer_id\": 1048576332,\n"
"  \"accounts\": [\n"
"      { \"account_id\": 2121,\n"
"        \"account_type: \"savings\",\n"
"        \"joint_customer_ids\": [],\n"
"        [...]\n"
"      },\n"
"      { \"account_id\": 2122,\n"
"        \"account_type: \"checking\",\n"
"        \"joint_customer_ids\": [1048576333],\n"
"        [...]\n"
"      },\n"
"  ]\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"customer_id\"：1048576332,\n"
"  \"accounts\"：[\n"
"      { \"account_id\"：2121,\n"
"        \"account_type：\"貯蓄\"、\n"
"        \"joint_customer_ids\"：[],\n"
"        [...]\n"
"      },\n"
"      { \"account_id\"：2122,\n"
"        \"account_type：「当座預金\n"
"        \"joint_customer_ids\"：[1048576333],\n"
"        [...]\n"
"      },\n"
"  ]\n"
"}\n"
"```"

#: src/functional/lenses.md:47
#, fuzzy
msgid ""
"Notice that both types have a customer ID number which corresponds to a "
"person.\n"
"How would a single function handle both records of different types?"
msgstr ""
"どちらのタイプも個人に対応する顧客ID番号を持っていることに注目してくださ"
"い。\n"
"異なるタイプのレコードを1つの関数で処理するにはどうすればよいでしょうか。"

#: src/functional/lenses.md:50
#, fuzzy
msgid ""
"In Rust, a `struct` could represent each of these types, and a trait would "
"have\n"
"a `get_customer_id` function they would implement:"
msgstr ""
"Rust では、 `struct` はこれらの型を表すことができます。\n"
"は `get_customer_id` 関数を実装します："

#: src/functional/lenses.md:53
#, fuzzy
msgid ""
"```rust\n"
"use std::collections::HashSet;\n"
"\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"pub trait CustomerId {\n"
"    fn get_customer_id(&self) -> u64;\n"
"}\n"
"\n"
"pub struct CreditRecord {\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"impl CustomerId for CreditRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"pub struct AccountRecord {\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"impl CustomerId for AccountRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"// static polymorphism: only one type, but each function call can choose it\n"
"fn unique_ids_set<R: CustomerId>(records: &[R]) -> HashSet<u64> {\n"
"    records.iter().map(|r| r.get_customer_id()).collect()\n"
"}\n"
"\n"
"// dynamic dispatch: iterates over any type with a customer ID, collecting "
"all\n"
"// values together\n"
"fn unique_ids_iter<I>(iterator: I) -> HashSet<u64>\n"
"    where I: Iterator<Item=Box<dyn CustomerId>>\n"
"{\n"
"    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"std::collections::HashSetを使用します；\n"
"\n"
"pub struct Account {\n"
"    account_id: u32、\n"
"    account_type：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"pub trait CustomerId { 顧客ID\n"
"    fn get_customer_id(&amp;self) -&gt; u64；\n"
"}\n"
"\n"
"pub struct CreditRecord { { 顧客ID: u64\n"
"    customer_id: u64、\n"
"    name: String、\n"
"    dob：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"impl CustomerId for CreditRecord { クレジットレコードのための顧客ID\n"
"    fn get_customer_id(&amp;self) -&gt; u64 {.\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"pub struct AccountRecord {\n"
"    customer_id: u64、\n"
"    accounts：Vec<Account> 、\n"
"}\n"
"\n"
"impl CustomerId for AccountRecord { 以下のようになります。\n"
"    fn get_customer_id(&amp;self) -&gt; u64 {.\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"// 静的多相性: 型は1つだけですが、各関数呼び出しで選択できます。\n"
"fn unique_ids_set<R: CustomerId>(records: &amp;[R]) -&gt; HashSet<u64> {.\n"
"    records.iter().map(|r| r.get_customer_id()).collect()\n"
"}\n"
"\n"
"// 動的なディスパッチ: 顧客 ID を持つ任意の型を繰り返し処理し、 // すべての値"
"を収集します。\n"
"// すべての値を収集します。\n"
"fn unique_ids_iter<I>(iterator: I) -&gt; HashSet<u64>\n"
"    ここで I: Iterator&lt;Item=Box<dyn CustomerId>&gt; です。\n"
"{\n"
"    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
"}\n"
"```"

#: src/functional/lenses.md:104
#, fuzzy
msgid ""
"Lenses, however, allow the code supporting customer ID to be moved from the\n"
"_type_ to the _accessor function_.\n"
"Rather than implementing a trait on each type, all matching structures can\n"
"simply be accessed the same way."
msgstr ""
"しかし、レンズは、顧客IDをサポートするコードを、_type_から_accessor function_"
"に移すことを可能にします。\n"
"型_から_アクセサ関数_に移すことができます。\n"
"それぞれの型に trait を実装するのではなく、すべてのマッチする構造体に同じ方法"
"でアクセスすることができます。\n"
"にアクセスできるようになります。"

#: src/functional/lenses.md:109
#, fuzzy
msgid ""
"While the Rust language itself does not support this (type erasure is the\n"
"preferred solution to this problem), the [lens-rs crate](https://github.com/"
"TOETOE55/lens-rs/blob/master/guide.md) allows code\n"
"that feels like this to be written with macros:"
msgstr ""
"Rust言語自体はこれをサポートしていませんが（型消去がこの問題の望ましい解決策"
"です。\n"
"型消去がこの問題に対する望ましい解決策です）、[lens-rs crate](https://github."
"com/TOETOE55/lens-rs/blob/master/guide.md)では、マクロを使ってこのようなコー"
"ドを書くことができます。\n"
"をマクロで書くことができます："

#: src/functional/lenses.md:113
#, fuzzy
msgid ""
"```rust,ignore\n"
"use std::collections::HashSet;\n"
"\n"
"use lens_rs::{optics, Lens, LensRef, Optics};\n"
"\n"
"#[derive(Clone, Debug, Lens /* derive to allow lenses to work */)]\n"
"pub struct CreditRecord {\n"
"    #[optic(ref)] // macro attribute to allow viewing this field\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug)]\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug, Lens)]\n"
"pub struct AccountRecord {\n"
"    #[optic(ref)]\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -> HashSet<u64>\n"
"where\n"
"    T: LensRef<Optics![customer_id], u64>, // any type with this field\n"
"{\n"
"    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
"}\n"
"```"
msgstr ""
"``rust,ignore\n"
"std::collections::HashSetを使用します；\n"
"\n"
"use lens_rs::{optics, Lens, LensRef, Optics}；\n"
"\n"
"#[derive(Clone, Debug, Lens /* レンズを動作させるための派生 */)].\n"
"pub struct CreditRecord {\n"
"    #[optic(ref)] // このフィールドを表示するためのマクロ属性\n"
"    customer_id: u64、\n"
"    name: 文字列、\n"
"    dob：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"#[derive(Clone, Debug)] (派生(クローン), デバッグ)\n"
"pub struct Account {\n"
"    account_id: u32、\n"
"    account_type：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"#[derive(Clone, Debug, Lens)] を参照してください。\n"
"pub struct AccountRecord {\n"
"    #[optic(ref)]\n"
"    customer_id: u64、\n"
"    accounts：Vec<Account> 、\n"
"}\n"
"\n"
"fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -&gt; HashSet<u64>\n"
"ここで\n"
"    T: LensRef<Optics![customer_id], u64>, // このフィールドを持つ任意の型\n"
"{\n"
"    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
"}\n"
"```"

#: src/functional/lenses.md:149
#, fuzzy
msgid ""
"The version of `unique_ids_lens` shown here allows any type to be in the "
"iterator,\n"
"so long as it has an attribute called `customer_id` which can be accessed "
"by\n"
"the function.\n"
"This is how most functional programming languages operate on lenses."
msgstr ""
"ここで紹介する `unique_ids_lens` のバージョンでは、どのような型でもイテレータ"
"に含めることができます、\n"
"関数がアクセスできる `customer_id` という属性を持っている限り、どんな型でもイ"
"テレータに入れることができます。\n"
"という属性を持つ限り、どんな型でもイテレータに入れることができます。\n"
"これは、ほとんどの関数型プログラミング言語がレンズを操作する方法です。"

#: src/functional/lenses.md:154
#, fuzzy
msgid ""
"Rather than macros, they achieve this with a technique known as "
"\"currying\".\n"
"That is, they \"partially construct\" the function, leaving the type of the\n"
"final parameter (the value being operated on) unfilled until the function "
"is\n"
"called.\n"
"Thus it can be called with different types dynamically even from one place "
"in\n"
"the code.\n"
"That is what the `optics!` and `view_ref` in the example above simulates."
msgstr ""
"マクロではなく、\"currying \"と呼ばれるテクニックでこれを実現します。\n"
"つまり、関数を \"部分的に構築 \"し、最終パラメータ（操作される値）の型は関数"
"が実行されるまで未記入のままにしておくのです。\n"
"つまり、関数を \"部分的に構築 \"し、関数が呼び出されるまで、最終パラメータ"
"（操作される値）の型は未記入のままにしておくのです。\n"
"関数が呼び出されるまで、最終パラメータ（操作される値）の型は未記入のままにし"
"ておきます。\n"
"そのため、関数が呼び出されるまで、最終パラメータ（演算される値）の型は未記入"
"のままです。\n"
"を動的に呼び出すことができます。\n"
"上の例の `optics!` と `view_ref` はそれをシミュレートしています。"

#: src/functional/lenses.md:162
#, fuzzy
msgid ""
"The functional approach need not be restricted to accessing members.\n"
"More powerful lenses can be created which both _set_ and _get_ data in a\n"
"structure.\n"
"But the concept really becomes interesting when used as a building block "
"for\n"
"composition.\n"
"That is where the concept appears more clearly in Rust."
msgstr ""
"関数的アプローチは、メンバーへのアクセスに限定される必要はありません。\n"
"より強力なレンズを作成することができます。\n"
"構造体の\n"
"しかし、このコンセプトが本当に面白くなるのは\n"
"コンポジションです。\n"
"Rustでは、この概念がより明確に現れます。"

#: src/functional/lenses.md:169
#, fuzzy
msgid "## Prisms: A Higher-Order form of \"Optics\""
msgstr "#プリズム高次の \"光学\""

#: src/functional/lenses.md:171
#, fuzzy
msgid ""
"A simple function such as `unique_ids_lens` above operates on a single "
"lens.\n"
"A _prism_ is a function that operates on a _family_ of lenses.\n"
"It is one conceptual level higher, using lenses as a building block, and\n"
"continuing the metaphor, is part of a family of \"optics\".\n"
"It is the main one that is useful in understanding Rust APIs, so will be "
"the\n"
"focus here."
msgstr ""
"上記の`unique_ids_lens`のような単純な関数は1つのレンズを操作します。\n"
"prism_はレンズの_ファミリーを操作する関数です。\n"
"これは、レンズを構成要素として使用する、1つ上の概念的なレベルです。\n"
"この比喩を続けると、「光学」のファミリーの一部です。\n"
"RustのAPIを理解する上で有用な主要なものなので、ここで取り上げます。\n"
"に焦点を当てます。"

#: src/functional/lenses.md:178
#, fuzzy
msgid ""
"The same way that traits allow \"lens-like\" design with static polymorphism "
"and\n"
"dynamic dispatch, prism-like designs appear in Rust APIs which split "
"problems\n"
"into multiple associated types to be composed.\n"
"A good example of this is the traits in the parsing crate _Serde_."
msgstr ""
"静的なポリモーフィズムと動的なディスパッチで「レンズのような」設計ができるの"
"と同じように、Rust APIではプリズムのような設計が可能です。\n"
"プリズムのような設計がRust APIに登場します。\n"
"を複数の関連型に分割して構成します。\n"
"この良い例が、構文解析クレート _Serde_ の traits です。"

#: src/functional/lenses.md:183
#, fuzzy
msgid ""
"Trying to understand the way _Serde_ works by only reading the API is a\n"
"challenge, especially the first time.\n"
"Consider the `Deserializer` trait, implemented by some type in any library\n"
"which parses a new format:"
msgstr ""
"APIを読むだけで、_Serde_の仕組みを理解しようとするのは難しいことです。\n"
"特に最初のうちは大変です。\n"
"デシリアライザ`の特徴を考えてみましょう。\n"
"を考えてみましょう："

#: src/functional/lenses.md:188
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Deserializer<'de>: Sized {\n"
"    type Error: Error;\n"
"\n"
"    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    // remainder ommitted\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait デシリアライザ<'de>: Sized {\n"
"    type Error: Error;\n"
"\n"
"    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de> ；\n"
"\n"
"    fn deserialize_bool<V>(self, visitor: V) -&gt; 結果<V::Value, Self::"
"Error>\n"
"    ここで\n"
"        V: Visitor&lt;'de&gt;；\n"
"\n"
"    // 余りは省略\n"
"}\n"
"```"

#: src/functional/lenses.md:204
#, fuzzy
msgid ""
"For a trait that is just supposed to parse data from a format and return a\n"
"value, this looks odd."
msgstr ""
"フォーマットからデータをパースして\n"
"これは奇妙に見えます。"

#: src/functional/lenses.md:207
#, fuzzy
msgid "Why are all the return types type erased?"
msgstr "なぜリターンタイプはすべて消去されるのですか？"

#: src/functional/lenses.md:209
#, fuzzy
msgid ""
"To understand that, we need to keep the lens concept in mind and look at\n"
"the definition of the `Visitor` type that is passed in generically:"
msgstr ""
"これを理解するためには、レンズの概念を念頭に置き、一般的に渡される `Visitor` "
"型の定義を見てみる必要があります。\n"
"を見る必要があります："

#: src/functional/lenses.md:212
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Visitor<'de>: Sized {\n"
"    type Value;\n"
"\n"
"    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    // remainder omitted\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait Visitor&lt;'de&gt;: サイズ {.\n"
"    型の値；\n"
"\n"
"    fn visit_bool&lt;E&gt;(self, v: bool) -&gt; 結果&lt;Self::Value, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    fn visit_u64&lt;E&gt;(self, v: u64) -&gt; 結果&lt;Self::値, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    fn visit_str&lt;E&gt;(self, v: &amp;str) -&gt; 結果&lt;Self::値, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    // 余りは省略\n"
"}\n"
"```"

#: src/functional/lenses.md:232
#, fuzzy
msgid ""
"The job of the `Visitor` type is to construct values in the _Serde_ data "
"model,\n"
"which are represented by its associated `Value` type."
msgstr ""
"Visitor`型の仕事は_Serde_データモデルで値を構築することです、\n"
"その値は `Value` 型によって表現されます。"

#: src/functional/lenses.md:235
#, fuzzy
msgid ""
"These values represent parts of the Rust value being deserialized.\n"
"If this fails, it returns an `Error` type - an error type determined by the\n"
"`Deserializer` when its methods were called."
msgstr ""
"これらの値は、デシリアライズされる Rust 値の一部を表します。\n"
"失敗した場合は `Error` 型を返します。\n"
"メソッドが呼び出されたときに `Deserializer` によって決定されたエラータイプで"
"す。"

#: src/functional/lenses.md:239
#, fuzzy
msgid ""
"This highlights that `Deserializer` is similar to `CustomerId` from "
"earlier,\n"
"allowing any format parser which implements it to create `Value`s based on "
"what\n"
"it parsed.\n"
"The `Value` trait is acting like a lens in functional programming languages."
msgstr ""
"これは `Deserializer` が先ほどの `CustomerId` と似ていることを強調していま"
"す、\n"
"を実装したフォーマットパーサであれば、そのパーサがパースした内容に基づいて "
"`Value` を作成することができます。\n"
"を生成することができます。\n"
"Value` 特性は関数型プログラミング言語におけるレンズのようなものです。"

#: src/functional/lenses.md:244
#, fuzzy
msgid ""
"But unlike the `CustomerId` trait, the return types of `Visitor` methods "
"are\n"
"_generic_, and the concrete `Value` type is _determined by the Visitor "
"itself_."
msgstr ""
"しかし、 `CustomerId` 特性と異なり、 `Visitor` メソッドの戻り値の型は "
"_generic_ です。\n"
"一般的なもので、具体的な `Value` の型は Visitor 自身によって決まります。"

#: src/functional/lenses.md:247
#, fuzzy
msgid ""
"Instead of acting as one lens, it effectively acts as a family of\n"
"lenses, one for each concrete type of `Visitor`."
msgstr ""
"つのレンズとして機能するのではなく、事実上、レンズのファミリーとして機能しま"
"す。\n"
"レンズのファミリーとして機能します。"

#: src/functional/lenses.md:250
#, fuzzy
msgid ""
"The `Deserializer` API is based on having a generic set of \"lenses\" work "
"across\n"
"a set of other generic types for \"observation\".\n"
"It is a _prism_."
msgstr ""
"デシリアライザーのAPIは、\"レンズ \"の一般的なセットが、\"観察 \"のために他の"
"一般的なタイプ\n"
"観察 \"のために他の一般的な型のセットをまたいで動作させることに基づいていま"
"す。\n"
"これは_prism_です。"

#: src/functional/lenses.md:254
#, fuzzy
msgid "For example, consider the identity record from earlier but simplified:"
msgstr "例えば、先ほどのID記録を単純化して考えてみましょう："

#: src/functional/lenses.md:256
#, fuzzy
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"name\"：\"Jane Doe\"、\n"
"  \"customer_id\"：1048576332,\n"
"}\n"
"```"

#: src/functional/lenses.md:262
#, fuzzy
msgid ""
"How would the _Serde_ library deserialize this JSON into `struct "
"CreditRecord`?"
msgstr ""
"Serde_ライブラリはこのJSONをどのように`struct CreditRecord`にデシリアライズし"
"ますか？"

#: src/functional/lenses.md:264
#, fuzzy
msgid ""
"1. The user would call a library function to deserialize the data. This "
"would\n"
"   create a `Deserializer` based on the JSON format.\n"
"1. Based on the fields in the struct, a `Visitor` would be created (more on\n"
"   that in a moment) which knows how to create each type in a generic data\n"
"   model that was needed to represent it: `u64` and `String`.\n"
"1. The deserializer would make calls to the `Visitor` as it parsed items.\n"
"1. The `Visitor` would indicate if the items found were expected, and if "
"not,\n"
"   raise an error to indicate deserialization has failed."
msgstr ""
"1.ユーザーはライブラリ関数を呼び出してデータをデシリアライズします。これは\n"
"   JSON フォーマットに基づいた `Deserializer` を作成します。\n"
"1.構造体のフィールドに基づいて、一般的なデータ型の各データ型を作成する方法を"
"知っている `Visitor` が作成されます。\n"
"   を作成することになります。\n"
"   型（`u64` と `String`）を作成する方法を知っています。\n"
"1.デシリアライザはアイテムをパースするときに `Visitor` を呼び出します。\n"
"1.Visitor` は見つかったアイテムが期待されたものであるかどうかを示し、期待され"
"たものでない場合はエラーを発生させます、\n"
"   デシリアライズに失敗したことを示すエラーを発生させます。"

#: src/functional/lenses.md:273
#, fuzzy
msgid "For our very simple structure above, the expected pattern would be:"
msgstr "上記の非常に単純な構造の場合、予想されるパターンは次のようになります："

#: src/functional/lenses.md:275
#, fuzzy
msgid ""
"1. Visit a map (_Serde_'s equvialent to `HashMap` or JSON's dictionary).\n"
"1. Visit a string key called \"name\".\n"
"1. Visit a string value, which will go into the `name` field.\n"
"1. Visit a string key called \"customer_id\".\n"
"1. Visit a string value, which will go into the `customer_id` field.\n"
"1. Visit the end of the map."
msgstr ""
"1.マップ（_Serde_ の `HashMap` や JSON の辞書に相当するもの）にアクセスしま"
"す。\n"
"1.name \"という文字列キーにアクセスします。\n"
"1.name`フィールドに入る文字列の値にアクセスします。\n"
"1.customer_id \"という文字列キーにアクセスします。\n"
"1.customer_id`フィールドに入る文字列の値にアクセスします。\n"
"1.マップの最後にアクセスします。"

#: src/functional/lenses.md:282
#, fuzzy
msgid "But what determines which \"observation\" pattern is expected?"
msgstr ""
"しかし、どの \"観測 \"パターンが期待されるかは、何によって決まるのでしょう"
"か？"

#: src/functional/lenses.md:284
#, fuzzy
msgid ""
"A functional programming language would be able to use currying to create\n"
"reflection of each type based on the type itself.\n"
"Rust does not support that, so every single type would need to have its own\n"
"code written based on its fields and their properties."
msgstr ""
"関数型プログラミング言語であれば、カリー（currying）を使って、型自体に基づい"
"た各型の\n"
"を作成することができます。\n"
"Rustはそれをサポートしていないため、すべての型が、そのフィールドとプロパティ"
"に基づいて独自の\n"
"コードを書く必要があります。"

#: src/functional/lenses.md:289
#, fuzzy
msgid "_Serde_ solves this usability challenge with a derive macro:"
msgstr "Serde_はderiveマクロでこの使い勝手の問題を解決します："

#: src/functional/lenses.md:291
#, fuzzy
msgid ""
"```rust,ignore\n"
"use serde::Deserialize;\n"
"\n"
"#[derive(Deserialize)]\n"
"struct IdRecord {\n"
"    name: String,\n"
"    customer_id: String,\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"serde::Deserialize を使用します；\n"
"\n"
"#[derive(Deserialize)] を参照してください。\n"
"struct IdRecord {\n"
"    name: 文字列、\n"
"    customer_id：文字列、\n"
"}\n"
"```"

#: src/functional/lenses.md:301
#, fuzzy
msgid ""
"That macro simply generates an impl block causing the struct to implement a\n"
"trait called `Deserialize`."
msgstr ""
"このマクロは、単に struct に `Deserialize` という trait を実装させる impl ブ"
"ロックを生成します。\n"
"という trait を実装させます。"

#: src/functional/lenses.md:304
#, fuzzy
msgid "It is defined this way:"
msgstr "このように定義されています："

#: src/functional/lenses.md:306
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Deserialize<'de>: Sized {\n"
"    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
"    where\n"
"        D: Deserializer<'de>;\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait Deserialize<'de>: Sized {\n"
"    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
"    where\n"
"        D: Deserializer<'de> ；\n"
"}\n"
"```"

#: src/functional/lenses.md:314
#, fuzzy
msgid ""
"This is the function that determines how to create the struct itself.\n"
"Code is generated based on the struct's fields.\n"
"When the parsing library is called - in our example, a JSON parsing library "
"-\n"
"it creates a `Deserializer` and calls `Type::deserialize` with it as a\n"
"parameter."
msgstr ""
"これは、構造体自体の作成方法を決定する関数です。\n"
"コードは構造体のフィールドに基づいて生成されます。\n"
"構文解析ライブラリが呼び出されると（この例では JSON 構文解析ライブラリ）、"
"`Deserializer` が作成され、それを使用して `Type::deserialize` が呼び出されま"
"す。\n"
"が呼び出されると、`Deserializer` が作成され、それをパラメータとして `Type::"
"deserialize` が呼び出されます。\n"
"を呼び出します。"

#: src/functional/lenses.md:320
#, fuzzy
msgid ""
"The `deserialize` code will then create a `Visitor` which will have its "
"calls\n"
"\"refracted\" by the `Deserializer`.\n"
"If everything goes well, eventually that `Visitor` will construct a value\n"
"corresponding to the type being parsed and return it."
msgstr ""
"そして `deserialize` コードは `Visitor` を作成し、その呼び出しは "
"`Deserializer` によって \"refract\" されます。\n"
"その呼び出しは `Deserializer` によって \"refracted\" されます。\n"
"すべてがうまくいけば、最終的に `Visitor` はパースされた型に対応する値を構築"
"し、それを返します。\n"
"を作成し、それを返します。"

#: src/functional/lenses.md:325
#, fuzzy
msgid ""
"For a complete example, see the [_Serde_ documentation](https://serde.rs/"
"deserialize-struct.html)."
msgstr ""
"完全な例については、[_Serde_ documentation](https://serde.rs/deserialize-"
"struct.html) を参照してください。"

#: src/functional/lenses.md:327
#, fuzzy
msgid "To wrap up, this is the power of _Serde_:"
msgstr "最後に、これがセルデの力です："

#: src/functional/lenses.md:329
#, fuzzy
msgid ""
"1. The structure being parsed is represented by an `impl` block for "
"`Deserialize`\n"
"1. The input data format (e.g. JSON) is represented by a `Deserializer` "
"called\n"
"   by `Deserialize`\n"
"1. The `Deserializer` acts like a prism which \"refracts\" lens-like "
"`Visitor`\n"
"   calls which actually build the data value"
msgstr ""
"1.パースされる構造は `Deserialize` 用の `impl` ブロックで表現されます。\n"
"1.入力データフォーマット（例えば JSON）は `Deserializer` の\n"
"   によって呼び出されます。\n"
"1.この `Deserializer` はプリズムのように動作し、レンズのような `Visitor` 呼び"
"出しを \"屈折\" させます。\n"
"   を呼び出します。"

#: src/functional/lenses.md:335
#, fuzzy
msgid ""
"The result is that types to be deserialized only implement the \"top layer\" "
"of\n"
"the API, and file formats only need to implement the \"bottom layer\".\n"
"Each piece can then \"just work\" with the rest of the ecosystem, since "
"generic\n"
"types will bridge them."
msgstr ""
"その結果、デシリアライズされる型はAPIの \"トップ・レイヤー \"のみを実装し、"
"ファイル・フォーマットは \"ボトム・レイヤー \"のみを実装すればよいことになり"
"ます。\n"
"デシリアライズされる型はAPIの \"トップレイヤー \"のみを実装し、ファイルフォー"
"マットは \"ボトムレイヤー \"のみを実装すればよいということです。\n"
"その結果、デシリアライズされる型はAPIの \"最上層 \"のみを実装し、ファイル"
"フォーマットは \"最下層 \"のみを実装すればよくなります。\n"
"型がそれらの橋渡しをしてくれるからです。"

#: src/functional/lenses.md:340
#, fuzzy
msgid ""
"To emphasize, the only reason this model works on any format and any type "
"is\n"
"because the `Deserializer` trait's output type **is specified by the\n"
"implementor of `Visitor` it is passed**, rather than being tied to one "
"specific\n"
"type.\n"
"This was not true in the account example earlier."
msgstr ""
"強調しておきますが、このモデルがどのようなフォーマットでもどのような型でも動"
"作する唯一の理由は\n"
"なぜなら `Deserializer` 特性の出力型は **渡される `Visitor` の実装者によって"
"指定されるからです。\n"
"の実装者によって指定されるからです。\n"
"の実装者によって指定されるからです。\n"
"これは先ほどの口座の例では当てはまりませんでした。"

#: src/functional/lenses.md:346
#, fuzzy
msgid ""
"Rust's generic-inspired type system can bring it close to these concepts "
"and\n"
"use their power, as shown in this API design.\n"
"But it may also need procedural macros to create bridges for its generics."
msgstr ""
"Rustのジェネリックにインスパイアされた型システムは、このAPI設計に示されている"
"ように、これらの概念に近づけ、その力を利用することができます。\n"
"このAPI設計で示されているように、その力を利用することができます。\n"
"しかし、ジェネリックのためのブリッジを作成するための手続き型マクロも必要かも"
"しれません。"

#: src/functional/lenses.md:350
#, fuzzy
msgid "## See Also"
msgstr "## See Also"

#: src/functional/lenses.md:352
#, fuzzy
msgid ""
"- [lens-rs crate](https://crates.io/crates/lens-rs) for a pre-built lenses\n"
"  implementation, with a cleaner interface than these examples\n"
"- [serde](https://serde.rs) itself, which makes these concepts intuitive "
"for\n"
"  end users (i.e. defining the structs) without needing to undestand the\n"
"  details\n"
"- [luminance](https://github.com/phaazon/luminance-rs) is a crate for "
"drawing\n"
"  computer graphics that uses lens API design, including proceducal macros "
"to\n"
"  create full prisms for buffers of different pixel types that remain "
"generic\n"
"- [An Article about Lenses in Scala](https://web.archive.org/"
"web/20221128185849/https://medium.com/zyseme-technology/functional-"
"references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
"  that is very readable even without Scala expertise.\n"
"- [Paper: Profunctor Optics: Modular Data\n"
"  Accessors](https://web.archive.org/web/20220701102832/https://arxiv.org/"
"ftp/arxiv/papers/1703/1703.10857.pdf)"
msgstr ""
"- [lens-rs crate](https://crates.io/crates/lens-rs)は、これらの例よりもすっき"
"りとしたインターフェイスを持つ、あらかじめ組み込まれたレンズの実装です。\n"
"  を実装しています。\n"
"- [serde](https://serde.rs)そのものです。\n"
"  を理解することなく、エンドユーザー (構造体の定義など) がこれらの概念を直感"
"的に理解できるようにします。\n"
"  詳細\n"
"- [luminance](https://github.com/phaazon/luminance-rs)は、レンズAPIの設計を使"
"用した、コンピュータグラフィックスを描画するためのクレートです。\n"
"  レンズ API デザインを使用するコンピュータグラフィックス用のクレートです。\n"
"  汎用のまま、異なるピクセルタイプのバッファのための完全なプリズムを作成しま"
"す。\n"
"- [Scala におけるレンズについての記事](https://web.archive.org/"
"web/20221128185849/https://medium.com/zyseme-technology/functional-"
"references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
"  Scalaの専門知識がなくても非常に読みやすいものです。\n"
"- 論文プロファンクタ光学系．モジュラーデータ\n"
"  アクセサ](https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/"
"arxiv/papers/1703/1703.10857.pdf)"

#: src/functional/lenses.md:365
#, fuzzy
msgid ""
"[School of Haskell: A Little Lens Starter Tutorial](https://web.archive.org/"
"web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-"
"beyond/pick-of-the-week/a-little-lens-starter-tutorial)"
msgstr ""
"[Haskellの学校：小さなレンズ・スターター・チュートリアル](https://web."
"archive.org/web/20221128190041/https://www.schoolofhaskell.com/school/to-"
"infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial)"

#: src/additional_resources/index.md:1
#, fuzzy
msgid "# Additional resources"
msgstr "# その他のリソース"

#: src/additional_resources/index.md:3
#, fuzzy
msgid "A collection of complementary helpful content"
msgstr "補完的なお役立ちコンテンツ集"

#: src/additional_resources/index.md:5
#, fuzzy
msgid "## Talks"
msgstr "## Talks"

#: src/additional_resources/index.md:7
#, fuzzy
msgid ""
"- [Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by\n"
"  Nicholas Cameron at the PDRust (2016)\n"
"- [Writing Idiomatic Libraries in Rust](https://www.youtube.com/watch?"
"v=0zOg8_B71gE)\n"
"  by Pascal Hertleif at RustFest (2017)\n"
"- [Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4) "
"by\n"
"  Nicholas Cameron at LinuxConfAu (2018)"
msgstr ""
"- [Rustのデザインパターン](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by\n"
"  ニコラス・キャメロン＠PDRust (2016)\n"
"- [Rustでイディオマティックなライブラリを書く](https://www.youtube.com/watch?"
"v=0zOg8_B71gE)\n"
"  by Pascal Hertleif at RustFest (2017)\n"
"- [Rustプログラミングテクニック](https://www.youtube.com/watch?"
"v=vqavdUGKeb4)\n"
"  ニコラス・キャメロン at LinuxConfAu (2018)"

#: src/additional_resources/index.md:14
#, fuzzy
msgid "## Books (Online)"
msgstr "## 書籍（オンライン）"

#: src/additional_resources/index.md:16
#, fuzzy
msgid "- [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines)"
msgstr "- [Rust APIガイドライン](https://rust-lang.github.io/api-guidelines)"

#: src/additional_resources/design-principles.md:1
#, fuzzy
msgid "# Design principles"
msgstr "# デザインの原則"

#: src/additional_resources/design-principles.md:3
#, fuzzy
msgid "## A brief overview over common design principles"
msgstr "## 一般的な設計原則の概要"

#: src/additional_resources/design-principles.md:7
#, fuzzy
msgid "## [SOLID](https://en.wikipedia.org/wiki/SOLID)"
msgstr "## ♪ [SOLID](https://en.wikipedia.org/wiki/SOLID)"

#: src/additional_resources/design-principles.md:9
#, fuzzy
msgid ""
"- [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/"
"Single-responsibility_principle):\n"
"  A class should only have a single responsibility, that is, only changes "
"to\n"
"  one part of the software's specification should be able to affect the\n"
"  specification of the class.\n"
"- [Open/Closed Principle (OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle):\n"
"  \"Software entities ... should be open for extension, but closed for\n"
"  modification.\"\n"
"- [Liskov Substitution Principle (LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle):\n"
"  \"Objects in a program should be replaceable with instances of their "
"subtypes\n"
"  without altering the correctness of that program.\"\n"
"- [Interface Segregation Principle (ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle):\n"
"  \"Many client-specific interfaces are better than one general-purpose\n"
"  interface.\"\n"
"- [Dependency Inversion Principle (DIP)](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle):\n"
"  One should \"depend upon abstractions, [not] concretions.\""
msgstr ""
"- [単一責任原則(SRP)](https://en.wikipedia.org/wiki/Single-"
"responsibility_principle)：\n"
"  クラスは単一の責任だけを持つべきです。\n"
"  ソフトウェアの仕様の一部分の変更だけが、クラスの仕様に影響を与えることがで"
"きます。\n"
"  クラスの仕様に影響を与えることができるべきです。\n"
"- [オープン/クローズド原則(OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle)：\n"
"  「ソフトウェア・エンティティは......拡張に対してはオープンであるべきです"
"が、変更に対してはクローズドであるべきです。\n"
"  \"。\n"
"- [リスコフ置換原則(LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle)：\n"
"  「プログラム中のオブジェクトは、そのサブタイプのインスタンスと置き換え可能"
"であるべきです。\n"
"  そのプログラムの正しさを変えることなく。\"\n"
"- [インタフェース分離の原則(ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle)：\n"
"  \"多くのクライアント固有のインターフェースは、1つの汎用インターフェースよ"
"り\n"
"  インターフェースよりも優れている\" [Dependency Inversion Principle (ISP)]"
"()\n"
"- [依存関係逆転の原則(DIP)](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)：\n"
"  人は \"抽象的なものに依存すべきであり、具体的なものに依存すべきではない\"。"

#: src/additional_resources/design-principles.md:25
#, fuzzy
msgid ""
"## [DRY (Don’t Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"
msgstr ""
"## [DRY (Don't Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"

#: src/additional_resources/design-principles.md:27
#, fuzzy
msgid ""
"\"Every piece of knowledge must have a single, unambiguous, authoritative\n"
"representation within a system\""
msgstr ""
"「すべての知識は、システム内で単一の、曖昧さのない、権威ある表現を持たなけれ"
"ばなりません。\n"
"システム内で表現されなければならない\""

#: src/additional_resources/design-principles.md:30
#, fuzzy
msgid "## [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)"
msgstr "## [KISSの原則](https://en.wikipedia.org/wiki/KISS_principle)"

#: src/additional_resources/design-principles.md:32
#, fuzzy
msgid ""
"most systems work best if they are kept simple rather than made "
"complicated;\n"
"therefore, simplicity should be a key goal in design, and unnecessary\n"
"complexity should be avoided"
msgstr ""
"ほとんどのシステムは、複雑にするよりもシンプルにした方がうまく機能します；\n"
"したがって、シンプルであることが設計の重要な目標であり、不必要な複雑さは避け"
"るべきです。\n"
"を避けるべきです。"

#: src/additional_resources/design-principles.md:36
#, fuzzy
msgid "## [Law of Demeter (LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"
msgstr "## [デメテルの法則(LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"

#: src/additional_resources/design-principles.md:38
#, fuzzy
msgid ""
"a given object should assume as little as possible about the structure or\n"
"properties of anything else (including its subcomponents), in accordance "
"with\n"
"the principle of \"information hiding\""
msgstr ""
"あるオブジェクトは、他のもの（そのサブコンポーネントを含む）の構造や特性につ"
"いて、できる限り推測しないようにすべきです。\n"
"情報隠蔽」の原則に従い\n"
"\"情報隠蔽 \"の原則に従って"

#: src/additional_resources/design-principles.md:42
#, fuzzy
msgid ""
"## [Design by contract (DbC)](https://en.wikipedia.org/wiki/"
"Design_by_contract)"
msgstr ""
"## [契約による設計（DbC）](https://en.wikipedia.org/wiki/Design_by_contract)"

#: src/additional_resources/design-principles.md:44
#, fuzzy
msgid ""
"software designers should define formal, precise and verifiable interface\n"
"specifications for software components, which extend the ordinary definition "
"of\n"
"abstract data types with preconditions, postconditions and invariants"
msgstr ""
"ソフトウエア設計者は、ソフトウエア・コンポーネントのインターフェイス仕様につ"
"いて、通常の定義を拡張した、形式的で正確かつ検証可能なものを定義する必要があ"
"ります。\n"
"ソフトウェア・コンポーネントのインターフェイス仕様を定義すべきです。\n"
"抽象データ型の定義を拡張し、前提条件、後件条件、不変条件"

#: src/additional_resources/design-principles.md:48
#, fuzzy
msgid ""
"## [Encapsulation](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"
msgstr ""
"## [Encapsulation](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"

#: src/additional_resources/design-principles.md:50
#, fuzzy
msgid ""
"bundling of data with the methods that operate on that data, or the "
"restricting\n"
"of direct access to some of an object's components. Encapsulation is used "
"to\n"
"hide the values or state of a structured data object inside a class, "
"preventing\n"
"unauthorized parties' direct access to them."
msgstr ""
"データとそのデータを操作するメソッドのバンドルや、オブジェクトのコンポーネン"
"トの一部への直接アクセスの制限。\n"
"オブジェクトのコンポーネントの一部への直接アクセスを制限します。カプセル化"
"は\n"
"構造化されたデータオブジェクトの値や状態をクラス内に隠すことで、 許可されてい"
"ない人がオブジェクトに直接アクセスできないようにします。\n"
"構造化されたデータオブジェクトの値や状態をクラス内に隠し、 許可されていない人"
"が直接アクセスできないようにします。"

#: src/additional_resources/design-principles.md:55
#, fuzzy
msgid ""
"## [Command-Query-Separation(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"
msgstr ""
"## [コマンドクエリ分離(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"

#: src/additional_resources/design-principles.md:57
#, fuzzy
msgid ""
"“Functions should not produce abstract side effects...only commands\n"
"(procedures) will be permitted to produce side effects.” - Bertrand Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"\"関数は抽象的な副作用を発生させるべきではありません。\n"
"(手続き）のみが副作用を生成することを許されます。\" - バートランド・マイ"
"ヤー\n"
"オブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:61
#, fuzzy
msgid ""
"## [Principle of least astonishment (POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"
msgstr ""
"## [最小驚嘆の原則(POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"

#: src/additional_resources/design-principles.md:63
#, fuzzy
msgid ""
"a component of a system should behave in a way that most users will expect "
"it\n"
"to behave. The behavior should not astonish or surprise users"
msgstr ""
"システムのコンポーネントは、ほとんどのユーザーが期待するような振る舞いをする"
"ものでなければなりません。\n"
"であるべきです。その振る舞いは、ユーザーを驚かせたり、驚かせたりするもので"
"あってはなりません。"

#: src/additional_resources/design-principles.md:66
#, fuzzy
msgid "## Linguistic-Modular-Units"
msgstr "## 言語モジュール単位"

#: src/additional_resources/design-principles.md:68
#, fuzzy
msgid ""
"“Modules must correspond to syntactic units in the language used.” - "
"Bertrand\n"
"Meyer: Object-Oriented Software Construction"
msgstr ""
"\"モジュールは使用言語の構文単位に対応しなければならない\" - バートランド\n"
"マイヤーオブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:71
#, fuzzy
msgid "## Self-Documentation"
msgstr "#自己文書化"

#: src/additional_resources/design-principles.md:73
#, fuzzy
msgid ""
"“The designer of a module should strive to make all information about the\n"
"module part of the module itself.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"「モジュールの設計者は、モジュールに関するすべての情報をモジュール自体の一部"
"とするよう努めるべきです。\n"
"モジュールの設計者は、モジュールに関するすべての情報をモジュール自体の一部と"
"するよう努めるべきです。\" - バートランド・マイヤーオブジェクト指向ソフトウェ"
"ア\n"
"構築"

#: src/additional_resources/design-principles.md:77
#, fuzzy
msgid "## Uniform-Access"
msgstr "## ♪ユニフォーム・アクセス"

#: src/additional_resources/design-principles.md:79
#, fuzzy
msgid ""
"“All services offered by a module should be available through a uniform\n"
"notation, which does not betray whether they are implemented through storage "
"or\n"
"through computation.” - Bertrand Meyer: Object-Oriented Software Construction"
msgstr ""
"「モジュールによって提供されるすべてのサービスは、統一された表記法によって利"
"用可能であるべきです。\n"
"モジュールによって提供されるすべてのサービスは、統一された記法によって利用可"
"能であるべきです。\n"
"計算によって実装されているかどうかを裏切ることはありません。\" - バートラン"
"ド・メイヤーオブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:83
#, fuzzy
msgid "## Single-Choice"
msgstr "## シングルチョイス"

#: src/additional_resources/design-principles.md:85
#, fuzzy
msgid ""
"“Whenever a software system must support a set of alternatives, one and "
"only\n"
"one module in the system should know their exhaustive list.” - Bertrand "
"Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"\"ソフトウェアシステムが一連の選択肢をサポートしなければならないときはいつで"
"も、システム内の1つのモジュールだけが、その選択肢の網羅的なリストを知っていな"
"ければなりません。\n"
"つのモジュールだけが、その選択肢の網羅的なリストを知っていなければなりませ"
"ん。\" - バートランド・マイヤー\n"
"オブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:89
#, fuzzy
msgid "## Persistence-Closure"
msgstr "#永続性-閉鎖"

#: src/additional_resources/design-principles.md:91
#, fuzzy
msgid ""
"“Whenever a storage mechanism stores an object, it must store with it the\n"
"dependents of that object. Whenever a retrieval mechanism retrieves a\n"
"previously stored object, it must also retrieve any dependent of that "
"object\n"
"that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"\"ストレージメカニズムがオブジェクトを格納するときは、必ずそのオブジェクトの"
"従属オブジェクトも一緒に格納しなければなりません。\n"
"を格納しなければなりません。検索機構が以前に格納されたオブジェクトを検索する"
"ときは常に\n"
"検索機構が以前に格納されたオブジェクトを検索するときは常に、そのオブジェクト"
"の依存関係も検索しなければなりません。\n"
"を取り出す必要があります。\" - バートランド・マイヤーオブジェクト指向ソフト"
"ウェア\n"
"構築"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "// Some type, not necessarily in the same module or even crate.\n"
#~ "struct Foo {\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // These functions are not present on Bar.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// The newtype.\n"
#~ "pub struct Bar(Foo);\n"
#~ "\n"
#~ "impl Bar {\n"
#~ "    // Constructor.\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> Self {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...);\n"
#~ "\n"
#~ "    // Foo and Bar are type incompatible, the following do not type "
#~ "check.\n"
#~ "    // let f: Foo = b;\n"
#~ "    // let b: Bar = Foo { ... };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト,無視\n"
#~ "// 同じモジュールやクレート内にあるとは限りません。\n"
#~ "struct Foo {.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // これらの関数はBarにはありません。\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// ニュータイプ。\n"
#~ "pub struct Bar(Foo)；\n"
#~ "\n"
#~ "impl Bar { // コンストラクタ。\n"
#~ "    // コンストラクタ。\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> 自己 {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...)；\n"
#~ "\n"
#~ "    // Foo と Bar は型互換性がありません。\n"
#~ "    // let f: Foo = b；\n"
#~ "    // let b: Bar = Foo { ...};\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "# Compose structs together for better borrowing"
#~ msgstr "# 構造体をまとめると借りやすくなります"

#, fuzzy
#~ msgid "TODO - this is not a very snappy name"
#~ msgstr "TODO - この名前はあまりスマートではありません。"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "struct A {\n"
#~ "    f1: u32,\n"
#~ "    f2: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    // The later usage of x causes a to be borrowed for the rest of the "
#~ "function.\n"
#~ "    let x = foo(a);\n"
#~ "    // Borrow checker error:\n"
#~ "    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more "
#~ "than once\n"
#~ "                       //          at a time\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "錆\n"
#~ "構造体 A {\n"
#~ "    f1: u32、\n"
#~ "    f2: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }.\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { // 後で x を使用すると、以下のようになります。\n"
#~ "    // xの後の使用により、aは関数の残りの部分で借用されます。\n"
#~ "    let x = foo(a)；\n"
#~ "    // 借用チェッカーのエラー：\n"
#~ "    // let y = bar(a); // ~ ERROR: `*a` を mutable として複数回借りること"
#~ "はできません。\n"
#~ "                       // 一度に\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "// A is now composed of two structs - B and C.\n"
#~ "struct A {\n"
#~ "    b: B,\n"
#~ "    c: C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32,\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "// These functions take a B or C, rather than A.\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    let x = foo(&mut a.b);\n"
#~ "    // Now it's OK!\n"
#~ "    let y = bar(&mut a.c);\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "// AはBとCの2つの構造体で構成されます。\n"
#~ "struct A {\n"
#~ "    b: B、\n"
#~ "    c:C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32、\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "// これらの関数は、AではなくBまたはCを取ります。\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }.\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { { fn x = foo(&mut B) -> u32\n"
#~ "    let x = foo(&mut a.b)；\n"
#~ "    // これでOK！\n"
#~ "    let y = bar(&mut a.c)；\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "TODO Why and where you should use the pattern"
#~ msgstr "TODO パターンを使うべき理由と場所"

#, fuzzy
#~ msgid "Often produces a better design."
#~ msgstr "多くの場合、より良いデザインが生まれます。"

#, fuzzy
#~ msgid "Leads to more verbose code."
#~ msgstr "より冗長なコードになります。"
