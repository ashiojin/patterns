msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-08-26 17:40+0900\n"
"Last-Translator: ashiojin@gmail.com\n"
"Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "はじめに"

#: src/SUMMARY.md:4
msgid "Translations"
msgstr "翻訳"

#: src/SUMMARY.md:5
msgid "Idioms"
msgstr "イディオム"

#: src/SUMMARY.md:6
msgid "Use borrowed types for arguments"
msgstr "引数には借用型（borrowed types）を使用する"

#: src/SUMMARY.md:7
msgid "Concatenating Strings with format!"
msgstr "format!による文字列の連結"

#: src/SUMMARY.md:8
msgid "Constructor"
msgstr "コンストラクタ"

#: src/SUMMARY.md:9
msgid "The Default Trait"
msgstr "Default トレイト"

#: src/SUMMARY.md:10
msgid "Collections Are Smart Pointers"
msgstr "スマートポインタとしてのコレクション"

#: src/SUMMARY.md:11
msgid "Finalisation in Destructors"
msgstr "デストラクタでのファイナライズ"

#: src/SUMMARY.md:12
msgid "mem::{take(_), replace(_)}"
msgstr "mem::{take(_), replace(_)}"

#: src/SUMMARY.md:13
msgid "On-Stack Dynamic Dispatch"
msgstr "オンスタックの動的ディスパッチ"

#: src/SUMMARY.md:14 src/SUMMARY.md:40
msgid "Foreign function interface (FFI)"
msgstr "Foreign function interface (FFI)"

#: src/SUMMARY.md:15
msgid "Idiomatic Errors"
msgstr "慣習的なエラー"

#: src/SUMMARY.md:16
msgid "Accepting Strings"
msgstr "文字列の受け入れ"

#: src/SUMMARY.md:17
msgid "Passing Strings"
msgstr "文字列の受け渡し"

#: src/SUMMARY.md:18
msgid "Iterating over an Option"
msgstr "Option に対する反復処理"

#: src/SUMMARY.md:19
msgid "Pass Variables to Closure"
msgstr "変数をクロージャに渡す"

#: src/SUMMARY.md:20
msgid "Privacy For Extensibility"
msgstr "拡張性のための隠蔽"

#: src/SUMMARY.md:21
msgid "Easy doc initialization"
msgstr "docコメント内の簡易な初期化"

#: src/SUMMARY.md:22
msgid "Temporary mutability"
msgstr "一時的なミュータビリティ"

#: src/SUMMARY.md:23
msgid "Return consumed arg on error"
msgstr "エラー時に消費された引数を返す"

#: src/SUMMARY.md:25
msgid "Design Patterns"
msgstr "デザインパターン"

#: src/SUMMARY.md:26
msgid "Behavioural"
msgstr "振る舞いに関するパターン"

#: src/SUMMARY.md:27
msgid "Command"
msgstr "Command"

#: src/SUMMARY.md:28
msgid "Interpreter"
msgstr "Interpreter"

#: src/SUMMARY.md:29
msgid "Newtype"
msgstr "NewType"

#: src/SUMMARY.md:30
msgid "RAII Guards"
msgstr "RAIIガード"

#: src/SUMMARY.md:31
msgid "Strategy"
msgstr "Strategy"

#: src/SUMMARY.md:32
msgid "Visitor"
msgstr "Visitor"

#: src/SUMMARY.md:33
msgid "Creational"
msgstr "生成に関するパターン"

#: src/SUMMARY.md:34
msgid "Builder"
msgstr "Builder"

#: src/SUMMARY.md:35
msgid "Fold"
msgstr "Fold"

#: src/SUMMARY.md:36
msgid "Structural"
msgstr "構造に関するパターン"

# 英題おかしくない？
#: src/SUMMARY.md:37
msgid "Compose Structs"
msgstr "構造体の構成"

#: src/SUMMARY.md:38
msgid "Prefer Small Crates"
msgstr "小さなクレートを好む"

#: src/SUMMARY.md:39
msgid "Contain unsafety in small modules"
msgstr "安全でないものを小さなモジュールに閉じ込める"

#: src/SUMMARY.md:41
msgid "Object-Based APIs"
msgstr "オブジェクトベースのAPI"

#: src/SUMMARY.md:42
msgid "Type Consolidation into Wrappers"
msgstr "ラッパーへの型の統合"

#: src/SUMMARY.md:44
msgid "Anti-patterns"
msgstr "アンチパターン"

#: src/SUMMARY.md:45
msgid "Clone to satisfy the borrow checker"
msgstr "借用チェッカーを満足させるためのクローン"

#: src/SUMMARY.md:46
msgid "#[deny(warnings)]"
msgstr "#[deny(warnings)]"

#: src/SUMMARY.md:47
msgid "Deref Polymorphism"
msgstr "Deref ポリモーフィズム"

#: src/SUMMARY.md:49
msgid "Functional Programming"
msgstr "関数型プログラミング"

#: src/SUMMARY.md:50
#, fuzzy
msgid "Programming paradigms"
msgstr "プログラミング・パラダイム"

#: src/SUMMARY.md:51
#, fuzzy
msgid "Generics as Type Classes"
msgstr "型クラスとしてのジェネリック"

#: src/SUMMARY.md:52
#, fuzzy
msgid "Lenses and Prisms"
msgstr "レンズとプリズム"

#: src/SUMMARY.md:54
msgid "Additional Resources"
msgstr "追加リソース"

#: src/SUMMARY.md:55
#, fuzzy
msgid "Design principles"
msgstr "設計原則"

#: src/intro.md:1
msgid "# Introduction"
msgstr "# はじめに"

#: src/intro.md:3
msgid "## Participation"
msgstr "## 参加"

#: src/intro.md:5
msgid ""
"If you are interested in contributing to this book, check out the\n"
"[contribution guidelines](https://github.com/rust-unofficial/patterns/blob/"
"master/CONTRIBUTING.md)."
msgstr ""
"本書への寄稿にご興味のある方は、[contribution guidelines](https://github.com/"
"rust-unofficial/patterns/blob/master/CONTRIBUTING.md)をご覧ください。"

#: src/intro.md:8
msgid "## Design patterns"
msgstr "## デザインパターン"

#: src/intro.md:10
msgid ""
"In software development, we often come across problems that share\n"
"similarities regardless of the environment they appear in. Although the\n"
"implementation details are crucial to solve the task at hand, we may\n"
"abstract from these particularities to find the common practices that\n"
"are generically applicable."
msgstr ""
"ソフトウェア開発では、それがどのような環境で発生したかに関係なく、共通点を持"
"つ問題に出くわすことがよくあります。目の前の課題を解決するためにはその実装上"
"の詳細が非常に重要ですが、私たちはこのような特殊性を抽象化して、一般的に適用"
"可能な共通プラクティスを見出すことが可能です。"

#: src/intro.md:16
msgid ""
"Design patterns are a collection of reusable and tested solutions to\n"
"recurring problems in engineering. They make our software more modular,\n"
"maintainable, and extensible. Moreover, these patterns provide a common\n"
"language for developers, making them an excellent tool for effective\n"
"communication when problem-solving in teams."
msgstr ""
"デザインパターンとは、エンジニアリングで繰り返し発生する問題に対する、再利用"
"可能でテスト済みの解決策を集めたものです。\n"
"デザインパターンは、ソフトウェアをよりモジュール化し保守性と拡張性を高めま"
"す。さらに、これらのパターンは開発者に共通言語を提供するため、チームが問題解"
"決する際の効果的なコミュニケーションツールとなります。"

#: src/intro.md:22 src/patterns/index.md:14
msgid "## Design patterns in Rust"
msgstr "## Rustのデザインパターン"

#: src/intro.md:24
msgid ""
"Rust is not object-oriented, and the combination of all its "
"characteristics,\n"
"such as functional elements, a strong type system, and the borrow checker,\n"
"makes it unique.\n"
"Because of this, Rust design patterns vary with respect to other\n"
"traditional object-oriented programming languages.\n"
"That's why we decided to write this book. We hope you enjoy reading it!\n"
"The book is divided in three main chapters:"
msgstr ""
"Rustはオブジェクト指向ではありません。また、関数型プログラミングの要素、強力"
"な型システム、借用チェッカーなど、Rustのすべての特徴の組み合わせがRustをユ"
"ニークなものにしています。このため、Rust のデザインパターンは他の伝統的なオブ"
"ジェクト指向プログラミング言語とは異なります。これが私たちがこの本を書くこと"
"にした理由です。ご愛読いただければ幸いです！\n"
"本書は大きく3つの章に分かれています："

#: src/intro.md:32
msgid ""
"- [Idioms](./idioms/index.md): guidelines to follow when coding.\n"
"  They are the social norms of the community.\n"
"  You should break them only if you have a good reason for it.\n"
"- [Design patterns](./patterns/index.md): methods to solve common problems\n"
"  when coding.\n"
"- [Anti-patterns](./anti_patterns/index.md): methods to solve common "
"problems\n"
"  when coding.\n"
"  However, while design patterns give us benefits,\n"
"  anti-patterns create more problems."
msgstr ""
"- [イディオム](./idioms/index.md)：コーディングの際に従うべきガイドライン。\n"
"  コミュニティの社会的規範です。正当な理由がある場合のみ、破るべきです。\n"
"- [デザインパターン](./patterns/index.md): コーディングの際によくある問題を解"
"決するための方法です。\n"
"- [アンチパターン](./anti_patterns/index.md): コーディング時によくある問題を"
"解決するための方法です。\n"
"  ただし、デザインパターンが私たちに利益を与えてくれるのに対し、アンチパター"
"ンはより多くの問題を引き起こします。"

#: src/translations.md:1
msgid "# Translations"
msgstr "# 翻訳"

#: src/translations.md:3
msgid ""
"We are utilizing [mdbook-i18n-helper](https://github.com/google/mdbook-i18n-"
"helpers).\n"
"Please read up on how to _add_ and _update_ translations in [their "
"repository](https://github.com/google/mdbook-i18n-helpers#creating-and-"
"updating-translations)"
msgstr ""
"私たちは[mdbook-i18n-helper](https://github.com/google/mdbook-i18n-helpers)を"
"利用しています。翻訳の追加と更新の方法は[そのリポジトリ](https://github.com/"
"google/mdbook-i18n-helpers#creating-and-updating-translations)を参照してくだ"
"さい。"

#: src/translations.md:6
msgid "## External translations"
msgstr "## 外部の翻訳"

#: src/translations.md:8
msgid "- [简体中文](https://fomalhauthmj.github.io/patterns/)"
msgstr "- [简体中文](https://fomalhauthmj.github.io/patterns/)"

#: src/translations.md:10
msgid ""
"If you want to add a translation, please open an issue in the\n"
"[main repository](https://github.com/rust-unofficial/patterns)."
msgstr ""
"翻訳を追加したい場合は、[メインリポジトリ](https://github.com/rust-"
"unofficial/patterns) にissueを開いてください。"

#: src/idioms/index.md:1
msgid "# Idioms"
msgstr "# イディオム"

#: src/idioms/index.md:3
msgid ""
"[Idioms](https://en.wikipedia.org/wiki/Programming_idiom) are commonly used\n"
"styles, guidelines and patterns largely agreed upon by a community.\n"
"Writing idiomatic code allows other developers to understand better what is\n"
"happening."
msgstr ""
"[イディオム](https://en.wikipedia.org/wiki/Programming_idiom)は、一般的に使わ"
"れているスタイル、ガイドライン、パターンです。\n"
"慣用的なコードを書くことで、他の開発者は何が起こっているのかをよりよく理解す"
"ることができます。"

#: src/idioms/index.md:8
msgid ""
"After all, the computer only cares about the machine code that is generated\n"
"by the compiler.\n"
"Instead, the source code is mainly beneficial to the developer.\n"
"So, since we have this abstraction layer, why not make it more readable?"
msgstr ""
"結局のところ、コンピュータにとって重要なものは、コンパイラが生成したマシン"
"コードのみです。\n"
"むしろ、ソースコードは主に開発者にとって有益なものです。\n"
"せっかく、私たちには抽象化レイヤーがあるのですから、もっと読みやすくしたらど"
"うでしょう？"

#: src/idioms/index.md:13
msgid ""
"Remember the [KISS principle](https://en.wikipedia.org/wiki/"
"KISS_principle):\n"
"\"Keep It Simple, Stupid\". It claims that \"most systems work best if they "
"are\n"
"kept simple rather than made complicated; therefore, simplicity should be a "
"key\n"
"goal in design, and unnecessary complexity should be avoided\"."
msgstr ""
"[KISSの原則](https://en.wikipedia.org/wiki/KISS_principle) ：「シンプルにして"
"おけ！この間抜け」を思い出してください。この原則は、「ほとんどのシステムは、"
"複雑にするよりもシンプルにしたほうが最もうまく機能する。したがって、シンプル"
"であることが設計における重要な目標であるべきであり、不必要な複雑さは避けるべ"
"きである」と主張しています。"

#: src/idioms/index.md:18
msgid "> Code is there for humans, not computers, to understand."
msgstr ""
"> コードは人間が理解するものであって、コンピューターが理解するものではありま"
"せん。"

#: src/idioms/coercion-arguments.md:1
msgid "# Use borrowed types for arguments"
msgstr "# 引数には借用型（borrowed types）を使用する"

#: src/idioms/coercion-arguments.md:3 src/idioms/concat-format.md:3
#: src/idioms/ctor.md:3 src/idioms/default.md:3 src/idioms/deref.md:3
#: src/idioms/dtor-finally.md:3 src/idioms/mem-replace.md:3
#: src/idioms/on-stack-dyn-dispatch.md:3 src/idioms/ffi/errors.md:3
#: src/idioms/ffi/accepting-strings.md:3 src/idioms/ffi/passing-strings.md:3
#: src/idioms/option-iter.md:3 src/idioms/pass-var-to-closure.md:3
#: src/idioms/priv-extend.md:3 src/idioms/rustdoc-init.md:3
#: src/idioms/temporary-mutability.md:3
#: src/idioms/return-consumed-arg-on-error.md:3
#: src/patterns/behavioural/command.md:3
#: src/patterns/behavioural/interpreter.md:3
#: src/patterns/behavioural/newtype.md:13 src/patterns/behavioural/RAII.md:3
#: src/patterns/behavioural/strategy.md:3 src/patterns/behavioural/visitor.md:3
#: src/patterns/creational/builder.md:3 src/patterns/creational/fold.md:3
#: src/patterns/structural/compose-structs.md:3
#: src/patterns/structural/small-crates.md:3
#: src/patterns/structural/unsafe-mods.md:3 src/patterns/ffi/export.md:3
#: src/patterns/ffi/wrappers.md:3 src/anti_patterns/borrow_clone.md:3
#: src/anti_patterns/deny-warnings.md:3 src/anti_patterns/deref.md:3
#: src/functional/generics-type-classes.md:3
msgid "## Description"
msgstr "## 説明"

#: src/idioms/coercion-arguments.md:5
msgid ""
"Using a target of a deref coercion can increase the flexibility of your "
"code\n"
"when you are deciding which argument type to use for a function argument.\n"
"In this way, the function will accept more input types."
msgstr ""
"関数の引数にどの型を使うかを決めるときに、参照外し型強制(deref coercion)の対"
"象を使うことで、コードの柔軟性を高めることができます。この方法により、関数は"
"より多くの型を入力として受け入れられるようになります。"

#: src/idioms/coercion-arguments.md:9
msgid ""
"This is not limited to slice-able or fat pointer types.\n"
"In fact, you should always prefer using the **borrowed type** over\n"
"**borrowing the owned type**.\n"
"Such as `&str` over `&String`, `&[T]` over `&Vec<T>`, or `&T` over `&Box<T>`."
msgstr ""
"これはスライス可能な型やファットポインタ型に限ったことではありません。\n"
"実際、**所有型の借用**よりも **借用型** を常に使用することをお勧めします。\n"
"例えば、 `&String` よりも `&str` の方が、 `&Vec<T>` よりも `&[T]` の方が、 "
"`&Box<T>` よりも `&T` の方が優れています。"

#: src/idioms/coercion-arguments.md:14
msgid ""
"Using borrowed types you can avoid layers of indirection for those "
"instances\n"
"where the owned type already provides a layer of indirection. For instance, "
"a\n"
"`String` has a layer of indirection, so a `&String` will have two layers of\n"
"indirection. We can avoid this by using `&str` instead, and letting "
"`&String`\n"
"coerce to a `&str` whenever the function is invoked."
msgstr ""
"借用型を使えば、所有型がすでに間接的なレイヤーを提供しているような場合に、そ"
"のインスタンスに対する多重の間接的なレイヤーを避けることができます。例えば "
"`String` には間接的なレイヤーがあるので、 `&String` は2つの間接的なレイヤーを"
"持つことになってしまいます。\n"
"代わりに `&str` を使用し、関数呼び出し毎に `&String` を `&str` に型強制するこ"
"とでこれを避けることができます。"

#: src/idioms/coercion-arguments.md:20 src/idioms/concat-format.md:10
#: src/idioms/default.md:20 src/idioms/deref.md:9 src/idioms/dtor-finally.md:9
#: src/idioms/mem-replace.md:11 src/idioms/on-stack-dyn-dispatch.md:10
#: src/idioms/pass-var-to-closure.md:12 src/idioms/priv-extend.md:18
#: src/idioms/rustdoc-init.md:45 src/idioms/temporary-mutability.md:12
#: src/idioms/return-consumed-arg-on-error.md:8
#: src/patterns/behavioural/command.md:18
#: src/patterns/behavioural/newtype.md:18 src/patterns/behavioural/RAII.md:11
#: src/patterns/behavioural/strategy.md:28
#: src/patterns/behavioural/visitor.md:13 src/patterns/creational/builder.md:7
#: src/patterns/creational/fold.md:12
#: src/patterns/structural/compose-structs.md:15
#: src/anti_patterns/borrow_clone.md:11 src/anti_patterns/deny-warnings.md:8
#: src/anti_patterns/deref.md:8 src/functional/generics-type-classes.md:38
msgid "## Example"
msgstr "## 例"

#: src/idioms/coercion-arguments.md:22
msgid ""
"For this example, we will illustrate some differences for using `&String` as "
"a\n"
"function argument versus using a `&str`, but the ideas apply as well to "
"using\n"
"`&Vec<T>` versus using a `&[T]` or using a `&Box<T>` versus a `&T`."
msgstr ""
"この例では、関数の引数として `&String` を使用する場合と `&str` を使用する場合"
"の違いを説明します。例で示すものは型の組み合わせが `Vec<T>` に対して "
"`&[T]` 、 `&Box<T>` に対して `&T` 、などあっても同様です。"

#: src/idioms/coercion-arguments.md:26
msgid ""
"Consider an example where we wish to determine if a word contains three\n"
"consecutive vowels. We don't need to own the string to determine this, so "
"we\n"
"will take a reference."
msgstr ""
"例として、ある単語が3つの連続した母音を含むかどうかを調べたい場合を考えてみま"
"しょう。調べるにあたって、対象の文字列を所有する必要はありません。私たちは参"
"照を使うでしょう。"

#: src/idioms/coercion-arguments.md:30
msgid "The code might look something like this:"
msgstr "コードは次のようになります："

#: src/idioms/coercion-arguments.md:32
msgid ""
"```rust\n"
"fn three_vowels(word: &String) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let ferris = \"Ferris\".to_string();\n"
"    let curious = \"Curious\".to_string();\n"
"    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
"    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
"\n"
"    // This works fine, but the following two lines would fail:\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn three_vowels(word: &String) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let ferris = \"Ferris\".to_string();\n"
"    let curious = \"Curious\".to_string();\n"
"    println!(\"{}: {}\", ferris, three_vowels(&ferris));\n"
"    println!(\"{}: {}\", curious, three_vowels(&curious));\n"
"\n"
"    // 以上はうまく動作する。しかし以下の2行は失敗する：\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
"\n"
"}\n"
"```"

#: src/idioms/coercion-arguments.md:62
msgid ""
"This works fine because we are passing a `&String` type as a parameter.\n"
"If we remove the comments on the last two lines, the example will fail. "
"This\n"
"is because a `&str` type will not coerce to a `&String` type. We can fix "
"this\n"
"by simply modifying the type for our argument."
msgstr ""
"これは `&String` 型をパラメータとして渡しているため、問題なく動作します。最後"
"の2行のコメントを削除すると、この例は失敗します。これは `&str` 型が "
"`&String` 型に型強制されないからです。この問題を、単に引数の型を変更すること"
"で修正できます。"

#: src/idioms/coercion-arguments.md:67
msgid "For instance, if we change our function declaration to:"
msgstr "例えば、関数宣言を次のように変更します："

#: src/idioms/coercion-arguments.md:69
msgid ""
"```rust, ignore\n"
"fn three_vowels(word: &str) -> bool {\n"
"```"
msgstr ""
"```rust, ignore\n"
"fn three_vowels(word: &str) -> bool {\n"
"```"

#: src/idioms/coercion-arguments.md:73
msgid "then both versions will compile and print the same output."
msgstr ""
"すると、上述の例のどちらのバージョンもコンパイルされ、同じ出力が表示されま"
"す。"

#: src/idioms/coercion-arguments.md:75
msgid ""
"```bash\n"
"Ferris: false\n"
"Curious: true\n"
"```"
msgstr ""
"```bash\n"
"Ferris: false\n"
"Curious: true\n"
"```"

#: src/idioms/coercion-arguments.md:80
msgid ""
"But wait, that's not all! There is more to this story.\n"
"It's likely that you may say to yourself: that doesn't matter, I will never "
"be\n"
"using a `&'static str` as an input anyways (as we did when we used "
"`\"Ferris\"`).\n"
"Even ignoring this special example, you may still find that using `&str` "
"will\n"
"give you more flexibility than using a `&String`."
msgstr ""
"でも待ってください！この話にはまだ続きがあります。もしかしたら、あなたは"
"「 `&'static str` （上述の例では `\"Ferris\"` ）を入力に使うことは絶対ない"
"し・・・」と考え、こんなことどうでもいいと感じるかもしれません。\n"
"または、この特別な例を無視しても、`&str`を使用する方が`&'static str`を使用す"
"るよりも柔軟性があることに気づくかもしれません。"

#: src/idioms/coercion-arguments.md:86
msgid ""
"Let's now take an example where someone gives us a sentence, and we want to\n"
"determine if any of the words in the sentence contain three consecutive "
"vowels.\n"
"We probably should make use of the function we have already defined and "
"simply\n"
"feed in each word from the sentence."
msgstr ""
"では、誰かが私たちに文章を与えたとして、その中に3つの母音が連続する単語がある"
"かどうかを調べる例を考えてみましょう。\n"
"この場合、すでに定義した関数を利用すべきでしょう。単純に、文中の単語を関数に"
"与えるべきです。"

#: src/idioms/coercion-arguments.md:91
msgid "An example of this could look like this:"
msgstr "その例は次のようなものです："

#: src/idioms/coercion-arguments.md:93
msgid ""
"```rust\n"
"fn three_vowels(word: &str) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let sentence_string =\n"
"        \"Once upon a time, there was a friendly curious crab named Ferris\"."
"to_string();\n"
"    for word in sentence_string.split(' ') {\n"
"        if three_vowels(word) {\n"
"            println!(\"{} has three consecutive vowels!\", word);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn three_vowels(word: &str) -> bool {\n"
"    let mut vowel_count = 0;\n"
"    for c in word.chars() {\n"
"        match c {\n"
"            'a' | 'e' | 'i' | 'o' | 'u' => {\n"
"                vowel_count += 1;\n"
"                if vowel_count >= 3 {\n"
"                    return true\n"
"                }\n"
"            }\n"
"            _ => vowel_count = 0\n"
"        }\n"
"    }\n"
"    false\n"
"}\n"
"\n"
"fn main() {\n"
"    let sentence_string =\n"
"        \"Once upon a time, there was a friendly curious crab named Ferris\"."
"to_string();\n"
"    for word in sentence_string.split(' ') {\n"
"        if three_vowels(word) {\n"
"            println!(\"{} has three consecutive vowels!\", word);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/coercion-arguments.md:121
msgid ""
"Running this example using our function declared with an argument type "
"`&str`\n"
"will yield"
msgstr ""
"引数を `&str` として宣言した関数を使用してこの例を実行すると、次のようになる"
"でしょう"

#: src/idioms/coercion-arguments.md:124
msgid ""
"```bash\n"
"curious has three consecutive vowels!\n"
"```"
msgstr ""
"```bash\n"
"curious has three consecutive vowels!\n"
"```"

#: src/idioms/coercion-arguments.md:128
msgid ""
"However, this example will not run when our function is declared with an\n"
"argument type `&String`. This is because string slices are a `&str` and not "
"a\n"
"`&String` which would require an allocation to be converted to `&String` "
"which\n"
"is not implicit, whereas converting from `String` to `&str` is cheap and "
"implicit."
msgstr ""
"しかし私たちが関数の引数型を `&String` として宣言していた場合には、この例は実"
"行できません。これは、文字列スライスが `&str` であり、`&String` ではないため"
"です。 `&str` は `&String` に変換するためにはアロケーションを必要とし、暗黙期"
"には変換されません。対して `String` は `&str` に安価かつ暗黙的に変換されま"
"す。"

#: src/idioms/coercion-arguments.md:133 src/idioms/ctor.md:101
#: src/idioms/default.md:58 src/idioms/deref.md:76
#: src/idioms/dtor-finally.md:88 src/idioms/mem-replace.md:108
#: src/idioms/on-stack-dyn-dispatch.md:83 src/idioms/option-iter.md:46
#: src/idioms/priv-extend.md:120 src/patterns/behavioural/command.md:218
#: src/patterns/behavioural/interpreter.md:142
#: src/patterns/behavioural/newtype.md:93 src/patterns/behavioural/RAII.md:111
#: src/patterns/behavioural/strategy.md:174
#: src/patterns/behavioural/visitor.md:106
#: src/patterns/creational/builder.md:108 src/patterns/creational/fold.md:109
#: src/patterns/structural/small-crates.md:45
#: src/patterns/structural/unsafe-mods.md:32
#: src/anti_patterns/borrow_clone.md:68 src/anti_patterns/deny-warnings.md:96
#: src/anti_patterns/deref.md:123 src/functional/generics-type-classes.md:237
msgid "## See also"
msgstr "## See also"

#: src/idioms/coercion-arguments.md:135
msgid ""
"- [Rust Language Reference on Type Coercions](https://doc.rust-lang.org/"
"reference/type-coercions.html)\n"
"- For more discussion on how to handle `String` and `&str` see\n"
"  [this blog series (2015)](https://web.archive.org/web/20201112023149/"
"https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html)\n"
"  by Herman J. Radtke III"
msgstr ""
"- [型強制(Type coercions)に関するRust言語リファレンス](https://doc.rust-lang."
"org/reference/type-coercions.html)\n"
"- `String`と`&str`の扱い方に関する議論は、Herman J. Radtke III の\n"
"  [このブログのシリーズ(2015)](https://web.archive.org/web/20201112023149/"
"https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html) を"
"見てください"

#: src/idioms/concat-format.md:1
msgid "# Concatenating strings with `format!`"
msgstr "# `format! による文字列の連結"

#: src/idioms/concat-format.md:5
msgid ""
"It is possible to build up strings using the `push` and `push_str` methods "
"on a\n"
"mutable `String`, or using its `+` operator. However, it is often more\n"
"convenient to use `format!`, especially where there is a mix of literal and\n"
"non-literal strings."
msgstr ""
"`String` の `push` メソッドや `push_str` メソッドを使用したり、 `+` 演算子を"
"使用したりすることで、文字列を構築することは可能です。\n"
"しかし`format!` を使用した方がより便利なことがあります。特にリテラル文字列と"
"非リテラル文字列が混在している場合がそうです。"

#: src/idioms/concat-format.md:12
msgid ""
"```rust\n"
"fn say_hello(name: &str) -> String {\n"
"    // We could construct the result string manually.\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
"\n"
"    // But using format! is better.\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn say_hello(name: &str) -> String {\n"
"    // 以下のように result 文字列を構築することができます。\n"
"    // let mut result = \"Hello \".to_owned();\n"
"    // result.push_str(name);\n"
"    // result.push('!');\n"
"    // result\n"
"\n"
"    // しかし format! を使うほうがよいでしょう。\n"
"    format!(\"Hello {}!\", name)\n"
"}\n"
"```"

#: src/idioms/concat-format.md:25 src/idioms/deref.md:43
#: src/idioms/dtor-finally.md:42 src/idioms/mem-replace.md:83
#: src/idioms/on-stack-dyn-dispatch.md:48 src/idioms/ffi/errors.md:131
#: src/idioms/ffi/accepting-strings.md:68 src/idioms/ffi/passing-strings.md:68
#: src/idioms/pass-var-to-closure.md:48 src/idioms/rustdoc-init.md:77
#: src/idioms/temporary-mutability.md:38
#: src/idioms/return-consumed-arg-on-error.md:55
#: src/patterns/behavioural/newtype.md:55 src/patterns/behavioural/RAII.md:78
#: src/patterns/behavioural/strategy.md:95
#: src/patterns/creational/builder.md:68
#: src/patterns/structural/compose-structs.md:98
#: src/patterns/structural/small-crates.md:12
#: src/patterns/structural/unsafe-mods.md:11 src/patterns/ffi/export.md:111
#: src/patterns/ffi/wrappers.md:63 src/anti_patterns/deny-warnings.md:16
#: src/anti_patterns/deref.md:69 src/functional/generics-type-classes.md:210
msgid "## Advantages"
msgstr "## メリット"

#: src/idioms/concat-format.md:27
msgid ""
"Using `format!` is usually the most succinct and readable way to combine "
"strings."
msgstr ""
"`format!` を使う方法が、通常、文字列を組み合わせる最も簡潔で読みやすい方法で"
"す。"

#: src/idioms/concat-format.md:29 src/idioms/deref.md:50
#: src/idioms/dtor-finally.md:47 src/idioms/mem-replace.md:87
#: src/idioms/on-stack-dyn-dispatch.md:54 src/idioms/ffi/errors.md:136
#: src/idioms/ffi/accepting-strings.md:141
#: src/idioms/ffi/passing-strings.md:103 src/idioms/pass-var-to-closure.md:57
#: src/idioms/rustdoc-init.md:81 src/idioms/temporary-mutability.md:42
#: src/idioms/return-consumed-arg-on-error.md:59
#: src/patterns/behavioural/newtype.md:66
#: src/patterns/behavioural/strategy.md:104
#: src/patterns/creational/builder.md:76
#: src/patterns/structural/compose-structs.md:103
#: src/patterns/structural/small-crates.md:22
#: src/patterns/structural/unsafe-mods.md:17 src/patterns/ffi/export.md:234
#: src/patterns/ffi/wrappers.md:69 src/anti_patterns/deref.md:81
#: src/functional/generics-type-classes.md:221
msgid "## Disadvantages"
msgstr "## デメリット"

#: src/idioms/concat-format.md:31
msgid ""
"It is usually not the most efficient way to combine strings - a series of "
"`push`\n"
"operations on a mutable string is usually the most efficient (especially if "
"the\n"
"string has been pre-allocated to the expected size)."
msgstr ""
"通常、文字列を結合する最も効率的な方法とは言えません。通常、ミュータブルな文"
"字列への `push` の繰り返しが最も効率的です（特に、その文字列があらかじめ期待"
"されるサイズに割り当てられている場合）。"

#: src/idioms/ctor.md:1
msgid "# Constructors"
msgstr "# コンストラクタ"

#: src/idioms/ctor.md:5
msgid ""
"Rust does not have constructors as a language construct. Instead, the\n"
"convention is to use an [associated function][associated function] `new` to "
"create an object:"
msgstr ""
"Rustには、言語の構成要素としてコンストラクタというものを持っていません。\n"
"代わりに [関連関数][associated function] の `new` を使ってオブジェクトを生成"
"するのが一般的です："

#: src/idioms/ctor.md:8
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    // Constructs a new instance of [`Second`].\n"
"    // Note this is an associated function - no self.\n"
"    pub fn new(value: u64) -> Self {\n"
"        Self { value }\n"
"    }\n"
"\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::new(42);\n"
"/// assert_eq!(42, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    // [`Second`] のインスタンスを生成する。\n"
"    // 関連関数であることに注意： self が無い。 \n"
"    pub fn new(value: u64) -> Self {\n"
"        Self { value }\n"
"    }\n"
"\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:35
msgid "## Default Constructors"
msgstr "## デフォルトコンストラクタ"

#: src/idioms/ctor.md:37
msgid ""
"Rust supports default constructors with the [`Default`][std-default] trait:"
msgstr ""
"Rust は [`Default`][std-default] トレイトとして、デフォルトコンストラクタをサ"
"ポートしています："

#: src/idioms/ctor.md:39
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"\n"
"impl Default for Second {\n"
"    fn default() -> Self {\n"
"        Self { value: 0 }\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間。\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"\n"
"impl Default for Second {\n"
"    fn default() -> Self {\n"
"        Self { value: 0 }\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:66
msgid ""
"`Default` can also be derived if all types of all fields implement "
"`Default`,\n"
"like they do with `Second`:"
msgstr ""
"すべてのフィールドのすべての型が `Default` を実装していれば、 `Default` も派"
"生させることができます。下記の `Second` で行っているように："

#: src/idioms/ctor.md:69
msgid ""
"````rust\n"
"/// Time in seconds.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"#[derive(Default)]\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// Returns the value in seconds.\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"/// 秒単位の時間。\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// let s = Second::default();\n"
"/// assert_eq!(0, s.value());\n"
"/// ```\n"
"#[derive(Default)]\n"
"pub struct Second {\n"
"    value: u64\n"
"}\n"
"\n"
"impl Second {\n"
"    /// 秒として値を返す。\n"
"    pub fn value(&self) -> u64 {\n"
"        self.value\n"
"    }\n"
"}\n"
"````"

#: src/idioms/ctor.md:91
msgid ""
"**Note:** It is common and expected for types to implement both\n"
"`Default` and an empty `new` constructor. `new` is the constructor\n"
"convention in Rust, and users expect it to exist, so if it is\n"
"reasonable for the basic constructor to take no arguments, then it\n"
"should, even if it is functionally identical to default."
msgstr ""
"**注意:** 型が `Default` と 空の `new` コンストラクタの両方を実装することは一"
"般的であり、期待されています。\n"
"`new` は Rust におけるコンストラクタの慣習であり、ユーザはその存在を期待して"
"います。\n"
"基本的なコンストラクタが引数を取らないことが合理的であれば、たとえ機能的には "
"default と同じであるとしても、実装すべきです。"

#: src/idioms/ctor.md:97
msgid ""
"**Hint:** The advantage of implementing or deriving `Default` is that your "
"type\n"
"can now be used where a `Default` implementation is required, most "
"prominently,\n"
"any of the [`*or_default` functions in the standard library][std-or-default]."
msgstr ""
"**ヒント:** `Default` を実装または派生させることの利点は、あなたの型が "
"`Default` の実装が必要な場所で使用できるようになることです。特に重要なのは、 "
"[標準ライブラリの `*or_default` 関数][std-or-default] です。"

#: src/idioms/ctor.md:103
msgid ""
"- The [default idiom](default.md) for a more in-depth description of the\n"
"  `Default` trait.\n"
"\n"
"- The [builder pattern](../patterns/creational/builder.md) for constructing\n"
"  objects where there are multiple configurations.\n"
"\n"
"- [API Guidelines/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS] for\n"
"  implementing both, `Default` and `new`."
msgstr ""
"- `Default` トレイトについてのより詳細な記述は [default idiom](default.md)を"
"参照してください。\n"
"\n"
"- 多数の設定項目を持つオブジェクトの構築については [builderパターン](../"
"patterns/creational/builder.md)を参照してください。\n"
"\n"
"- [APIガイドライン/C-COMMON-TRAITS][API Guidelines/C-COMMON-TRAITS]を参照して"
"ください。\n"
"  Default`と`new`の両方を実装します。"

#: src/idioms/default.md:1
msgid "# The `Default` Trait"
msgstr "# `Default` トレイト"

#: src/idioms/default.md:5
msgid ""
"Many types in Rust have a [constructor]. However, this is _specific_ to the\n"
"type; Rust cannot abstract over \"everything that has a `new()` method\". "
"To\n"
"allow this, the [`Default`] trait was conceived, which can be used with\n"
"containers and other generic types (e.g. see [`Option::"
"unwrap_or_default()`]).\n"
"Notably, some containers already implement it where applicable."
msgstr ""
"Rustの多くの型には [コンストラクタ][constructor] があります。しかし、これはそ"
"の型 _固有_ のものです。\n"
"Rustは「 `new()` メソッドを持つものすべて」を抽象化することはできません。\n"
"これを可能にするために、[`Default`] 特性が考案されました。\n"
"コンテナや他のジェネリック型と一緒に使うことができます (例えば、[`Option::"
"unwrap_or_default()`] を参照してください)。\n"
"注目すべきことに、いくつかのコンテナはすでにこれを実装しています。"

#: src/idioms/default.md:11
msgid ""
"Not only do one-element containers like `Cow`, `Box` or `Arc` implement\n"
"`Default` for contained `Default` types, one can automatically\n"
"`#[derive(Default)]` for structs whose fields all implement it, so the more\n"
"types implement `Default`, the more useful it becomes."
msgstr ""
"`Cow`、`Box`、`Arc` のような 1要素のコンテナが内包する `Default` 型に対して "
"`Default` を実装しているだけではありません。 すべてのフィールドが `Default` "
"を実装している構造体に対しては `#[derive(Default)]` による自動派生を適用でき"
"ます。\n"
"型が `Default` を実装すればするほど便利になります。"

#: src/idioms/default.md:16
msgid ""
"On the other hand, constructors can take multiple arguments, while the\n"
"`default()` method does not. There can even be multiple constructors with\n"
"different names, but there can only be one `Default` implementation per type."
msgstr ""
"コンストラクタは複数の引数を取ることができます。対して `default()` メソッドで"
"はできません。\n"
"また異なる名称の複数のコンストラクタを定義することもできます。\n"
"対して `Default` の実装は1つの型につき1つだけです。"

#: src/idioms/default.md:22
msgid ""
"```rust\n"
"use std::{path::PathBuf, time::Duration};\n"
"\n"
"// note that we can simply auto-derive Default here.\n"
"#[derive(Default, Debug, PartialEq)]\n"
"struct MyConfiguration {\n"
"    // Option defaults to None\n"
"    output: Option<PathBuf>,\n"
"    // Vecs default to empty vector\n"
"    search_path: Vec<PathBuf>,\n"
"    // Duration defaults to zero time\n"
"    timeout: Duration,\n"
"    // bool defaults to false\n"
"    check: bool,\n"
"}\n"
"\n"
"impl MyConfiguration {\n"
"    // add setters here\n"
"}\n"
"\n"
"fn main() {\n"
"    // construct a new instance with default values\n"
"    let mut conf = MyConfiguration::default();\n"
"    // do something with conf here\n"
"    conf.check = true;\n"
"    println!(\"conf = {:#?}\", conf);\n"
"        \n"
"    // partial initialization with default values, creates the same "
"instance\n"
"    let conf1 = MyConfiguration {\n"
"        check: true,\n"
"        ..Default::default()\n"
"    };\n"
"    assert_eq!(conf, conf1);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::{path::PathBuf, time::Duration};\n"
"\n"
"// ここでは単にDefaultを自動派生できることに注目してください。\n"
"#[derive(Default, Debug, PartialEq)]\n"
"struct MyConfiguration {\n"
"    // Option のデフォルトは None\n"
"    output: Option<PathBuf>,\n"
"    // Vecs のデフォルトは空のベクタr\n"
"    search_path: Vec<PathBuf>,\n"
"    // Duration のデフォルトは 0時間\n"
"    timeout: Duration,\n"
"    // bool のデフォルトは false\n"
"    check: bool,\n"
"}\n"
"\n"
"impl MyConfiguration {\n"
"    // add setters here\n"
"}\n"
"\n"
"fn main() {\n"
"    // デフォルト値で新しいインスタンスを構築します\n"
"    let mut conf = MyConfiguration::default();\n"
"    // ここで conf に何かをします\n"
"    conf.check = true;\n"
"    println!(\"conf = {:#?}\", conf);\n"
"        \n"
"    // デフォルト値を使い部分的に初期化し、同じインスタンスを作成します。\n"
"    let conf1 = MyConfiguration {\n"
"        check: true,\n"
"        ..Default::default()\n"
"    };\n"
"    assert_eq!(conf, conf1);\n"
"}\n"
"```"

#: src/idioms/default.md:60
msgid ""
"- The [constructor] idiom is another way to generate instances that may or "
"may\n"
"  not be \"default\"\n"
"- The [`Default`] documentation (scroll down for the list of implementors)\n"
"- [`Option::unwrap_or_default()`]\n"
"- [`derive(new)`]"
msgstr ""
"- [コンストラクタ][constructor] イディオムは、 \"default\" であるかどうかにか"
"かわらずインスタンスを生成する別の方法です。\n"
"- [`Default`]ドキュメント (実装する型の一覧は下にスクロールしてください)\n"
"- [`Option::unwrap_or_default()`] \n"
"- [`derive(new)`]"

#: src/idioms/deref.md:1
msgid "# Collections are smart pointers"
msgstr "# スマートポインタとしてのコレクション"

#: src/idioms/deref.md:5
msgid ""
"Use the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)\n"
"trait to treat collections like smart pointers, offering owning\n"
"and borrowed views of data."
msgstr ""
"コレクションに [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) "
"トレイトを使うことで、そのデータに対し所有や借用のビューを提供するスマートポ"
"インタのようにコレクションを扱えます。"

#: src/idioms/deref.md:11
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Vec<T> {\n"
"    data: RawVec<T>,\n"
"    //..\n"
"}\n"
"\n"
"impl<T> Deref for Vec<T> {\n"
"    type Target = [T];\n"
"\n"
"    fn deref(&self) -> &[T] {\n"
"        //..\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Vec<T> {\n"
"    data: RawVec<T>,\n"
"    //..\n"
"}\n"
"\n"
"impl<T> Deref for Vec<T> {\n"
"    type Target = [T];\n"
"\n"
"    fn deref(&self) -> &[T] {\n"
"        //..\n"
"    }\n"
"}\n"
"```"

#: src/idioms/deref.md:28
msgid ""
"A `Vec<T>` is an owning collection of `T`s, while a slice (`&[T]`) is a "
"borrowed\n"
"collection of `T`s. Implementing `Deref` for `Vec` allows implicit "
"dereferencing\n"
"from `&Vec<T>` to `&[T]` and includes the relationship in auto-derefencing\n"
"searches. Most methods you might expect to be implemented for `Vec`s are "
"instead\n"
"implemented for slices."
msgstr ""
"スライス(`&[T]`)が `T` の借用のコレクションであるのに対し、 `Vec<T>` は`T` の"
"所有のコレクションです。\n"
"`Vec` に `Deref` を実装することで、 `&Vec<T>` から `&[T]` への暗黙的な参照外"
"しが可能になるとともに、\n"
"自動参照外しの検索対象に組み込まれます。\n"
"`Vec` に実装されることが期待されるほとんどのメソッドは、代わりにスライスのそ"
"れとして実装されます。"

#: src/idioms/deref.md:34
msgid "Also `String` and `&str` have a similar relation."
msgstr "`String` と `&str` もまた同様の関係にあります。"

#: src/idioms/deref.md:36 src/idioms/dtor-finally.md:32
#: src/idioms/mem-replace.md:57 src/idioms/on-stack-dyn-dispatch.md:37
#: src/idioms/ffi/accepting-strings.md:12 src/idioms/ffi/passing-strings.md:14
#: src/idioms/rustdoc-init.md:9 src/idioms/return-consumed-arg-on-error.md:43
#: src/patterns/behavioural/command.md:8
#: src/patterns/behavioural/interpreter.md:16
#: src/patterns/behavioural/newtype.md:45 src/patterns/behavioural/RAII.md:72
#: src/patterns/behavioural/strategy.md:19
#: src/patterns/behavioural/visitor.md:72 src/patterns/creational/builder.md:63
#: src/patterns/creational/fold.md:73
#: src/patterns/structural/compose-structs.md:92 src/patterns/ffi/export.md:15
#: src/anti_patterns/borrow_clone.md:30
msgid "## Motivation"
msgstr "## 動機"

#: src/idioms/deref.md:38
msgid ""
"Ownership and borrowing are key aspects of the Rust language. Data "
"structures\n"
"must account for these semantics properly to give a good user\n"
"experience. When implementing a data structure that owns its data, offering "
"a\n"
"borrowed view of that data allows for more flexible APIs."
msgstr ""
"所有権と借用はRust言語の重要な側面です。データ構造は、よりよいユーザエクスペ"
"リエンスのため、これらのセマンティクスに則る必要があります。\n"
"データを所有するデータ構造を実装する場合、そのデータへの借用のビューを提供す"
"ることで、よりフレキシブルなAPIを提供することが可能になります。"

#: src/idioms/deref.md:45
msgid ""
"Most methods can be implemented only for the borrowed view, they are then\n"
"implicitly available for the owning view."
msgstr ""
"ほとんどのメソッドが借用の型に対して実装可能です。それらメソッドが参照外しに"
"より、所有の型に対しても暗黙的に利用可能になります。"

#: src/idioms/deref.md:48
msgid "Gives clients a choice between borrowing or taking ownership of data."
msgstr ""
"データの借用を行うか、所有権を取るか、利用者が選択できるようにしましょう。"

#: src/idioms/deref.md:52
msgid ""
"Methods and traits only available via dereferencing are not taken into "
"account\n"
"when bounds checking, so generic programming with data structures using "
"this\n"
"pattern can get complex (see the `Borrow` and `AsRef` traits, etc.)."
msgstr ""
"参照外しを通してのみ利用可能なメソッドとトレイトは、境界チェックの際に考慮さ"
"れません。そのため、このパターンを使用したデータ構造でのジェネリックプログラ"
"ミングは複雑になる可能性があります (トレイト `Borrow` や `AsRef` など参照)。"

#: src/idioms/deref.md:56 src/idioms/dtor-finally.md:61
#: src/idioms/mem-replace.md:97 src/idioms/on-stack-dyn-dispatch.md:68
#: src/idioms/priv-extend.md:85 src/idioms/rustdoc-init.md:87
#: src/patterns/behavioural/command.md:203
#: src/patterns/behavioural/interpreter.md:103
#: src/patterns/behavioural/newtype.md:74 src/patterns/behavioural/RAII.md:83
#: src/patterns/behavioural/strategy.md:110
#: src/patterns/behavioural/visitor.md:79 src/patterns/creational/builder.md:81
#: src/patterns/creational/fold.md:85
#: src/patterns/structural/compose-structs.md:109
#: src/anti_patterns/deref.md:102
msgid "## Discussion"
msgstr "## 議論"

#: src/idioms/deref.md:58
msgid ""
"Smart pointers and collections are analogous: a smart pointer points to a "
"single\n"
"object, whereas a collection points to many objects. From the point of view "
"of\n"
"the type system, there is little difference between the two. A collection "
"owns\n"
"its data if the only way to access each datum is via the collection and the\n"
"collection is responsible for deleting the data (even in cases of shared\n"
"ownership, some kind of borrowed view may be appropriate). If a collection "
"owns\n"
"its data, it is usually useful to provide a view of the data as borrowed so "
"that\n"
"it can be referenced multiple times."
msgstr ""
"スマート・ポインタとコレクションは相似です。スマートポインタは単一のオブジェ"
"クトを指すのに対し、コレクションは多数のオブジェクトを指します。\n"
"型システムの観点からは、両者にほとんど違いはありません。\n"
"各データへのコレクション経由でのみアクセス可能なとき、コレクションはそれら"
"データを所有するとともに削除の責任を持ちます(所有権をを共有している場合でも、"
"一部の借用のビューでは当てはまります)。\n"
"コレクションがそのデータを所有する場合に、そのデータへの借用のビューを提供し"
"複数回参照可能にすることは、一般に有用です。"

#: src/idioms/deref.md:67
msgid ""
"Most smart pointers (e.g., `Foo<T>`) implement `Deref<Target=T>`. However,\n"
"collections will usually dereference to a custom type. `[T]` and `str` have "
"some\n"
"language support, but in the general case, this is not necessary. `Foo<T>` "
"can\n"
"implement `Deref<Target=Bar<T>>` where `Bar` is a dynamically sized type "
"and\n"
"`&Bar<T>` is a borrowed view of the data in `Foo<T>`."
msgstr ""
"ほとんどのスマートポインタ(例えば `Foo<T>`)は `Deref<Target=T>` を実装しま"
"す。\n"
"しかしコレクションは通常、カスタム型に参照外しされます。 `[T]`と `str` にはい"
"くつかの言語サポートがありますが、一般的なケースでは、その必要はありませ"
"ん。\n"
"`Foo<T>` が `Deref<Target=Bar<T>>` を実装することがあります。ここで `Bar` は"
"動的なサイズの型であり、`&Bar<T>` は `Foo<T>` のデータの借用のビューです。"

#: src/idioms/deref.md:73
msgid ""
"Commonly, ordered collections will implement `Index` for `Range`s to "
"provide\n"
"slicing syntax. The target will be the borrowed view."
msgstr ""
"一般的に、順序付きコレクションは `Range` に対して `Index` を実装し、スライス"
"構文を提供します。このターゲットは借用のビューになります。"

#: src/idioms/deref.md:78
msgid ""
"- [Deref polymorphism anti-pattern](../anti_patterns/deref.md).\n"
"- [Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."
msgstr ""
"- [Deref ポリモーフィズムのアンチパターン](../anti_patterns/deref.md).\n"
"- [`Deref` トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."

#: src/idioms/dtor-finally.md:1
msgid "# Finalisation in destructors"
msgstr "# デストラクタでのファイナライズ"

#: src/idioms/dtor-finally.md:5
msgid ""
"Rust does not provide the equivalent to `finally` blocks - code that will "
"be\n"
"executed no matter how a function is exited. Instead, an object's destructor "
"can\n"
"be used to run code that must be run before exit."
msgstr ""
"Rust には `finally` ブロック（関数の終了の仕方を問わずに実行されるコード）に"
"相当するものがありません。\n"
"その代わりに、オブジェクトのデストラクタを使用して、終了前に実行しなければな"
"らないコードを実行させることができます。"

#: src/idioms/dtor-finally.md:11
msgid ""
"```rust,ignore\n"
"fn bar() -> Result<(), ()> {\n"
"    // These don't need to be defined inside the function.\n"
"    struct Foo;\n"
"\n"
"    // Implement a destructor for Foo.\n"
"    impl Drop for Foo {\n"
"        fn drop(&mut self) {\n"
"            println!(\"exit\");\n"
"        }\n"
"    }\n"
"\n"
"    // The dtor of _exit will run however the function `bar` is exited.\n"
"    let _exit = Foo;\n"
"    // Implicit return with `?` operator.\n"
"    baz()?;\n"
"    // Normal return.\n"
"    Ok(())\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn bar() -> Result<(), ()> {\n"
"    // 関数内で定義する必要はありません。\n"
"    struct Foo;\n"
"\n"
"    // Fooのデストラクタを実装。\n"
"    impl Drop for Foo {\n"
"        fn drop(&mut self) {\n"
"            println!(\"exit\");\n"
"        }\n"
"    }\n"
"\n"
"    // _exit のデストラクタは `bar` の抜け方にかかわらず実行されます。\n"
"    let _exit = Foo;\n"
"    // `?` による暗黙的な return。\n"
"    baz()?;\n"
"    // 通常の return。\n"
"    Ok(())\n"
"}\n"
"```"

#: src/idioms/dtor-finally.md:34
msgid ""
"If a function has multiple return points, then executing code on exit "
"becomes\n"
"difficult and repetitive (and thus bug-prone). This is especially the case "
"where\n"
"return is implicit due to a macro. A common case is the `?` operator which\n"
"returns if the result is an `Err`, but continues if it is `Ok`. `?` is used "
"as\n"
"an exception handling mechanism, but unlike Java (which has `finally`), "
"there is\n"
"no way to schedule code to run in both the normal and exceptional cases.\n"
"Panicking will also exit a function early."
msgstr ""
"関数に複数のリターン・ポイントがある場合、関数終了時にコードを実行するのは難"
"しく、繰り返し的になり（またそれゆえにバグの原因になり）ます。特にreturnがマ"
"クロによって暗黙的に行われる場合です。\n"
"よくあるケースが `?` 演算子で、これは結果が `Err` なら戻り、`Ok` なら続行する"
"ものです。 `?` は例外処理のメカニズムとして使用されますすが、(`finally`を持"
"つ) Javaとは異なり、通常と例外の両方のケースで実行されるコードを実装する方法"
"はありません。\n"
"また、パニックが起きると関数は早期に終了します。"

#: src/idioms/dtor-finally.md:44
msgid ""
"Code in destructors will (nearly) always be run - copes with panics, early\n"
"returns, etc."
msgstr ""
"デストラクタ内のコードは（ほぼ）常に実行されます。パニックや早期returnなどに"
"も対処できます。"

#: src/idioms/dtor-finally.md:49
msgid ""
"It is not guaranteed that destructors will run. For example, if there is an\n"
"infinite loop in a function or if running a function crashes before exit.\n"
"Destructors are also not run in the case of a panic in an already panicking\n"
"thread. Therefore, destructors cannot be relied on as finalizers where it "
"is\n"
"absolutely essential that finalisation happens."
msgstr ""
"デストラクタの実行は保証されていません。\n"
"例えば関数の無限ループがある場合や、関数の実行が終了前にクラッシュした場合な"
"どです。\n"
"また、すでにパニックになっているスレッドでパニックが発生した場合にも、デスト"
"ラクタは実行されません。\n"
"したがって、絶対的かつ本質的にファイナライズを行うファイナライザとしては、デ"
"ストラクタを頼ることはできません。"

#: src/idioms/dtor-finally.md:55
msgid ""
"This pattern introduces some hard to notice, implicit code. Reading a "
"function\n"
"gives no clear indication of destructors to be run on exit. This can make\n"
"debugging tricky."
msgstr ""
"このパターンは、気づきにくい暗黙のコードを導入することになります。関数を読ん"
"でも、 終了時にデストラクタが実行されることについて、明らかな兆候が得られませ"
"ん。これはデバッグを厄介なものにする可能性があります。"

#: src/idioms/dtor-finally.md:59
msgid ""
"Requiring an object and `Drop` impl just for finalisation is heavy on "
"boilerplate."
msgstr ""
"ファイナライズのためだけにオブジェクトと `Drop` の実装が必要となり、ボイラー"
"テンプレートが多くなります。"

#: src/idioms/dtor-finally.md:63
msgid ""
"There is some subtlety about how exactly to store the object used as a\n"
"finalizer. It must be kept alive until the end of the function and must then "
"be\n"
"destroyed. The object must always be a value or uniquely owned pointer (e."
"g.,\n"
"`Box<Foo>`). If a shared pointer (such as `Rc`) is used, then the finalizer "
"can\n"
"be kept alive beyond the lifetime of the function. For similar reasons, the\n"
"finalizer should not be moved or returned."
msgstr ""
"ファイナライザとして使用されるオブジェクトの正確な格納方法については、繊細な"
"点があります。\n"
"このオブジェクトは関数が終了するまで存続しなければならず、また終了時に破棄さ"
"れなければなりません。\n"
"このオブジェクトは常に値か一意に所有されるポインタでなければなりません (例 "
"`Box<Foo>` など) 。もし共有ポインタ(`Rc`など)を使用した場合、ファイナライザが"
"関数のライフタイムを超えて存続してしまう可能性があります。\n"
"同様の理由でファイナライザの所有権を移動したり、ファイナライザを戻り値として"
"はいけません。"

#: src/idioms/dtor-finally.md:70
msgid ""
"The finalizer must be assigned into a variable, otherwise it will be "
"destroyed\n"
"immediately, rather than when it goes out of scope. The variable name must "
"start\n"
"with `_` if the variable is only used as a finalizer, otherwise the "
"compiler\n"
"will warn that the finalizer is never used. However, do not call the "
"variable\n"
"`_` with no suffix - in that case it will be destroyed immediately."
msgstr ""
"ファイナライザは変数に代入しなければなりません。そうでないとスコープを外れる"
"前に即座に破棄されます。\n"
"変数名は `_` で始まらなければなりません。そうでないとコンパイラは変数が利用さ"
"れていない旨の警告を出します。\n"
"しかし変数をサフィックスなしの `_` としてはいけません。そうすると、即座に破棄"
"されてしまいます。"

#: src/idioms/dtor-finally.md:76
msgid ""
"In Rust, destructors are run when an object goes out of scope. This happens\n"
"whether we reach the end of block, there is an early return, or the program\n"
"panics. When panicking, Rust unwinds the stack running destructors for each\n"
"object in each stack frame. So, destructors get called even if the panic "
"happens\n"
"in a function being called."
msgstr ""
"Rustでは、デストラクタはオブジェクトがスコープ外に出たときに実行されます。\n"
"これが起こるのは、ブロックの終了に到達したとき、早期returnのとき、パニックが"
"発生したときです。\n"
"パニックが起きると、Rustはスタックフレームの各オブジェクトのデストラクタを実"
"行しつつスタックを巻き戻します。\n"
"そのため、呼び出し中の関数内にてパニックが発生した場合でも、デストラクタが呼"
"び出されます。"

#: src/idioms/dtor-finally.md:82
msgid ""
"If a destructor panics while unwinding, there is no good action to take, so "
"Rust\n"
"aborts the thread immediately, without running further destructors. This "
"means\n"
"that destructors are not absolutely guaranteed to run. It also means that "
"you\n"
"must take extra care in your destructors not to panic, since it could leave\n"
"resources in an unexpected state."
msgstr ""
"デストラクタが巻き戻し中にパニックを起こした場合、取るべき良いアクションはあ"
"りません。\n"
"よってRustはそれ以上デストラクタを実行せずに、スレッドを即座に終了させま"
"す。\n"
"これは、デストラクタの実行が絶対に保証されているわけではないということを意味"
"します。\n"
"また、デストラクタがパニックに陥らないように細心の注意を払う必要があるという"
"ことでもあります。\n"
"リソースを想定されない状態にする可能性があるからです。"

#: src/idioms/dtor-finally.md:90
msgid "[RAII guards](../patterns/behavioural/RAII.md)."
msgstr "[RAIIガード](../patterns/behavioural/RAII.md)。"

#: src/idioms/mem-replace.md:1
msgid "# `mem::{take(_), replace(_)}` to keep owned values in changed enums"
msgstr "# `mem::{take(_), replace(_)}` による値を所有したままの列挙値の変換"

#: src/idioms/mem-replace.md:5
msgid ""
"Say we have a `&mut MyEnum` which has (at least) two variants,\n"
"`A { name: String, x: u8 }` and `B { name: String }`. Now we want to change\n"
"`MyEnum::A` to a `B` if `x` is zero, while keeping `MyEnum::B` intact."
msgstr ""
"`A { name: String, x: u8 }` と `B { name: String }` という(少なくとも) 2つの"
"バリアントを持つ `&mut MyEnum` があるとします。\n"
"`MyEnum::A` をその `x` が 0 の場合に `B` に変更したいとします。このとき "
"`MyEnum::B` に手を入れたくないとします。"

#: src/idioms/mem-replace.md:9
msgid "We can do this without cloning the `name`."
msgstr "`name` をクローンすることなく、これを実行できます。"

#: src/idioms/mem-replace.md:13
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MyEnum {\n"
"    A { name: String, x: u8 },\n"
"    B { name: String }\n"
"}\n"
"\n"
"fn a_to_b(e: &mut MyEnum) {\n"
"    if let MyEnum::A { name, x: 0 } = e {\n"
"        // this takes out our `name` and put in an empty String instead\n"
"        // (note that empty strings don't allocate).\n"
"        // Then, construct the new enum variant (which will\n"
"        // be assigned to `*e`).\n"
"        *e = MyEnum::B { name: mem::take(name) }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MyEnum {\n"
"    A { name: String, x: u8 },\n"
"    B { name: String }\n"
"}\n"
"\n"
"fn a_to_b(e: &mut MyEnum) {\n"
"    if let MyEnum::A { name, x: 0 } = e {\n"
"        // これは `name` を取り出し、その代わりに空文字列を置きます。\n"
"        // (空文字列はメモリが割り当てが発生しないことに注意)\n"
"        // そして、新しい列挙型のバリアントを作成します( `*e` に代入しま"
"す)。\n"
"        *e = MyEnum::B { name: mem::take(name) }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/mem-replace.md:32
msgid "This also works with more variants:"
msgstr "より多くのバリアントでも同様です："

#: src/idioms/mem-replace.md:34
msgid ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MultiVariateEnum {\n"
"    A { name: String },\n"
"    B { name: String },\n"
"    C,\n"
"    D\n"
"}\n"
"\n"
"fn swizzle(e: &mut MultiVariateEnum) {\n"
"    use MultiVariateEnum::*;\n"
"    *e = match e {\n"
"        // Ownership rules do not allow taking `name` by value, but we "
"cannot\n"
"        // take the value out of a mutable reference, unless we replace it:\n"
"        A { name } => B { name: mem::take(name) },\n"
"        B { name } => A { name: mem::take(name) },\n"
"        C => D,\n"
"        D => C\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::mem;\n"
"\n"
"enum MultiVariateEnum {\n"
"    A { name: String },\n"
"    B { name: String },\n"
"    C,\n"
"    D\n"
"}\n"
"\n"
"fn swizzle(e: &mut MultiVariateEnum) {\n"
"    use MultiVariateEnum::*;\n"
"    *e = match e {\n"
"        // 所有権のルールは `name` を値として取り出すことを禁じているため、\n"
"        // 置き換える形以外では、可変参照の外へ値を取り出せない。\n"
"        A { name } => B { name: mem::take(name) },\n"
"        B { name } => A { name: mem::take(name) },\n"
"        C => D,\n"
"        D => C\n"
"    }\n"
"}\n"
"```"

#: src/idioms/mem-replace.md:59
msgid ""
"When working with enums, we may want to change an enum value in place, "
"perhaps\n"
"to another variant. This is usually done in two phases to keep the borrow\n"
"checker happy. In the first phase, we observe the existing value and look "
"at\n"
"its parts to decide what to do next. In the second phase we may "
"conditionally\n"
"change the value (as in the example above)."
msgstr ""
"列挙型を扱うとき、ある列挙型の値を別のバリアントに置き換えたいことがありま"
"す。\n"
"通常これは、借用チェッカーを満足させるために、二段階に分けて行われます。\n"
"第一段階では、既存の値を参照し、その一部を見て次の処理を決めます。\n"
"第二段階では、(上の例のように) 条件付きで値を変更することができます。"

#: src/idioms/mem-replace.md:65
msgid ""
"The borrow checker won't allow us to take out `name` of the enum (because\n"
"_something_ must be there.) We could of course `.clone()` name and put the "
"clone\n"
"into our `MyEnum::B`, but that would be an instance of the [Clone to satisfy "
"the borrow checker](../anti_patterns/borrow_clone.md) anti-pattern. Anyway, "
"we\n"
"can avoid the extra allocation by changing `e` with only a mutable borrow."
msgstr ""
"借用チェッカーは列挙型の `name` を取り出すことを許可しません (そこに _何か_ "
"がなければならないため)。\n"
"もちろん、 `name` を `.clone()` して、そのクローンを `MyEnum::B` に入れること"
"はできますが、\n"
"それは [借用チェッカーを満足させるためのClone](../anti_patterns/borrow_clone."
"md) アンチパターンのインスタンスになってしまいます。\n"
"いずれにせよ、 可変借用のみ使用し ‘e‘ を変更することで余分なアロケーションを"
"避けることができます。"

#: src/idioms/mem-replace.md:70
msgid ""
"`mem::take` lets us swap out the value, replacing it with it's default "
"value,\n"
"and returning the previous value. For `String`, the default value is an "
"empty\n"
"`String`, which does not need to allocate. As a result, we get the original\n"
"`name` _as an owned value_. We can then wrap this in another enum."
msgstr ""
"`mem::take` は、値をそのデフォルト値に置き換えるとともに、元の値を返します。"
"これにより値を入れ替える形で取り出せます。\n"
"`String`の場合、デフォルト値は空の `String` であり、アロケートの必要がありま"
"せん。\n"
"結果として、元の `name` を _所有した値として_ 取得できます。そしてこれを別の"
"列挙型にラップすることができます。"

#: src/idioms/mem-replace.md:75
msgid ""
"**NOTE:** `mem::replace` is very similar, but allows us to specify what to\n"
"replace the value with. An equivalent to our `mem::take` line would be\n"
"`mem::replace(name, String::new())`."
msgstr ""
"**NOTE:** `mem::replace` は非常に似ていますが、値を何に置き換えるかを指定でき"
"ます。\n"
"例示の `mem::take` は `mem::replace(name, String::new())` に相当します。"

#: src/idioms/mem-replace.md:79
msgid ""
"Note, however, that if we are using an `Option` and want to replace its\n"
"value with a `None`, `Option`’s `take()` method provides a shorter and\n"
"more idiomatic alternative."
msgstr ""
"ただし `Option` を使用していてその値を `None` に置き換えたい状況では、 "
"`Option` の `take()` メソッドを使用することがより短くイディオム的な代替手段で"
"あること注意してください。"

# インディージョーンズが何かトラップを回避するために宝物的なモノを置き換えることをイメージしている？
#: src/idioms/mem-replace.md:85
msgid ""
"Look ma, no allocation! Also you may feel like Indiana Jones while doing it."
msgstr ""
"アロケーションが発生しません！インディ・ジョーンズがそうするような気分になれ"
"るかもしれません。"

#: src/idioms/mem-replace.md:89
msgid ""
"This gets a bit wordy. Getting it wrong repeatedly will make you hate the\n"
"borrow checker. The compiler may fail to optimize away the double store,\n"
"resulting in reduced performance as opposed to what you'd do in unsafe\n"
"languages."
msgstr ""
"少しくどい表現になります。\n"
"何度も間違えると借用チェッカーが憎くなるかもしれません。\n"
"コンパイラはダブルストアの最適化に失敗するかもしれません、\n"
"その結果、 unsafe で行うのとは対照的に、パフォーマンスが低下します。"

#: src/idioms/mem-replace.md:94
msgid ""
"Furthermore, the type you are taking needs to implement the [`Default` trait]"
"(./default.md). However, if the type you're working with doesn't\n"
"implement this, you can instead use `mem::replace`."
msgstr ""
"さらに、扱う型は [`Default` trait](./default.md) を実装している必要がありま"
"す。\n"
"もし実装していない場合は、代わりに `mem::replace` を使用することができます。"

#: src/idioms/mem-replace.md:99
msgid ""
"This pattern is only of interest in Rust. In GC'd languages, you'd take the\n"
"reference to the value by default (and the GC would keep track of refs), and "
"in\n"
"other low-level languages like C you'd simply alias the pointer and fix "
"things\n"
"later."
msgstr ""
"このパターンが注目されるのはRustだけです。\n"
"GCのある言語では、デフォルトで値への参照を取ります（そしてGCは参照を追跡しま"
"す）。\n"
"Cのような低レベル言語では、単にポインタをエイリアスして後から修正します。"

#: src/idioms/mem-replace.md:104
msgid ""
"However, in Rust, we have to do a little more work to do this. An owned "
"value\n"
"may only have one owner, so to take it out, we need to put something back in "
"–\n"
"like Indiana Jones, replacing the artifact with a bag of sand."
msgstr ""
"しかしRustでは、これを行うにはもう少し工夫が必要です。\n"
"所有された値には所有者が1人しかいないので、それを取り出すには、何かを戻す必要"
"があります。\n"
"インディ・ジョーンズのように、アーティファクトを砂袋に置き換えるのです。"

#: src/idioms/mem-replace.md:110
msgid ""
"This gets rid of the [Clone to satisfy the borrow checker](../anti_patterns/"
"borrow_clone.md)\n"
"anti-pattern in a specific case."
msgstr ""
"これは [借用チェッカーを満足させるためのClone](../anti_patterns/borrow_clone."
"md) アンチパターンを特定のケースで取り除くものです。"

#: src/idioms/on-stack-dyn-dispatch.md:1
msgid "# On-Stack Dynamic Dispatch"
msgstr "# オンスタックの動的ディスパッチ"

#: src/idioms/on-stack-dyn-dispatch.md:5
msgid ""
"We can dynamically dispatch over multiple values, however, to do so, we "
"need\n"
"to declare multiple variables to bind differently-typed objects. To extend "
"the\n"
"lifetime as necessary, we can use deferred conditional initialization, as "
"seen\n"
"below:"
msgstr ""
"複数の値を動的にディスパッチすることは可能ですが、\n"
"そうするためには、異なる型のオブジェクトに束縛するため複数の変数を宣言する必"
"要があります。\n"
"ライフタイムを必要に応じて延長するために、遅延条件付き初期化を使うことができ"
"ます："

#: src/idioms/on-stack-dyn-dispatch.md:12
msgid ""
"```rust\n"
"use std::io;\n"
"use std::fs;\n"
"\n"
"# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"# let arg = \"-\";\n"
"\n"
"// These must live longer than `readable`, and thus are declared first:\n"
"let (mut stdin_read, mut file_read);\n"
"\n"
"// We need to ascribe the type to get dynamic dispatch.\n"
"let readable: &mut dyn io::Read = if arg == \"-\" {\n"
"    stdin_read = io::stdin();\n"
"    &mut stdin_read\n"
"} else {\n"
"    file_read = fs::File::open(arg)?;\n"
"    &mut file_read\n"
"};\n"
"\n"
"// Read from `readable` here.\n"
"\n"
"# Ok(())\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"use std::io;\n"
"use std::fs;\n"
"\n"
"# fn main() -> Result<(), Box<dyn std::error::Error>> {\n"
"# let arg = \"-\";\n"
"\n"
"// These must live longer than `readable`, and thus are declared first:\n"
"// これらは `readable` よりも長く存在しなければならないので、最初に宣言しま"
"す：\n"
"let (mut stdin_read, mut file_read);\n"
"\n"
"// We need to ascribe the type to get dynamic dispatch.\n"
"// 動的なディスパッチを行うために、ディスパッチ先の型を指定する必要がありま"
"す。\n"
"let readable: &mut dyn io::Read = if arg == \"-\" {\n"
"    stdin_read = io::stdin();\n"
"    &mut stdin_read\n"
"} else {\n"
"    file_read = fs::File::open(arg)?;\n"
"    &mut file_read\n"
"};\n"
"\n"
"// ここで `readable` から読み出し。\n"
"\n"
"# Ok(())\n"
"# }\n"
"```"

#: src/idioms/on-stack-dyn-dispatch.md:39
msgid ""
"Rust monomorphises code by default. This means a copy of the code will be\n"
"generated for each type it is used with and optimized independently. While "
"this\n"
"allows for very fast code on the hot path, it also bloats the code in "
"places\n"
"where performance is not of the essence, thus costing compile time and "
"cache\n"
"usage."
msgstr ""
"Rustはデフォルトでコードを単相化します。これは、使用する型毎にコードのコピー"
"が生成され、別個に最適化されることを意味します。\n"
"これはホットパスにおける非常に高速なコードを実現しますが、\n"
"パフォーマンスが重要でない場所においてコードが肥大化することにもなります。そ"
"の結果コンパイル時間やキャッシュの使用量が犠牲になります。"

#: src/idioms/on-stack-dyn-dispatch.md:45
msgid ""
"Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly "
"ask\n"
"for it."
msgstr ""
"幸いなことに、Rustでは動的ディスパッチが使えますが、明示的に要求する必要があ"
"ります。"

#: src/idioms/on-stack-dyn-dispatch.md:50
msgid ""
"We do not need to allocate anything on the heap. Neither do we need to\n"
"initialize something we won't use later, nor do we need to monomorphize the\n"
"whole code that follows to work with both `File` or `Stdin`."
msgstr ""
"ヒープ上に何もアロケートする必要がありません。\n"
"後で使わないものを初期化する必要もなく、 `File` と `Stdin` の両方で動作するよ"
"うに、続くコード全体を単相化する必要もありません。"

#: src/idioms/on-stack-dyn-dispatch.md:56
msgid "The code needs more moving parts than the `Box`-based version:"
msgstr "このコードは、 `Box` ベースのバージョンよりも多くの変動部があります："

#: src/idioms/on-stack-dyn-dispatch.md:58
msgid ""
"```rust,ignore\n"
"// We still need to ascribe the type for dynamic dispatch.\n"
"let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
"    Box::new(io::stdin())\n"
"} else {\n"
"    Box::new(fs::File::open(arg)?)\n"
"};\n"
"// Read from `readable` here.\n"
"```"
msgstr ""
"```rust,ignore\n"
"// We still need to ascribe the type for dynamic dispatch.\n"
"// この場合でも、動的なディスパッチを行うために、ディスパッチ先の型を指定する"
"必要があります。\n"
"let readable: Box<dyn io::Read> = if arg == \"-\" {\n"
"    Box::new(io::stdin())\n"
"} else {\n"
"    Box::new(fs::File::open(arg)?)\n"
"};\n"
"// ここで `readable` から読み出し。\n"
"```"

#: src/idioms/on-stack-dyn-dispatch.md:70
msgid ""
"Rust newcomers will usually learn that Rust requires all variables to be\n"
"initialized _before use_, so it's easy to overlook the fact that _unused_\n"
"variables may well be uninitialized. Rust works quite hard to ensure that "
"this\n"
"works out fine and only the initialized values are dropped at the end of "
"their\n"
"scope."
msgstr ""
"Rustの初心者は通常、Rustはすべての変数を _使用前に_ 初期化する必要があること"
"を学びます。\n"
"そのため、 _未使用_ 変数が初期化されていないという事実を見落としがちです。\n"
"変数が初期化されていないという事実を見落としがちです。\n"
"Rust は、これが問題なく動作するよう相当な努力を払って保証しており、スコープの"
"最後には初期化済みの値のみがdropされます。"

#: src/idioms/on-stack-dyn-dispatch.md:76
msgid "The example meets all the constraints Rust places on us:"
msgstr "この例は、Rust が私たちに課しているすべての制約を満たしています："

#: src/idioms/on-stack-dyn-dispatch.md:78
msgid ""
"- All variables are initialized before using (in this case borrowing) them\n"
"- Each variable only holds values of a single type. In our example, `stdin` "
"is\n"
"  of type `Stdin`, `file` is of type `File` and `readable` is of type `&mut "
"dyn Read`\n"
"- Each borrowed value outlives all the references borrowed from it"
msgstr ""
"- すべての変数は、使用する（この場合は借用される）前に初期化されます。\n"
"- 各変数は単一の型の値のみを保持します。\n"
"  この例では、 `stdin_read` は `Stdin` 型、`file_read` は `File` 型、"
"`readable` は `&mut dyn Read` 型です。\n"
"- 借用された各値は、それから借用されたすべての参照よりも長生きします。"

#: src/idioms/on-stack-dyn-dispatch.md:85
msgid ""
"- [Finalisation in destructors](dtor-finally.md) and\n"
"  [RAII guards](../patterns/behavioural/RAII.md) can benefit from tight "
"control over\n"
"  lifetimes.\n"
"- For conditionally filled `Option<&T>`s of (mutable) references, one can\n"
"  initialize an `Option<T>` directly and use its [`.as_ref()`] method to get "
"an\n"
"  optional reference."
msgstr ""
"- [デストラクタでのファイナライズ](dtor-finally.md) と\n"
"  [RAIIガード](../patterns/behavioural/RAII.md)は、ライフタイムの厳密な制御か"
"ら恩恵を得ます。\n"
"- 条件により中身が決まる参照 (可変のもの含む) の `Option<&T>` などに対して"
"は、次のようにします。\n"
"  `Option<T>` を直接初期化し、その [`.as_ref()`] メソッドを使用することで"
"Optionにくるまれた参照を取得できます。"

#: src/idioms/ffi/intro.md:1
msgid "# FFI Idioms"
msgstr "# FFIのイディオム"

#: src/idioms/ffi/intro.md:3
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid\n"
"traps for inexperienced users of `unsafe` Rust."
msgstr ""
"FFIコードを書くことは、それ自体が1つの課程です。\n"
"しかしながら、ポインタの役割を担い、`unsafe` Rustの経験の浅いユーザーが陥る罠"
"を回避する、いくつかのイディオムがあります。"

#: src/idioms/ffi/intro.md:7
msgid "This section contains idioms that may be useful when doing FFI."
msgstr "このセクションでは、FFIを行う際に役立つイディオムを紹介します。"

# タイトル名は要見直し。目次見直しの時でもいいが・・・
#: src/idioms/ffi/intro.md:9
msgid ""
"1. [Idiomatic Errors](./errors.md) - Error handling with integer codes and\n"
"   sentinel return values (such as `NULL` pointers)\n"
"\n"
"2. [Accepting Strings](./accepting-strings.md) with minimal unsafe code\n"
"\n"
"3. [Passing Strings](./passing-strings.md) to FFI functions"
msgstr ""
"1. [慣習的なエラー](./errors.md) - 整数コードと番人戻り値（`NULL`ポインタな"
"ど）によるエラー処理\n"
"\n"
"2. 最小の `unsafe` コードでの [文字列の受け入れ](./accepting-strings.md) \n"
"\n"
"3. FFI関数への[文字列の受け渡し](./passing-strings.md)"

#: src/idioms/ffi/errors.md:1
msgid "# Error Handling in FFI"
msgstr "# FFI のエラー処理"

#: src/idioms/ffi/errors.md:5
msgid ""
"In foreign languages like C, errors are represented by return codes.\n"
"However, Rust's type system allows much more rich error information to be\n"
"captured and propogated through a full type."
msgstr ""
"C言語のような言語では、エラーはリターンコードで表されます。\n"
"しかしRustの型システムは、よりリッチなエラー情報を完全な型を通して捕捉、伝播"
"することが可能です。"

#: src/idioms/ffi/errors.md:9
msgid ""
"This best practice shows different kinds of error codes, and how to expose "
"them\n"
"in a usable way:"
msgstr ""
"このベストプラクティスでは、さまざまな種類のエラーコードを示し、どのようにそ"
"れらを扱いやすい方法で公開するかを示します："

#: src/idioms/ffi/errors.md:12
msgid ""
"1. Flat Enums should be converted to integers and returned as codes.\n"
"2. Structured Enums should be converted to an integer code with a string "
"error\n"
"   message for detail.\n"
"3. Custom Error Types should become \"transparent\", with a C representation."
msgstr ""
"1. フラットな Enum は整数に変換してコードとして返す必要があります。\n"
"2. 構造化された Enum は、詳細の文字列のエラーメッセージとともに整数コードに変"
"換されるべきです。\n"
"3. カスタムエラー型は、C言語表現に \"透過的 \" にするべきです。"

#: src/idioms/ffi/errors.md:17 src/idioms/ffi/accepting-strings.md:29
#: src/idioms/ffi/passing-strings.md:26 src/patterns/ffi/export.md:40
#: src/patterns/ffi/wrappers.md:23
msgid "## Code Example"
msgstr "## コード例"

#: src/idioms/ffi/errors.md:19
msgid "### Flat Enums"
msgstr "### フラットな Enum"

#: src/idioms/ffi/errors.md:21
msgid ""
"```rust,ignore\n"
"enum DatabaseError {\n"
"    IsReadOnly = 1, // user attempted a write operation\n"
"    IOError = 2, // user should read the C errno() for what it was\n"
"    FileCorrupted = 3, // user should run a repair tool to recover it\n"
"}\n"
"\n"
"impl From<DatabaseError> for libc::c_int {\n"
"    fn from(e: DatabaseError) -> libc::c_int {\n"
"        (e as i8).into()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"enum DatabaseError {\n"
"    IsReadOnly = 1, // ユーザが書き込みを試行しました。\n"
"    IOError = 2, // ユーザは C の error() を読み、何があったか確認するべきで"
"す。\n"
"    FileCorrupted = 3, // ユーザは復旧するために修復ツールを実行する必要があ"
"ります。\n"
"}\n"
"\n"
"impl From<DatabaseError> for libc::c_int {\n"
"    fn from(e: DatabaseError) -> libc::c_int {\n"
"        (e as i8).into()\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:35
msgid "### Structured Enums"
msgstr "### 構造化された Enum"

#: src/idioms/ffi/errors.md:37
msgid ""
"```rust,ignore\n"
"pub mod errors {\n"
"    enum DatabaseError {\n"
"        IsReadOnly,\n"
"        IOError(std::io::Error),\n"
"        FileCorrupted(String), // message describing the issue\n"
"    }\n"
"\n"
"    impl From<DatabaseError> for libc::c_int {\n"
"        fn from(e: DatabaseError) -> libc::c_int {\n"
"            match e {\n"
"                DatabaseError::IsReadOnly => 1,\n"
"                DatabaseError::IOError(_) => 2,\n"
"                DatabaseError::FileCorrupted(_) => 3,\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub mod c_api {\n"
"    use super::errors::DatabaseError;\n"
"\n"
"    #[no_mangle]\n"
"    pub extern \"C\" fn db_error_description(\n"
"        e: *const DatabaseError\n"
"        ) -> *mut libc::c_char {\n"
"\n"
"        let error: &DatabaseError = unsafe {\n"
"            // SAFETY: pointer lifetime is greater than the current stack "
"frame\n"
"            &*e\n"
"        };\n"
"\n"
"        let error_str: String = match error {\n"
"            DatabaseError::IsReadOnly => {\n"
"                format!(\"cannot write to read-only database\");\n"
"            }\n"
"            DatabaseError::IOError(e) => {\n"
"                format!(\"I/O Error: {}\", e);\n"
"            }\n"
"            DatabaseError::FileCorrupted(s) => {\n"
"                format!(\"File corrupted, run repair: {}\", &s);\n"
"            }\n"
"        };\n"
"\n"
"        let c_error = unsafe {\n"
"            // SAFETY: copying error_str to an allocated buffer with a NUL\n"
"            // character at the end\n"
"            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as "
"*mut _;\n"
"\n"
"            if malloc.is_null() {\n"
"                return std::ptr::null_mut();\n"
"            }\n"
"\n"
"            let src = error_str.as_bytes().as_ptr();\n"
"\n"
"            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
"\n"
"            std::ptr::write(malloc.add(error_str.len()), 0);\n"
"\n"
"            malloc as *mut libc::c_char\n"
"        };\n"
"\n"
"        c_error\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod errors {\n"
"    enum DatabaseError {\n"
"        IsReadOnly,\n"
"        IOError(std::io::Error),\n"
"        FileCorrupted(String), // 問題を説明するメッセージ\n"
"    }\n"
"\n"
"    impl From<DatabaseError> for libc::c_int {\n"
"        fn from(e: DatabaseError) -> libc::c_int {\n"
"            match e {\n"
"                DatabaseError::IsReadOnly => 1,\n"
"                DatabaseError::IOError(_) => 2,\n"
"                DatabaseError::FileCorrupted(_) => 3,\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub mod c_api {\n"
"    use super::errors::DatabaseError;\n"
"\n"
"    #[no_mangle]\n"
"    pub extern \"C\" fn db_error_description(\n"
"        e: *const DatabaseError\n"
"        ) -> *mut libc::c_char {\n"
"\n"
"        let error: &DatabaseError = unsafe {\n"
"            // SAFETY: ポインタの寿命が現在のスタックフレームより長い\n"
"            &*e\n"
"        };\n"
"\n"
"        let error_str: String = match error {\n"
"            DatabaseError::IsReadOnly => {\n"
"                format!(\"cannot write to read-only database\");\n"
"            }\n"
"            DatabaseError::IOError(e) => {\n"
"                format!(\"I/O Error: {}\", e);\n"
"            }\n"
"            DatabaseError::FileCorrupted(s) => {\n"
"                format!(\"File corrupted, run repair: {}\", &s);\n"
"            }\n"
"        };\n"
"\n"
"        let c_error = unsafe {\n"
"            // SAFETY: error_str をNUL終端されたアロケートされたバッファにコ"
"ピーします。\n"
"            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as "
"*mut _;\n"
"\n"
"            if malloc.is_null() {\n"
"                return std::ptr::null_mut();\n"
"            }\n"
"\n"
"            let src = error_str.as_bytes().as_ptr();\n"
"\n"
"            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());\n"
"\n"
"            std::ptr::write(malloc.add(error_str.len()), 0);\n"
"\n"
"            malloc as *mut libc::c_char\n"
"        };\n"
"\n"
"        c_error\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:104
msgid "### Custom Error Types"
msgstr "### カスタムエラー型"

#: src/idioms/ffi/errors.md:106
msgid ""
"```rust,ignore\n"
"struct ParseError {\n"
"    expected: char,\n"
"    line: u32,\n"
"    ch: u16\n"
"}\n"
"\n"
"impl ParseError { /* ... */ }\n"
"\n"
"/* Create a second version which is exposed as a C structure */\n"
"#[repr(C)]\n"
"pub struct parse_error {\n"
"    pub expected: libc::c_char,\n"
"    pub line: u32,\n"
"    pub ch: u16\n"
"}\n"
"\n"
"impl From<ParseError> for parse_error {\n"
"    fn from(e: ParseError) -> parse_error {\n"
"        let ParseError { expected, line, ch } = e;\n"
"        parse_error { expected, line, ch }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct ParseError {\n"
"    expected: char,\n"
"    line: u32,\n"
"    ch: u16\n"
"}\n"
"\n"
"impl ParseError { /* ... */ }\n"
"\n"
"/* Cの構造体として公開する2つ目のバージョンを作成 */\n"
"#[repr(C)]\n"
"pub struct parse_error {\n"
"    pub expected: libc::c_char,\n"
"    pub line: u32,\n"
"    pub ch: u16\n"
"}\n"
"\n"
"impl From<ParseError> for parse_error {\n"
"    fn from(e: ParseError) -> parse_error {\n"
"        let ParseError { expected, line, ch } = e;\n"
"        parse_error { expected, line, ch }\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/errors.md:133
msgid ""
"This ensures that the foreign language has clear access to error "
"information\n"
"while not compromising the Rust code's API at all."
msgstr ""
"これにより、RustコードのAPIをまったく損なうことなく、他言語でもエラー情報にア"
"クセスできるようになります。"

#: src/idioms/ffi/errors.md:138
msgid ""
"It's a lot of typing, and some types may not be able to be converted easily\n"
"to C."
msgstr "タイピングが多くなります。またC言語に簡単に変換できない型もあります。"

#: src/idioms/ffi/accepting-strings.md:1
msgid "# Accepting Strings"
msgstr "# 文字列の受け入れ"

#: src/idioms/ffi/accepting-strings.md:5
msgid ""
"When accepting strings via FFI through pointers, there are two principles "
"that\n"
"should be followed:"
msgstr ""
"FFIから文字列をポインタを通して受け取る場合、次の2つの原則に従う必要がありま"
"す："

#: src/idioms/ffi/accepting-strings.md:8
msgid ""
"1. Keep foreign strings \"borrowed\", rather than copying them directly.\n"
"2. Minimize the amount of complexity and `unsafe` code involved in "
"converting\n"
"   from a C-style string to native Rust strings."
msgstr ""
"1. 外部からの文字列を直接コピーするのではなく、「借用」しておいてください。\n"
"2. Cスタイルの文字列から Rust ネイティブの文字列への変換に伴う複雑さと"
"`unsafe` コードの量を最小限にしてください。"

#: src/idioms/ffi/accepting-strings.md:14
msgid ""
"The strings used in C have different behaviours to those used in Rust, "
"namely:"
msgstr ""
"C言語で使用される文字列は、Rustで使用される文字列とは振る舞いが異なります。即"
"ち："

#: src/idioms/ffi/accepting-strings.md:16
msgid ""
"- C strings are null-terminated while Rust strings store their length\n"
"- C strings can contain any arbitrary non-zero byte while Rust strings must "
"be\n"
"  UTF-8\n"
"- C strings are accessed and manipulated using `unsafe` pointer operations\n"
"  while interactions with Rust strings go through safe methods"
msgstr ""
"- C言語の文字列はヌル終端であるのに対し、Rustの文字列は長さを保存します。\n"
"- C言語の文字列は0以外の任意のバイトを含むことができますが、Rust の文字列は "
"UTF-8 でなければなりません。\n"
"- C の文字列は `unsafe` ポインタ操作を使ってアクセスおよび操作されます。\n"
"  一方、Rust の文字列とのやり取りは安全なメソッドを使用します。"

#: src/idioms/ffi/accepting-strings.md:22
msgid ""
"The Rust standard library comes with C equivalents of Rust's `String` and "
"`&str`\n"
"called `CString` and `&CStr`, that allow us to avoid a lot of the "
"complexity\n"
"and `unsafe` code involved in converting between C strings and Rust strings."
msgstr ""
"Rustの標準ライブラリには、Rustの `String` と `&str` に相当するC言語の文字列版"
"が用意されており、 `CString` と `&CStr` と呼びます。これらにより C言語の文字"
"列と Rust の文字列の変換にかかわる複雑さの大部分と `unsafe` なコードを避ける"
"ことができます。"

#: src/idioms/ffi/accepting-strings.md:26
msgid ""
"The `&CStr` type also allows us to work with borrowed data, meaning passing\n"
"strings between Rust and C is a zero-cost operation."
msgstr ""
"また、 `&CStr` 型は、借用データを扱うことを可能とします。\n"
"これは Rust とC言語の間での文字列の受け渡しがゼロコストで行えるということで"
"す。"

#: src/idioms/ffi/accepting-strings.md:31
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    /// Log a message at the specified level.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// It is the caller's guarantee to ensure `msg`:\n"
"    ///\n"
"    /// - is not a null pointer\n"
"    /// - points to valid, initialized data\n"
"    /// - points to memory ending in a null byte\n"
"    /// - won't be mutated for the duration of this function call\n"
"    #[no_mangle]\n"
"    pub unsafe extern \"C\" fn mylib_log(\n"
"        msg: *const libc::c_char,\n"
"        level: libc::c_int\n"
"    ) {\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        // SAFETY: The caller has already guaranteed this is okay (see the\n"
"        // `# Safety` section of the doc-comment).\n"
"        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() {\n"
"            Ok(s) => s,\n"
"            Err(e) => {\n"
"                crate::log_error(\"FFI string conversion failed\");\n"
"                return;\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // モジュールのその他の内容・・・\n"
"\n"
"    /// 指定されたレベルのメッセージをログに記録します。\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// `msg` について次のことを保証するのは呼び出し側です :\n"
"    ///\n"
"    /// - nullポインタでない\n"
"    /// - 有効かつ初期化済みのデータを指す\n"
"    /// - null バイトで終端されたメモリを指す\n"
"    /// - この関数呼び出し中変更されない\n"
"    #[no_mangle]\n"
"    pub unsafe extern \"C\" fn mylib_log(\n"
"        msg: *const libc::c_char,\n"
"        level: libc::c_int\n"
"    ) {\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        // SAFETY: 呼び出し元はこれが問題ないことを既に保証しています\n"
"        // ( docコメントの `# Safety` を参照 )\n"
"        let msg_str: &str = match std::ffi::CStr::from_ptr(msg).to_str() {\n"
"            Ok(s) => s,\n"
"            Err(e) => {\n"
"                crate::log_error(\"FFI string conversion failed\");\n"
"                return;\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(msg_str, level);\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/accepting-strings.md:70
msgid "The example is is written to ensure that:"
msgstr "この例は、以下のことを確実にするために書かれています："

#: src/idioms/ffi/accepting-strings.md:72
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The pointer with an \"untracked\" lifetime becomes a \"tracked\" shared\n"
"   reference"
msgstr ""
"1. `unsafe`ブロックを可能な限り小さくします。\n"
"2. 「追跡されない」ライフタイムのポインタを「追跡される」共有参照にします。"

#: src/idioms/ffi/accepting-strings.md:76
msgid "Consider an alternative, where the string is actually copied:"
msgstr "別の方法として、文字列を実際にコピーする方法を考えてみましょう："

#: src/idioms/ffi/accepting-strings.md:78
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
"c_int) {\n"
"        // DO NOT USE THIS CODE.\n"
"        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.\n"
"\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */\n"
"            libc::strlen(msg)\n"
"        };\n"
"\n"
"        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
"\n"
"        let msg_cstr: std::ffi::CString = unsafe {\n"
"            // SAFETY: copying from a foreign pointer expected to live\n"
"            // for the entire stack frame into owned memory\n"
"            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);\n"
"\n"
"            msg_data.set_len(msg_len + 1);\n"
"\n"
"            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
"        }\n"
"\n"
"        let msg_str: String = unsafe {\n"
"            match msg_cstr.into_string() {\n"
"                Ok(s) => s,\n"
"                Err(e) => {\n"
"                    crate::log_error(\"FFI string conversion failed\");\n"
"                    return;\n"
"                }\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(&msg_str, level);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // モジュールのその他の内容・・・\n"
"\n"
"    pub extern \"C\" fn mylib_log(msg: *const libc::c_char, level: libc::"
"c_int) {\n"
"        // このコードは使用しないでください！\n"
"        // このコードは醜く、冗長で、微妙なバグを含んでいます！\n"
"\n"
"        let level: crate::LogLevel = match level { /* ... */ };\n"
"\n"
"        let msg_len = unsafe { /* SAFETY: strlen って何だろう？ */\n"
"            libc::strlen(msg)\n"
"        };\n"
"\n"
"        let mut msg_data = Vec::with_capacity(msg_len + 1);\n"
"\n"
"        let msg_cstr: std::ffi::CString = unsafe {\n"
"            // SAFETY: スタックフレーム全体が生存していると期待される外部のポ"
"インタから、所有メモリへコピー。\n"
"            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);\n"
"\n"
"            msg_data.set_len(msg_len + 1);\n"
"\n"
"            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()\n"
"        }\n"
"\n"
"        let msg_str: String = unsafe {\n"
"            match msg_cstr.into_string() {\n"
"                Ok(s) => s,\n"
"                Err(e) => {\n"
"                    crate::log_error(\"FFI string conversion failed\");\n"
"                    return;\n"
"                }\n"
"            }\n"
"        };\n"
"\n"
"        crate::log(&msg_str, level);\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/accepting-strings.md:120
msgid "This code in inferior to the original in two respects:"
msgstr "このコードは2つの点でオリジナルより劣っています："

#: src/idioms/ffi/accepting-strings.md:122
msgid ""
"1. There is much more `unsafe` code, and more importantly, more invariants "
"it\n"
"   must uphold.\n"
"2. Due to the extensive arithmetic required, there is a bug in this version\n"
"   that cases Rust `undefined behaviour`."
msgstr ""
"1. より多くの `unsafe` コードがあり、より重要なことは、そのコードが守らなけれ"
"ばならない不変性がより多いということです。\n"
"2. 広範な演算が必要なため、このバージョンには Rust の `undefined behavior` を"
"引き起こすバグがあります。"

#: src/idioms/ffi/accepting-strings.md:127
msgid ""
"The bug here is a simple mistake in pointer arithmetic: the string was "
"copied,\n"
"all `msg_len` bytes of it. However, the `NUL` terminator at the end was not."
msgstr ""
"このバグはポインタ演算の単純なミスです：文字列は `msg_len` バイトすべてをコ"
"ピーされましたが、末尾の `NUL` 終端がコピーされませんでした。"

#: src/idioms/ffi/accepting-strings.md:130
msgid ""
"The Vector then had its size _set_ to the length of the _zero padded string_ "
"--\n"
"rather than _resized_ to it, which could have added a zero at the end.\n"
"As a result, the last byte in the Vector is uninitialized memory.\n"
"When the `CString` is created at the bottom of the block, its read of the\n"
"Vector will cause `undefined behaviour`!"
msgstr ""
"ベクタのサイズは、 _ゼロパディングされた文字列_ の長さに _設定_ されています "
"--\n"
"終端に 0 を追加できるよう、 _リサイズ_ するのではなく。\n"
"その結果、ベクタの最後のバイトは未初期化のメモリになります。\n"
"ブロックの最後にて `CString` を作成する際、\n"
"このベクタの読み出しが `undefined behaviour` を引き起こします！"

#: src/idioms/ffi/accepting-strings.md:136
msgid ""
"Like many such issues, this would be difficult issue to track down.\n"
"Sometimes it would panic because the string was not `UTF-8`, sometimes it "
"would\n"
"put a weird character at the end of the string, sometimes it would just\n"
"completely crash."
msgstr ""
"このような問題の多くがそうであるように、これは突き止めることが難しい問題とな"
"るでしょう。\n"
"ときには文字列が `UTF-8` でなかったためにパニックが発生したり、またときには文"
"字列の末尾に変な文字が置かれたり、または完全にクラッシュしたりすることでしょ"
"う。"

#: src/idioms/ffi/accepting-strings.md:143
#: src/idioms/ffi/passing-strings.md:105
msgid "None?"
msgstr "なし？"

#: src/idioms/ffi/passing-strings.md:1
msgid "# Passing Strings"
msgstr "# 文字列の受け渡し"

#: src/idioms/ffi/passing-strings.md:5
msgid ""
"When passing strings to FFI functions, there are four principles that should "
"be\n"
"followed:"
msgstr "FFI関数に文字列を渡す場合、次の4つの原則に従う必要があります："

#: src/idioms/ffi/passing-strings.md:8
msgid ""
"1. Make the lifetime of owned strings as long as possible.\n"
"2. Minimize `unsafe` code during the conversion.\n"
"3. If the C code can modify the string data, use `Vec` instead of "
"`CString`.\n"
"4. Unless the Foreign Function API requires it, the ownership of the string\n"
"   should not transfer to the callee."
msgstr ""
"1. 所有している文字列のライフタイムは可能な限り長くしてください。\n"
"2. 変換中の `unsafe` コードを最小限にします。\n"
"3. C言語のコードが文字列データを変更する可能性がある場合は、 `CString` の代わ"
"りに `Vec` を使用してください。\n"
"4. 外部関数のAPIが必要としない限り、文字列の所有権を着呼側に移さないようにし"
"ます。"

#: src/idioms/ffi/passing-strings.md:16
msgid ""
"Rust has built-in support for C-style strings with its `CString` and `CStr`\n"
"types. However, there are different approaches one can take with strings "
"that\n"
"are being sent to a foreign function call from a Rust function."
msgstr ""
"Rust は `CString` 型と `CStr` 型により C スタイルの文字列をビルトインでサポー"
"トしています。\n"
"しかしながら、Rust 関数から外部関数を呼び出す際に受け渡す文字列には、さまざま"
"なアプローチがあります。"

#: src/idioms/ffi/passing-strings.md:20
msgid ""
"The best practice is simple: use `CString` in such a way as to minimize\n"
"`unsafe` code. However, a secondary caveat is that\n"
"_the object must live long enough_, meaning the lifetime should be "
"maximized.\n"
"In addition, the documentation explains that \"round-tripping\" a `CString` "
"after\n"
"modification is UB, so additional work is necessary in that case."
msgstr ""
"ベストプラクティスは単純です：安全でないコードを最小限にするように `CString` "
"を使うことです。\n"
"ただし、二次的な注意点は _オブジェクトは十分に長く生存する必要がある_ です。"
"これはライフタイムを最大化すべきという意味です。\n"
"加えてドキュメントでは、変更後の `CString` を \"ラウンドトリップ\" することは"
"未定義動作であると説明されており、このようなケースでは追加の対応が必要です。"

#: src/idioms/ffi/passing-strings.md:28
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    extern \"C\" {\n"
"        fn seterr(message: *const libc::c_char);\n"
"        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> libc::"
"c_int;\n"
"    }\n"
"\n"
"    fn report_error_to_ffi<S: Into<String>>(\n"
"        err: S\n"
"    ) -> Result<(), std::ffi::NulError>{\n"
"        let c_err = std::ffi::CString::new(err.into())?;\n"
"\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation says the pointer "
"is\n"
"            // const, so no modification should occur\n"
"            seterr(c_err.as_ptr());\n"
"        }\n"
"\n"
"        Ok(())\n"
"        // The lifetime of c_err continues until here\n"
"    }\n"
"\n"
"    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> {\n"
"        let mut buffer = vec![0u8; 1024];\n"
"        unsafe {\n"
"            // SAFETY: calling an FFI whose documentation implies\n"
"            // that the input need only live as long as the call\n"
"            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();\n"
"\n"
"            buffer.truncate(written + 1);\n"
"        }\n"
"\n"
"        std::ffi::CString::new(buffer).unwrap().into_string()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // モジュールのその他の内容\n"
"\n"
"    extern \"C\" {\n"
"        fn seterr(message: *const libc::c_char);\n"
"        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -> libc::"
"c_int;\n"
"    }\n"
"\n"
"    fn report_error_to_ffi<S: Into<String>>(\n"
"        err: S\n"
"    ) -> Result<(), std::ffi::NulError>{\n"
"        let c_err = std::ffi::CString::new(err.into())?;\n"
"\n"
"        unsafe {\n"
"            // SAFETY: FFIのドキュメントにはポインタが const である記載されて"
"いるため、\n"
"            // 呼び出しにより変更が行われることはない\n"
"            seterr(c_err.as_ptr());\n"
"        }\n"
"\n"
"        Ok(())\n"
"        // The lifetime of c_err continues until here\n"
"    }\n"
"\n"
"    fn get_error_from_ffi() -> Result<String, std::ffi::IntoStringError> {\n"
"        let mut buffer = vec![0u8; 1024];\n"
"        unsafe {\n"
"            // SAFETY: FFIのドキュメントによると、入力値は呼び出しの間だけ生"
"存していればよい\n"
"            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();\n"
"\n"
"            buffer.truncate(written + 1);\n"
"        }\n"
"\n"
"        std::ffi::CString::new(buffer).unwrap().into_string()\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/passing-strings.md:70
msgid "The example is written in a way to ensure that:"
msgstr "この例は、以下のことを守るように記述されています："

#: src/idioms/ffi/passing-strings.md:72
msgid ""
"1. The `unsafe` block is as small as possible.\n"
"2. The `CString` lives long enough.\n"
"3. Errors with typecasts are always propagated when possible."
msgstr ""
"1. `unsafe` ブロックは可能な限り小さくします。\n"
"2. `CString` は十分生存します。\n"
"3. 型キャストによるエラーは可能であれば常に伝播されます。"

#: src/idioms/ffi/passing-strings.md:76
msgid ""
"A common mistake (so common it's in the documentation) is to not use the\n"
"variable in the first block:"
msgstr ""
"よくある間違い（ドキュメントにも載っているほど）は、最初のブロックで変数を使"
"わないことです："

#: src/idioms/ffi/passing-strings.md:79
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    fn report_error<S: Into<String>>(err: S) -> Result<(), std::ffi::"
"NulError> {\n"
"        unsafe {\n"
"            // SAFETY: whoops, this contains a dangling pointer!\n"
"            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // モジュールのその他の内容\n"
"\n"
"    fn report_error<S: Into<String>>(err: S) -> Result<(), std::ffi::"
"NulError> {\n"
"        unsafe {\n"
"            // SAFETY: おおっと, ここにはダングリングポインタがあります!\n"
"            seterr(std::ffi::CString::new(err.into())?.as_ptr());\n"
"        }\n"
"        Ok(())\n"
"    }\n"
"}\n"
"```"

#: src/idioms/ffi/passing-strings.md:94
msgid ""
"This code will result in a dangling pointer, because the lifetime of the\n"
"`CString` is not extended by the pointer creation, unlike if a reference "
"were\n"
"created."
msgstr ""
"このコードではダングリングポインタが発生します。\n"
"参照の作成とは異なり、ポインタの作成によって `CString` の寿命が延長されること"
"はないからです。"

#: src/idioms/ffi/passing-strings.md:98
msgid ""
"Another issue frequently raised is that the initialization of a 1k vector "
"of\n"
"zeroes is \"slow\". However, recent versions of Rust actually optimize that\n"
"particular macro to a call to `zmalloc`, meaning it is as fast as the "
"operating\n"
"system's ability to return zeroed memory (which is quite fast)."
msgstr ""
"もうひとつよく挙げられる問題は、1kのゼロ埋めベクトルの初期化が「遅い」という"
"ことです。\n"
"しかし、Rustの最近のバージョンでは、この特定のマクロはなんと `zmalloc` の呼び"
"出しに最適化されています。\n"
"これは、オペレーティングシステムのゼロ埋めしたメモリを返す機能（これはかなり"
"高速です）と同じ速さであることを意味します。"

#: src/idioms/option-iter.md:1
msgid "# Iterating over an `Option`"
msgstr "# `Option` に対する反復処理"

#: src/idioms/option-iter.md:5
msgid ""
"`Option` can be viewed as a container that contains either zero or one\n"
"element. In particular, it implements the `IntoIterator` trait, and as such\n"
"can be used with generic code that needs such a type."
msgstr ""
"`Option` は、0個または1個の要素を含むコンテナとみなすことができます。\n"
"特にこれは `IntoIterator` トレイトを実装しているため、そのような型を必要とす"
"るジェネリックなコードにて利用できます。"

#: src/idioms/option-iter.md:9 src/patterns/structural/small-crates.md:34
#: src/patterns/structural/unsafe-mods.md:22
msgid "## Examples"
msgstr "## 例"

#: src/idioms/option-iter.md:11
msgid ""
"Since `Option` implements `IntoIterator`, it can be used as an argument to\n"
"[`.extend()`](https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod."
"extend):"
msgstr ""
"`Option` は `IntoIterator` を実装しているので、[`.extend()`](https://doc."
"rust-lang.org/std/iter/trait.Extend.html#tymethod.extend)の引数として使用でき"
"ます："

#: src/idioms/option-iter.md:14
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"logicians.extend(turing);\n"
"\n"
"// equivalent to\n"
"if let Some(turing_inner) = turing {\n"
"    logicians.push(turing_inner);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let mut logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"logicians.extend(turing);\n"
"\n"
"// 以下と等価\n"
"if let Some(turing_inner) = turing {\n"
"    logicians.push(turing_inner);\n"
"}\n"
"```"

#: src/idioms/option-iter.md:26
msgid ""
"If you need to tack an `Option` to the end of an existing iterator, you can\n"
"pass it to [`.chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.chain):"
msgstr ""
"既存のイテレータの末尾に `Option` を追加する必要がある場合、それを/ [`."
"chain()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method."
"chain) に渡せます："

#: src/idioms/option-iter.md:29
msgid ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"for logician in logicians.iter().chain(turing.iter()) {\n"
"    println!(\"{} is a logician\", logician);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"let turing = Some(\"Turing\");\n"
"let logicians = vec![\"Curry\", \"Kleene\", \"Markov\"];\n"
"\n"
"for logician in logicians.iter().chain(turing.iter()) {\n"
"    println!(\"{} is a logician\", logician);\n"
"}\n"
"```"

#: src/idioms/option-iter.md:38
msgid ""
"Note that if the `Option` is always `Some`, then it is more idiomatic to "
"use\n"
"[`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) on the\n"
"element instead."
msgstr ""
"もし `Option` が常に `Some` である場合は、代わりに、その要素に対して [`std::"
"iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) を使用する方が"
"より慣習的であることに注意してください。"

#: src/idioms/option-iter.md:42
msgid ""
"Also, since `Option` implements `IntoIterator`, it's possible to iterate "
"over\n"
"it using a `for` loop. This is equivalent to matching it with `if let "
"Some(..)`,\n"
"and in most cases you should prefer the latter."
msgstr ""
"また、`Option` は `IntoIterator` を実装しているので、`for` ループを使って繰り"
"返し処理を行うことができます。\n"
"これは `if let Some(...)` とマッチさせるのと同じです。\n"
"ほとんどの場合、後者の方がよいでしょう。"

#: src/idioms/option-iter.md:48
msgid ""
"- [`std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html) is "
"an\n"
"  iterator which yields exactly one element. It's a more readable "
"alternative to\n"
"  `Some(foo).into_iter()`.\n"
"\n"
"- [`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.filter_map)\n"
"  is a version of [`Iterator::map`](https://doc.rust-lang.org/std/iter/trait."
"Iterator.html#method.map),\n"
"  specialized to mapping functions which return `Option`.\n"
"\n"
"- The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"  for converting an `Option` to a zero- or one-element slice.\n"
"\n"
"- [Documentation for `Option<T>`](https://doc.rust-lang.org/std/option/enum."
"Option.html)"
msgstr ""
"- [std::iter::once`](https://doc.rust-lang.org/std/iter/fn.once.html)はちょう"
"ど1つの要素を返すイテレータです。\n"
"  これは `Some(foo).into_iter()` に対するよりわかりやすい代案です。\n"
"\n"
"- [`Iterator::filter_map`](https://doc.rust-lang.org/std/iter/trait.Iterator."
"html#method.filter_map)\n"
"  は `Option` を返す関数のマッピングに特化した [`Iterator::map`](https://doc."
"rust-lang.org/std/iter/trait.Iterator.html#method.map) のバージョンです。\n"
"\n"
"- [`ref_slice`](https://crates.io/crates/ref_slice) は `Option` を 0 要素また"
"は 1 要素のスライスに変換する関数を提供する crate です。\n"
"\n"
"- [`Option<T>` のドキュメント](https://doc.rust-lang.org/std/option/enum."
"Option.html)"

#: src/idioms/pass-var-to-closure.md:1
msgid "# Pass variables to closure"
msgstr "# 変数をクロージャに渡す"

#: src/idioms/pass-var-to-closure.md:5
msgid ""
"By default, closures capture their environment by borrowing. Or you can use\n"
"`move`-closure to move whole environment. However, often you want to move "
"just\n"
"some variables to closure, give it copy of some data, pass it by reference, "
"or\n"
"perform some other transformation."
msgstr ""
"デフォルトでは、クロージャは借用する形で環境をキャプチャします。\n"
"あるいは環境全体をムーブする `move` クロージャを使うこともできます。\n"
"しかしながら、クロージャへ一部の変数のみを対象に、ムーブさせる／データのコ"
"ピーを与える／参照渡しをする／その他の変換を行う、といったことをしたいことが"
"よくあります。"

#: src/idioms/pass-var-to-closure.md:10
msgid "Use variable rebinding in separate scope for that."
msgstr "そのためには、別のスコープで変数の再バインディングを使用します。"

#: src/idioms/pass-var-to-closure.md:14
msgid "Use"
msgstr "次の例のようにしましょう"

#: src/idioms/pass-var-to-closure.md:16
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"let closure = {\n"
"    // `num1` is moved\n"
"    let num2 = num2.clone();  // `num2` is cloned\n"
"    let num3 = num3.as_ref();  // `num3` is borrowed\n"
"    move || {\n"
"        *num1 + *num2 + *num3;\n"
"    }\n"
"};\n"
"```"
msgstr ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"let closure = {\n"
"    // `num1` はムーブされます\n"
"    let num2 = num2.clone();  // `num2` はクローンされます\n"
"    let num3 = num3.as_ref();  // `num3` は借用されます\n"
"    move || {\n"
"        *num1 + *num2 + *num3;\n"
"    }\n"
"};\n"
"```"

#: src/idioms/pass-var-to-closure.md:32
msgid "instead of"
msgstr "上の例は下の例と同等の意味となります"

#: src/idioms/pass-var-to-closure.md:34
msgid ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"\n"
"let num2_cloned = num2.clone();\n"
"let num3_borrowed = num3.as_ref();\n"
"let closure = move || {\n"
"    *num1 + *num2_cloned + *num3_borrowed;\n"
"};\n"
"```"
msgstr ""
"```rust\n"
"use std::rc::Rc;\n"
"\n"
"let num1 = Rc::new(1);\n"
"let num2 = Rc::new(2);\n"
"let num3 = Rc::new(3);\n"
"\n"
"let num2_cloned = num2.clone();\n"
"let num3_borrowed = num3.as_ref();\n"
"let closure = move || {\n"
"    *num1 + *num2_cloned + *num3_borrowed;\n"
"};\n"
"```"

#: src/idioms/pass-var-to-closure.md:50
msgid ""
"Copied data are grouped together with closure definition, so their purpose "
"is\n"
"more clear, and they will be dropped immediately even if they are not "
"consumed\n"
"by closure."
msgstr ""
"コピーされたデータは、クロージャの定義と一緒にグループ化されるため、その目的"
"がより明確になります。\n"
"また、もしそれらがクロージャによって消費されない場合でも、即座に削除されるこ"
"とになります。"

#: src/idioms/pass-var-to-closure.md:54
msgid ""
"Closure uses same variable names as surrounding code whether data are copied "
"or\n"
"moved."
msgstr ""
"クロージャは、データがコピーされようがムーブされようが、周辺のコードと同じ変"
"数名を使用します。"

#: src/idioms/pass-var-to-closure.md:59
msgid "Additional indentation of closure body."
msgstr "クロージャの本体のインデントが増えます。"

#: src/idioms/priv-extend.md:1
msgid "# `#[non_exhaustive]` and private fields for extensibility"
msgstr "# 拡張性のための `#[non_exhaustive]` と private なフィールド"

#: src/idioms/priv-extend.md:5
msgid ""
"A small set of scenarios exist where a library author may want to add "
"public\n"
"fields to a public struct or new variants to an enum without breaking "
"backwards\n"
"compatibility."
msgstr ""
"ライブラリの作者が後方互換性を破壊することなく、publicな構造体へpublicな"
"フィールドを追加したり、\n"
"enumへ新しいバリアントを追加したりしたい、といったいくつかのシナリオがありま"
"す。"

#: src/idioms/priv-extend.md:9
msgid "Rust offers two solutions to this problem:"
msgstr "Rust はこの問題に対して2つの解決策を提供します："

#: src/idioms/priv-extend.md:11
msgid ""
"- Use `#[non_exhaustive]` on `struct`s, `enum`s, and `enum` variants.\n"
"  For extensive documentation on all the places where `#[non_exhaustive]` "
"can be\n"
"  used, see [the docs](https://doc.rust-lang.org/reference/attributes/"
"type_system.html#the-non_exhaustive-attribute).\n"
"\n"
"- You may add a private field to a struct to prevent it from being directly\n"
"  instantiated or matched against (see Alternative)"
msgstr ""
"-  `struct` や `enum` 、 `enum` バリアントに対して `#[non_exhaustive]` を使用"
"する。\n"
"  [`non_exhaustive]`が使用できるすべての場所に関する詳細なドキュメントは "
"[the docs](https://doc.rust-lang.org/reference/attributes/type_system."
"html#the-non_exhaustive-attribute). を参照してください。\n"
"\n"
"- 構造体が直接インスタンス化されたり、マッチングされたりしないようにするため"
"に、\n"
"  構造体に private なフィールドを追加することができます（Alternative 参照）。"

#: src/idioms/priv-extend.md:20
msgid ""
"```rust\n"
"mod a {\n"
"    // Public struct.\n"
"    #[non_exhaustive]\n"
"    pub struct S {\n"
"        pub foo: i32,\n"
"    }\n"
"    \n"
"    #[non_exhaustive]\n"
"    pub enum AdmitMoreVariants {\n"
"        VariantA,\n"
"        VariantB,\n"
"        #[non_exhaustive]\n"
"        VariantC { a: String }\n"
"    }\n"
"}\n"
"\n"
"fn print_matched_variants(s: a::S) {\n"
"    // Because S is `#[non_exhaustive]`, it cannot be named here and\n"
"    // we must use `..` in the pattern.\n"
"    let a::S { foo: _, ..} = s;\n"
"    \n"
"    let some_enum = a::AdmitMoreVariants::VariantA;\n"
"    match some_enum {\n"
"        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
"        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
"\n"
"        // .. required because this variant is non-exhaustive as well\n"
"        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a c\"),\n"
"\n"
"        // The wildcard match is required because more variants may be\n"
"        // added in the future\n"
"        _ => println!(\"it's a new variant\")\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod a {\n"
"    // Public な構造体\n"
"    #[non_exhaustive]\n"
"    pub struct S {\n"
"        pub foo: i32,\n"
"    }\n"
"    \n"
"    #[non_exhaustive]\n"
"    pub enum AdmitMoreVariants {\n"
"        VariantA,\n"
"        VariantB,\n"
"        #[non_exhaustive]\n"
"        VariantC { a: String }\n"
"    }\n"
"}\n"
"\n"
"fn print_matched_variants(s: a::S) {\n"
"    // S は `#[non_exhaustive]` でないため、ここではすべてに名前を付けること"
"ができず、\n"
"    // パターンに `..` を使用する必要があります。\n"
"    let a::S { foo: _, ..} = s;\n"
"    \n"
"    let some_enum = a::AdmitMoreVariants::VariantA;\n"
"    match some_enum {\n"
"        a::AdmitMoreVariants::VariantA => println!(\"it's an A\"),\n"
"        a::AdmitMoreVariants::VariantB => println!(\"it's a b\"),\n"
"\n"
"        // このバリアントも `#[non_exhaustive]` であるため、 `..` が必要で"
"す。 \n"
"        a::AdmitMoreVariants::VariantC { a, .. } => println!(\"it's a c\"),\n"
"\n"
"        // 将来的にバリアントが追加される可能性があるため、\n"
"        // ワイルドカードのマッチが必要です。\n"
"        _ => println!(\"it's a new variant\")\n"
"    }\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:57
msgid "## Alternative: `Private fields` for structs"
msgstr "## Alternative： 構造体の private なフィールド"

#: src/idioms/priv-extend.md:59
msgid ""
"`#[non_exhaustive]` only works across crate boundaries.\n"
"Within a crate, the private field method may be used."
msgstr ""
"`[non_exhaustive]` が機能するのは、crate の境界を越えるときのみです。\n"
"クレート内部では、private なフィールドによる手法を使用できます。"

#: src/idioms/priv-extend.md:62
msgid ""
"Adding a field to a struct is a mostly backwards compatible change.\n"
"However, if a client uses a pattern to deconstruct a struct instance, they\n"
"might name all the fields in the struct and adding a new one would break "
"that\n"
"pattern.\n"
"The client could name some fields and use `..` in the pattern, in which case "
"adding\n"
"another field is backwards compatible.\n"
"Making at least one of the struct's fields private forces clients to use the "
"latter\n"
"form of patterns, ensuring that the struct is future-proof."
msgstr ""
"構造体にフィールドを追加することはだいたいの場合、後方互換性のある変更で"
"す。\n"
"ただし、構造体のクライアントが、パターンを使用して構造体のインスタンスをデコ"
"ンストラクトする際に、構造体内のすべてのフィールドに名前を付けている可能性が"
"あります。この状況で構造体に新しいフィールドを追加することは、そのパターンを"
"壊すことになります。\n"
"クライアントは、パターンの中でいくつかのフィールドに名前を付けるとともに `.."
"` を使うことが可能であり、この場合はフィールドの追加に対して後方互換性があり"
"ます。\n"
"構造体のフィールドの1つ以上を private なものにすることで、クライアントに後者"
"のパターンを使用することを強制することが可能であり、構造体の将来性を確保でき"
"ます。"

#: src/idioms/priv-extend.md:71
msgid ""
"The downside of this approach is that you might need to add an otherwise "
"unneeded\n"
"field to the struct.\n"
"You can use the `()` type so that there is no runtime overhead and prepend "
"`_` to\n"
"the field name to avoid the unused field warning."
msgstr ""
"この方法の欠点は、構造体に本来不要なフィールドを追加する必要がある可能性があ"
"ることです。\n"
"`()` 型を使うことでランタイムのオーバーヘッドを回避できます。\n"
"またフィールド名の頭に `_` を付けることで未使用フィールドの警告を回避できま"
"す。"

#: src/idioms/priv-extend.md:76
msgid ""
"```rust\n"
"pub struct S {\n"
"    pub a: i32,\n"
"    // Because `b` is private, you cannot match on `S` without using `..` "
"and `S`\n"
"    //  cannot be directly instantiated or matched against\n"
"    _b: ()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub struct S {\n"
"    pub a: i32,\n"
"    // `b` は private です。 `S` に対して `..` を使用せずにパターンマッチする"
"ことは不可能であり、 \n"
"    // `S` を直接インスタンス化したり、マッチ対象としたりすること不可能で"
"す。\n"
"    _b: ()\n"
"}\n"
"```"

#: src/idioms/priv-extend.md:87
msgid ""
"On `struct`s, `#[non_exhaustive]` allows adding additional fields in a "
"backwards\n"
"compatible way.\n"
"It will also prevent clients from using the struct constructor, even if all "
"the\n"
"fields are public.\n"
"This may be helpful, but it's worth considering if you _want_ an additional "
"field\n"
"to be found by clients as a compiler error rather than something that may be "
"silently\n"
"undiscovered."
msgstr ""
"`struct` に対しては `#[non_exhaustive]` は、後方互換性のある形でフィールドを"
"追加可能にします。\n"
"また、すべてのフィールドがpublicであっても、クライアントは構造体のコンストラ"
"クタを使用できなくなります。\n"
"これは便利ではあります。しかしながら、フィールドの追加がコンパイルエラーを起"
"こすようにすることで、エラーを見たクライアントがフィールドが追加されたことに"
"気づけるようにする形が (フィールドの追加をクライアントに隠す形よりも) _期待_ "
"されることもあります。"

#: src/idioms/priv-extend.md:95
msgid ""
"`#[non_exhaustive]` can be applied to enum variants as well.\n"
"A `#[non_exhaustive]` variant behaves in the same way as a "
"`#[non_exhaustive]` struct."
msgstr ""
"`#[non_exhaustive]` は列挙型のバリアントにも適用できます。\n"
"`#[non_exhaustive]` なバリアントは、`#[non_exhaustive]` な構造体と同様に振舞"
"います。"

#: src/idioms/priv-extend.md:98
msgid ""
"Use this deliberately and with caution: incrementing the major version when "
"adding\n"
"fields or variants is often a better option.\n"
"`#[non_exhaustive]` may be appropriate in scenarios where you're modeling an "
"external\n"
"resource that may change out-of-sync with your library, but is not a general "
"purpose\n"
"tool."
msgstr ""
"この方法は計画的かつ注意深く使用してください：フィールドやバリアントを追加す"
"るときは、 メジャーバージョンをインクリメントした方が良いことが多いのです。\n"
"`#[non_exhaustive]`は、あなたのライブラリが、ライブラリに同期させることができ"
"ない外部のリソースをモデリングする場合に適切かもしれませんが、汎用目的のツー"
"ルではありません。"

#: src/idioms/priv-extend.md:104
msgid "### Disadvantages"
msgstr "### デメリット"

#: src/idioms/priv-extend.md:106
msgid ""
"`#[non_exhaustive]` can make your code much less ergonomic to use, "
"especially when\n"
"forced to handle unknown enum variants.\n"
"It should only be used when these sorts of evolutions are required "
"**without**\n"
"incrementing the major version."
msgstr ""
"`#[non_exhaustive]`はコードを人間工学的に使いにくくします。\n"
"特に未知の列挙型の変種を扱わなければならない場合は顕著です。\n"
"この種の開発を、メジャーバージョンをインクリメント **せずに** 行う必要な場合"
"にのみ使うべきです。"

#: src/idioms/priv-extend.md:111
msgid ""
"When `#[non_exhaustive]` is applied to `enum`s, it forces clients to handle "
"a\n"
"wildcard variant.\n"
"If there is no sensible action to take in this case, this may lead to "
"awkward\n"
"code and code paths that are only executed in extremely rare circumstances.\n"
"If a client decides to `panic!()` in this scenario, it may have been better "
"to\n"
"expose this error at compile time.\n"
"In fact, `#[non_exhaustive]` forces clients to handle the \"Something else\" "
"case;\n"
"there is rarely a sensible action to take in this scenario."
msgstr ""
"`enum` に `#[non_exhaustive]` を適用することは、クライアントにワイルドカード"
"の使用を強制します。\n"
"この場合に取るべき賢明なアクションがなければ、厄介なコードや、極めて稀な状況"
"でのみ実行されるコードパスを生み出しかねません。\n"
"クライアントがこのシナリオで `panic!()` を選択するようなら、コンパイル時エ"
"ラーとして公開された方がよかったかもしれません。\n"
"実際、`#[non_exhaustive]`はクライアントに 「その他の何か」 に対するケースを処"
"理するように強制します。そして、このシナリオで取るべき賢明なアクションはまず"
"ありません。"

#: src/idioms/priv-extend.md:122
msgid ""
"- [RFC introducing #[non_exhaustive] attribute for enums and structs]"
"(https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"
msgstr ""
"- [`enum` と `struct` に `#[non_exhaustive]` 属性を導入するRFC](https://"
"github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"

#: src/idioms/rustdoc-init.md:1
msgid "# Easy doc initialization"
msgstr "# docコメント内の簡易な初期化"

#: src/idioms/rustdoc-init.md:5
msgid ""
"If a struct takes significant effort to initialize when writing docs, it can "
"be\n"
"quicker to wrap your example with a helper function which takes the struct "
"as an\n"
"argument."
msgstr ""
"docコメントを書く際に、構造体を初期化するのに多大な労力がかかる場合は、\n"
"構造体を引数に取るヘルパー関数でコード例をラップした方が手っ取り早いかもしれ"
"ません。"

#: src/idioms/rustdoc-init.md:11
msgid ""
"Sometimes there is a struct with multiple or complicated parameters and "
"several\n"
"methods. Each of these methods should have examples."
msgstr ""
"多数の、または複雑なパラメータや複数のメソッドが、構造体に存在するとしましょ"
"う。\n"
"これらのメソッドにはそれぞれコード例があるはずです。"

#: src/idioms/rustdoc-init.md:14
msgid "For example:"
msgstr "例:"

#: src/idioms/rustdoc-init.md:16
msgid ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```no_run\n"
"    /// # // Boilerplate are required to get an example working.\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream };\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> {\n"
"        // ...\n"
"    }\n"
"\n"
"    /// Oh no, all that boilerplate needs to be repeated here!\n"
"    fn check_status(&self) -> Status {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信\n"
"    ///\n"
"    /// # Example\n"
"    /// ```no_run\n"
"    /// # // コード例を機能させるにはボイラーテンプレートが必要になります。\n"
"    /// # let stream = TcpStream::connect(\"127.0.0.1:34254\");\n"
"    /// # let connection = Connection { name: \"foo\".to_owned(), stream };\n"
"    /// # let request = Request::new(\"RequestId\", RequestType::Get, "
"\"payload\");\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) -> Result<Status, SendErr> {\n"
"        // ...\n"
"    }\n"
"\n"
"    /// なんと、ここでも同じボイラーテンプレートが必要です！\n"
"    fn check_status(&self) -> Status {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:47
msgid ""
"Instead of typing all of this boilerplate to create a `Connection` and\n"
"`Request`, it is easier to just create a wrapping helper function which "
"takes\n"
"them as arguments:"
msgstr ""
"このような `Connection` や `Request` を生成するボイラーテンプレートすべてをタ"
"イピングする代わりに、\n"
"それらを引数として受け取るヘルパー関数をラッパーとして作成する方が簡単です："

#: src/idioms/rustdoc-init.md:51
msgid ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// Sends a request over the connection.\n"
"    ///\n"
"    /// # Example\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// # }\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"
msgstr ""
"````rust,ignore\n"
"struct Connection {\n"
"    name: String,\n"
"    stream: TcpStream,\n"
"}\n"
"\n"
"impl Connection {\n"
"    /// 接続を介してリクエストを送信\n"
"    ///\n"
"    /// # Example\n"
"    /// ```\n"
"    /// # fn call_send(connection: Connection, request: Request) {\n"
"    /// let response = connection.send_request(request);\n"
"    /// assert!(response.is_ok());\n"
"    /// # }\n"
"    /// ```\n"
"    fn send_request(&self, request: Request) {\n"
"        // ...\n"
"    }\n"
"}\n"
"````"

#: src/idioms/rustdoc-init.md:73
msgid ""
"**Note** in the above example the line `assert!(response.is_ok());` will "
"not\n"
"actually run while testing because it is inside a function which is never\n"
"invoked."
msgstr ""
"**注意** 上記の例における、 `assert!(response.is_ok());` という行は、\n"
"呼び出されない関数内にあるため、実際にはテスト中に実行されません。"

#: src/idioms/rustdoc-init.md:79
msgid "This is much more concise and avoids repetitive code in examples."
msgstr ""
"この方がはるかに簡潔で、コード例中のコードの繰り返しを避けることができます。"

#: src/idioms/rustdoc-init.md:83
msgid ""
"As example is in a function, the code will not be tested. Though it will "
"still be\n"
"checked to make sure it compiles when running a `cargo test`. So this "
"pattern is\n"
"most useful when you need `no_run`. With this, you do not need to add "
"`no_run`."
msgstr ""
"コード例が関数定義の中にあるので、コードはテストされません。\n"
"しかし `cargo test` を実行することで、コンパイルできたかどうかはチェックされ"
"ます。\n"
"ですから、このパターンは `no_run` が必要なときに便利です。このパターンを使う"
"場合、（実行されないため） `no_run` を追加する必要はありません。"

#: src/idioms/rustdoc-init.md:89
msgid "If assertions are not required this pattern works well."
msgstr "アサーションが必要ない場合は、このパターンがうまく機能します。"

#: src/idioms/rustdoc-init.md:91
msgid ""
"If they are, an alternative can be to create a public method to create a "
"helper\n"
"instance which is annotated with `#[doc(hidden)]` (so that users won't see "
"it).\n"
"Then this method can be called inside of rustdoc because it is part of the\n"
"crate's public API."
msgstr ""
"もしアサーションが必要であるなら、別の方法として、ヘルパーインスタンスを作成"
"するpublicメソッドを `#[doc(hidden)]` でアノテーションして作成する方法があり"
"ます。\n"
"これにより、このメソッドはcrateのパブリックAPIの一部として、 rustdoc の内部で"
"呼び出すことが可能になります。"

#: src/idioms/temporary-mutability.md:1
msgid "# Temporary mutability"
msgstr "# 一時的なミュータビリティ"

#: src/idioms/temporary-mutability.md:5
msgid ""
"Often it is necessary to prepare and process some data, but after that data "
"are\n"
"only inspected and never modified. The intention can be made explicit by "
"redefining\n"
"the mutable variable as immutable."
msgstr ""
"あるデータを準備・処理する必要があり、いったんそれが済めば、データは参照され"
"るだけであり、変更されることはない、という状況がよくあります。\n"
"このような状況では、可変変数を不変変数として再定義することで、その意図を明示"
"することができます。"

#: src/idioms/temporary-mutability.md:9
msgid ""
"It can be done either by processing data within a nested block or by "
"redefining\n"
"the variable."
msgstr ""
"これは、ネストされたブロック内でデータを処理することか、変数を再束縛すること"
"で実現できます。"

#: src/idioms/temporary-mutability.md:14
msgid "Say, vector must be sorted before usage."
msgstr "ベクタが使用される前にソートする必要がある、という状況を考えましょう。"

#: src/idioms/temporary-mutability.md:16
msgid "Using nested block:"
msgstr "ネストされたブロックを使う場合："

#: src/idioms/temporary-mutability.md:18
msgid ""
"```rust,ignore\n"
"let data = {\n"
"    let mut data = get_vec();\n"
"    data.sort();\n"
"    data\n"
"};\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""
"```rust,ignore\n"
"let data = {\n"
"    let mut data = get_vec();\n"
"    data.sort();\n"
"    data\n"
"};\n"
"\n"
"// ここで `data` は不変です。\n"
"```"

#: src/idioms/temporary-mutability.md:28
msgid "Using variable rebinding:"
msgstr "変数の再束縛を使う場合："

#: src/idioms/temporary-mutability.md:30
msgid ""
"```rust,ignore\n"
"let mut data = get_vec();\n"
"data.sort();\n"
"let data = data;\n"
"\n"
"// Here `data` is immutable.\n"
"```"
msgstr ""
"```rust,ignore\n"
"let mut data = get_vec();\n"
"data.sort();\n"
"let data = data;\n"
"\n"
"// ここで `data` は不変です。\n"
"```"

#: src/idioms/temporary-mutability.md:40
msgid ""
"Compiler ensures that you don't accidentally mutate data after some point."
msgstr ""
"ある時点以降にデータを誤って変更してしまうことを、コンパイラが防ぎます。"

#: src/idioms/temporary-mutability.md:44
msgid ""
"Nested block requires additional indentation of block body.\n"
"One more line to return data from block or redefine variable."
msgstr ""
"ネストされたブロックは、ブロックの本体に追加のインデントが必要になります。\n"
"ブロックからデータを返したり、変数を再定義するに、追加の1行が必要です。"

#: src/idioms/return-consumed-arg-on-error.md:1
msgid "# Return consumed argument on error"
msgstr "# エラー時に消費した引数を返す"

#: src/idioms/return-consumed-arg-on-error.md:5
msgid ""
"If a fallible function consumes (moves) an argument, return that argument "
"back inside\n"
"an error."
msgstr ""
"失敗する可能性のある関数が引数を消費(move)した場合、その引数をエラーの中に返"
"却しましょう。"

#: src/idioms/return-consumed-arg-on-error.md:10
msgid ""
"```rust\n"
"pub fn send(value: String) -> Result<(), SendError> {\n"
"    println!(\"using {value} in a meaningful way\");\n"
"    // Simulate non-deterministic fallible action.\n"
"    use std::time::SystemTime;\n"
"    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
"unwrap();\n"
"    if period.subsec_nanos() % 2 == 1 {\n"
"        Ok(())\n"
"    } else {\n"
"        Err(SendError(value))\n"
"    }\n"
"}\n"
"\n"
"pub struct SendError(String);\n"
"\n"
"fn main() {\n"
"    let mut value = \"imagine this is very long string\".to_string();\n"
"\n"
"    let success = 's: {\n"
"        // Try to send value two times.\n"
"        for _ in 0..2 {\n"
"            value = match send(value) {\n"
"                Ok(()) => break 's true,\n"
"                Err(SendError(value)) => value,\n"
"            }\n"
"        }\n"
"        false\n"
"    };\n"
"\n"
"    println!(\"success: {}\", success);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub fn send(value: String) -> Result<(), SendError> {\n"
"    println!(\"using {value} in a meaningful way\");\n"
"    // 非決定的に失敗し得る操作をシミュレート\n"
"    use std::time::SystemTime;\n"
"    let period = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)."
"unwrap();\n"
"    if period.subsec_nanos() % 2 == 1 {\n"
"        Ok(())\n"
"    } else {\n"
"        Err(SendError(value))\n"
"    }\n"
"}\n"
"\n"
"pub struct SendError(String);\n"
"\n"
"fn main() {\n"
"    let mut value = \"この文字列がとても長いと考えてください\".to_string();\n"
"\n"
"    let success = 's: {\n"
"        // value の send を2回まで試行\n"
"        for _ in 0..2 {\n"
"            value = match send(value) {\n"
"                Ok(()) => break 's true,\n"
"                Err(SendError(value)) => value,\n"
"            }\n"
"        }\n"
"        false\n"
"    };\n"
"\n"
"    println!(\"success: {}\", success);\n"
"}\n"
"```"

#: src/idioms/return-consumed-arg-on-error.md:45
msgid ""
"In case of error you may want to try some alternative way or to\n"
"retry action in case of non-deterministic function. But if the argument\n"
"is always consumed, you are forced to clone it on every call, which\n"
"is not very efficient."
msgstr ""
"エラーが発生した際、なにか別の手段を試したり、非決定的な関数であるならリトラ"
"イしたくなるものです。\n"
"しかし、もし引数が常に消費されてしまうのであれば、呼び出しのたびに引数をク"
"ローンしなければならなくなります。\n"
"これではとても効率的とは言えません。"

#: src/idioms/return-consumed-arg-on-error.md:50
msgid ""
"The standard library uses this approach in e.g. `String::from_utf8` method.\n"
"When given a vector that doesn't contain valid UTF-8, a `FromUtf8Error`\n"
"is returned.\n"
"You can get original vector back using `FromUtf8Error::into_bytes` method."
msgstr ""
"標準ライブラリでは、このアプローチを `String::from_utf8` メソッドなどで使用し"
"ています。\n"
"有効な UTF-8 を含まないベクタが与えられた場合、 `FromUtf8Error` を返しま"
"す。\n"
" `FromUtf8Error::into_bytes` メソッドを使用することで、元のベクタを取得できま"
"す。"

#: src/idioms/return-consumed-arg-on-error.md:57
msgid "Better performance because of moving arguments whenever possible."
msgstr "可能な限り引数をmoveすることで、パフォーマンスを向上させます。"

#: src/idioms/return-consumed-arg-on-error.md:61
msgid "Slightly more complex error types."
msgstr "エラーの型がやや複雑になります。"

#: src/patterns/index.md:1
msgid "# Design Patterns"
msgstr "# デザインパターン"

#: src/patterns/index.md:3
msgid ""
"[Design patterns](https://en.wikipedia.org/wiki/Software_design_pattern) "
"are\n"
"\"general reusable solutions to a commonly occurring problem within a given\n"
"context in software design\". Design patterns are a great way to describe "
"the\n"
"culture of a programming language. Design patterns are very language-"
"specific -\n"
"what is a pattern in one language may be unnecessary in another due to a\n"
"language feature, or impossible to express due to a missing feature."
msgstr ""
"[デザインパターン](https://en.wikipedia.org/wiki/Software_design_pattern) と"
"は\n"
"「general reusable solutions to a commonly occurring problem within a given\n"
"context in software design(ソフトウェア設計において、与えられた文脈の中で一般"
"的に発生する問題に対する一般的で再利用可能な解決策)」です。\n"
"デザインパターンはプログラミング言語の文化を表現する素晴らしい方法です。\n"
"デザインパターンはとても言語固有のものです。\n"
"ある言語ではパターンであっても、別の言語ではその言語の特徴によって不要であっ"
"たり、欠けている機能によって表現できなかったりします。"

#: src/patterns/index.md:10
msgid ""
"If overused, design patterns can add unnecessary complexity to programs.\n"
"However, they are a great way to share intermediate and advanced level "
"knowledge\n"
"about a programming language."
msgstr ""
"デザインパターンは使い過ぎると、プログラムに不必要な複雑さを加えることがあり"
"ます。\n"
"しかし、デザインパターンは、プログラミング言語に関する中級および上級レベルの"
"知識を共有するための素晴らしい方法です。"

#: src/patterns/index.md:16
msgid ""
"Rust has many unique features. These features give us great benefit by "
"removing\n"
"whole classes of problems. Some of them are also patterns that are _unique_ "
"to Rust."
msgstr ""
"Rust には多くのユニークな特徴があります。\n"
"これらの機能は、各種問題の大半を取り除く、大きなメリットをもたらします。その"
"中には、Rust _独自_ のパターンもあります。"

#: src/patterns/index.md:19
msgid "## YAGNI"
msgstr "## YAGNI"

#: src/patterns/index.md:21
msgid ""
"YAGNI is an acronym that stands for `You Aren't Going to Need It`.\n"
"It's a vital software design principle to apply as you write code."
msgstr ""
"YAGNIとは「You Aren't Going to Need It」の頭文字をとったものです。\n"
"これは、コードを書くときに適用すべき重要なソフトウェア設計の原則です。"

#: src/patterns/index.md:24
msgid "> The best code I ever wrote was code I never wrote."
msgstr "> これまで書いた中で最高のコードは、書かなかったコードです。"

#: src/patterns/index.md:26
msgid ""
"If we apply YAGNI to design patterns, we see that the features of Rust allow "
"us to\n"
"throw out many patterns. For instance, there is no need for the [strategy "
"pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"in Rust because we can just use [traits](https://doc.rust-lang.org/book/"
"traits.html)."
msgstr ""
"YAGNIをデザインパターンに適用すると、Rustの機能によって多くのパターンを捨てる"
"ことができることがわかります。\n"
"例えば、Rustでは [strategyパターン](https://en.wikipedia.org/wiki/"
"Strategy_pattern) は不要です。\n"
"なぜなら、単に [trait](https://doc.rust-lang.org/book/traits.html) を使えば良"
"いためです。"

#: src/patterns/behavioural/intro.md:1
msgid "# Behavioural Patterns"
msgstr "# 振る舞いに関するパターン"

#: src/patterns/behavioural/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Behavioral_pattern) より："

#: src/patterns/behavioural/intro.md:5
msgid ""
"> Design patterns that identify common communication patterns among "
"objects.\n"
"> By doing so, these patterns increase flexibility in carrying out "
"communication."
msgstr ""
"> Design patterns that identify common communication patterns among "
"objects.\n"
"> By doing so, these patterns increase flexibility in carrying out "
"communication.\n"
"> (オブジェクト間で共通するコミュニケーションのパターンを特定するデザインパ"
"ターン。\n"
"> これらのパターンの実践により、コミュニケーションを実行する際の柔軟性が高ま"
"ります。)"

#: src/patterns/behavioural/command.md:1
msgid "# Command"
msgstr "# Command"

#: src/patterns/behavioural/command.md:5
msgid ""
"The basic idea of the Command pattern is to separate out actions into its "
"own\n"
"objects and pass them as parameters."
msgstr ""
"Commandパターンの基本的な考え方は、アクションを独自のオブジェクトに分離し、\n"
"それらをパラメータとして渡すことです。"

#: src/patterns/behavioural/command.md:10
msgid ""
"Suppose we have a sequence of actions or transactions encapsulated as "
"objects.\n"
"We want these actions or commands to be executed or invoked in some order "
"later\n"
"at different time. These commands may also be triggered as a result of some "
"event.\n"
"For example, when a user pushes a button, or on arrival of a data packet.\n"
"In addition, these commands might be undoable. This may come in useful for\n"
"operations of an editor. We might want to store logs of executed commands so "
"that\n"
"we could reapply the changes later if the system crashes."
msgstr ""
"オブジェクトとしてカプセル化された一連のアクションやトランザクションがあると"
"します。\n"
"これらのアクションやコマンドを、ある順序で、別の時間に実行したり呼び出したり"
"したいとします。\n"
"これらのコマンドは、何らかのイベントの結果としてトリガーされることもあるで"
"しょう。\n"
"例えば、ユーザーがボタンを押した時や、データパケットが到着した時などのよう"
"に。\n"
"また他に、これらのコマンドはアンドゥ可能であるかもしれません。これはエディ"
"ターの操作などに役立つでしょう。\n"
"また実行したコマンドのログを保存しておき、後でシステムがクラッシュしたときに"
"その変更を再適用できるようにしておきたいこともあるでしょう。"

#: src/patterns/behavioural/command.md:20
msgid ""
"Define two database operations `create table` and `add field`. Each of "
"these\n"
"operations is a command which knows how to undo the command, e.g., `drop "
"table`\n"
"and `remove field`. When a user invokes a database migration operation then "
"each\n"
"command is executed in the defined order, and when the user invokes the "
"rollback\n"
"operation then the whole set of commands is invoked in reverse order."
msgstr ""
"`create table` と `add field` の2つのデータベース操作を定義します。これらの操"
"作はそれぞれ\n"
"これらの操作はそれぞれ、そのコマンドをアンドゥする方法(例えば `drop table` "
"と `remove field` )が分かっているコマンドです。\n"
"ユーザがデータベースの移行操作を実行すると、各コマンドが定義された順序で実行"
"され、\n"
"またロールバック操作を実行すると、コマンド一式が逆の順序で実行されます。"

#: src/patterns/behavioural/command.md:26
msgid "## Approach: Using trait objects"
msgstr "## アプローチ：トレイトオブジェクトの使用"

#: src/patterns/behavioural/command.md:28
msgid ""
"We define a common trait which encapsulates our command with two operations\n"
"`execute` and `rollback`. All command `structs` must implement this trait."
msgstr ""
"`execute` と `rollback` の2つの操作を持つコマンドをカプセル化する共通のトレイ"
"トを定義します。\n"
"すべてのコマンドの `struct` はこのトレイトを実装しなければなりません。"

#: src/patterns/behavioural/command.md:31
msgid ""
"```rust\n"
"pub trait Migration {\n"
"    fn execute(&self) -> &str;\n"
"    fn rollback(&self) -> &str;\n"
"}\n"
"\n"
"pub struct CreateTable;\n"
"impl Migration for CreateTable {\n"
"    fn execute(&self) -> &str {\n"
"        \"create table\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"drop table\"\n"
"    }\n"
"}\n"
"\n"
"pub struct AddField;\n"
"impl Migration for AddField {\n"
"    fn execute(&self) -> &str {\n"
"        \"add field\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"remove field\"\n"
"    }\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Box<dyn Migration>>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"\n"
"    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
"        self.commands.push(cmd);\n"
"    }\n"
"\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev() // reverse iterator's direction\n"
"            .map(|cmd| cmd.rollback())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"\n"
"    let cmd = Box::new(CreateTable);\n"
"    schema.add_migration(cmd);\n"
"    let cmd = Box::new(AddField);\n"
"    schema.add_migration(cmd);\n"
"\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub trait Migration {\n"
"    fn execute(&self) -> &str;\n"
"    fn rollback(&self) -> &str;\n"
"}\n"
"\n"
"pub struct CreateTable;\n"
"impl Migration for CreateTable {\n"
"    fn execute(&self) -> &str {\n"
"        \"create table\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"drop table\"\n"
"    }\n"
"}\n"
"\n"
"pub struct AddField;\n"
"impl Migration for AddField {\n"
"    fn execute(&self) -> &str {\n"
"        \"add field\"\n"
"    }\n"
"    fn rollback(&self) -> &str {\n"
"        \"remove field\"\n"
"    }\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Box<dyn Migration>>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"\n"
"    fn add_migration(&mut self, cmd: Box<dyn Migration>) {\n"
"        self.commands.push(cmd);\n"
"    }\n"
"\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.commands.iter().map(|cmd| cmd.execute()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev() // イテレータを逆順に\n"
"            .map(|cmd| cmd.rollback())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"\n"
"    let cmd = Box::new(CreateTable);\n"
"    schema.add_migration(cmd);\n"
"    let cmd = Box::new(AddField);\n"
"    schema.add_migration(cmd);\n"
"\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:95
msgid "## Approach: Using function pointers"
msgstr "## アプローチ：関数ポインタの使用"

#: src/patterns/behavioural/command.md:97
msgid ""
"We could follow another approach by creating each individual command as\n"
"a different function and store function pointers to invoke these functions "
"later\n"
"at a different time. Since function pointers implement all three traits "
"`Fn`,\n"
"`FnMut`, and `FnOnce` we could as well pass and store closures instead of\n"
"function pointers."
msgstr ""
"他のアプローチとして、個々のコマンドを別個の関数として作成し、関数ポインタを"
"格納、後でこれらの関数を別の時間に呼び出す方法があります。\n"
"関数ポインタは `Fn` 、 `FnMut` 、 `FnOnce` の3つのトレイトを実装しているの"
"で、関数ポインタの代わりにクロージャを渡して格納することもできます。"

#: src/patterns/behavioural/command.md:103
msgid ""
"```rust\n"
"type FnPtr = fn() -> String;\n"
"struct Command {\n"
"    execute: FnPtr,\n"
"    rollback: FnPtr,\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Command>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
"        self.commands.push(Command { execute, rollback });\n"
"    }\n"
"    fn execute(&self) -> Vec<String> {\n"
"        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<String> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev()\n"
"            .map(|cmd| (cmd.rollback)())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> String {\n"
"    \"add field\".to_string()\n"
"}\n"
"\n"
"fn remove_field() -> String {\n"
"    \"remove field\".to_string()\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\".to_string(), || \"drop table\"."
"to_string());\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"type FnPtr = fn() -> String;\n"
"struct Command {\n"
"    execute: FnPtr,\n"
"    rollback: FnPtr,\n"
"}\n"
"\n"
"struct Schema {\n"
"    commands: Vec<Command>,\n"
"}\n"
"\n"
"impl Schema {\n"
"    fn new() -> Self {\n"
"        Self { commands: vec![] }\n"
"    }\n"
"    fn add_migration(&mut self, execute: FnPtr, rollback: FnPtr) {\n"
"        self.commands.push(Command { execute, rollback });\n"
"    }\n"
"    fn execute(&self) -> Vec<String> {\n"
"        self.commands.iter().map(|cmd| (cmd.execute)()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<String> {\n"
"        self.commands\n"
"            .iter()\n"
"            .rev()\n"
"            .map(|cmd| (cmd.rollback)())\n"
"            .collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> String {\n"
"    \"add field\".to_string()\n"
"}\n"
"\n"
"fn remove_field() -> String {\n"
"    \"remove field\".to_string()\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\".to_string(), || \"drop table\"."
"to_string());\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:150
msgid "## Approach: Using `Fn` trait objects"
msgstr "## アプローチ： `Fn` トレイトオブジェクトの使用"

#: src/patterns/behavioural/command.md:152
msgid ""
"Finally, instead of defining a common command trait we could store\n"
"each command implementing the `Fn` trait separately in vectors."
msgstr ""
"最後に、共通のコマンドのトレイトを定義する代わりに、個々に `Fn` トレイトを実"
"装した各コマンドをベクタに格納することができます。"

#: src/patterns/behavioural/command.md:155
msgid ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"type Migration<'a> = Box<dyn Fn() -> &'a str>;\n"
"\n"
"struct Schema<'a> {\n"
"    executes: Vec<Migration<'a>>,\n"
"    rollbacks: Vec<Migration<'a>>,\n"
"}\n"
"\n"
"impl<'a> Schema<'a> {\n"
"    fn new() -> Self {\n"
"        Self {\n"
"            executes: vec![],\n"
"            rollbacks: vec![],\n"
"        }\n"
"    }\n"
"    fn add_migration<E, R>(&mut self, execute: E, rollback: R)\n"
"    where\n"
"        E: Fn() -> &'a str + 'static,\n"
"        R: Fn() -> &'a str + 'static,\n"
"    {\n"
"        self.executes.push(Box::new(execute));\n"
"        self.rollbacks.push(Box::new(rollback));\n"
"    }\n"
"    fn execute(&self) -> Vec<&str> {\n"
"        self.executes.iter().map(|cmd| cmd()).collect()\n"
"    }\n"
"    fn rollback(&self) -> Vec<&str> {\n"
"        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()\n"
"    }\n"
"}\n"
"\n"
"fn add_field() -> &'static str {\n"
"    \"add field\"\n"
"}\n"
"\n"
"fn remove_field() -> &'static str {\n"
"    \"remove field\"\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut schema = Schema::new();\n"
"    schema.add_migration(|| \"create table\", || \"drop table\");\n"
"    schema.add_migration(add_field, remove_field);\n"
"    assert_eq!(vec![\"create table\", \"add field\"], schema.execute());\n"
"    assert_eq!(vec![\"remove field\", \"drop table\"], schema.rollback());\n"
"}\n"
"```"

#: src/patterns/behavioural/command.md:205
msgid ""
"If our commands are small and may be defined as functions or passed as a "
"closure\n"
"then using function pointers might be preferable since it does not exploit\n"
"dynamic dispatch. But if our command is a whole struct with a bunch of "
"functions\n"
"and variables defined as seperated module then using trait objects would be\n"
"more suitable. A case of application can be found in [`actix`](https://actix."
"rs/),\n"
"which uses trait objects when it registers a handler function for routes.\n"
"In case of using `Fn` trait objects we can create and use commands in the "
"same\n"
"way as we used in case of function pointers."
msgstr ""
"コマンドが小さく、関数として定義されたり、クロージャとして渡されたりするので"
"あれば、関数ポインタを使うのが望ましいでしょう。\n"
"動的ディスパッチを濫用せずに済みます。\n"
"しかし、コマンドが、別のモジュールに定義されている関数や変数の多い構造体全体"
"である場合は、 トレイトオブジェクトを使用するのが望ましいでしょう。\n"
"その応用例が [`actix`](https://actix.rs/) です。これは、ルート用のハンドラ関"
"数を登録するときにトレイトオブジェクトを使用しています。\n"
"`Fn` トレイトオブジェクトを使用する場合、関数ポインタを使用するの場合と同じよ"
"うにコマンドを作成して使用することができます。"

#: src/patterns/behavioural/command.md:214
msgid ""
"As performance, there is always a trade-off between performance and code\n"
"simplicity and organisation. Static dispatch gives faster performance, "
"while\n"
"dynamic dispatch provides flexibility when we structure our application."
msgstr ""
"パフォーマンスとコードのシンプルさと秩序の間には常にトレードオフがありま"
"す。\n"
"静的ディスパッチはより高速なパフォーマンスをもたらしますが、\n"
"動的ディスパッチはアプリケーションを構成する際に柔軟性をもたらします。"

#: src/patterns/behavioural/command.md:220
msgid ""
"- [Command pattern](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [Another example for the `command` pattern](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"
msgstr ""
"- [Command pattern](https://en.wikipedia.org/wiki/Command_pattern)\n"
"\n"
"- [`command` パターンのもう一つの例](https://web.archive.org/"
"web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)"

#: src/patterns/behavioural/interpreter.md:1
msgid "# Interpreter"
msgstr "# Interpreter"

#: src/patterns/behavioural/interpreter.md:5
msgid ""
"If a problem occurs very often and requires long and repetitive steps to "
"solve\n"
"it, then the problem instances might be expressed in a simple language and "
"an\n"
"interpreter object could solve it by interpreting the sentences written in "
"this\n"
"simple language."
msgstr ""
"ある問題が非常に頻繁に発生し、その解決に長く反復的な手順を必要とする場合、\n"
"その問題のインスタンスは単純な言語で表現可能であり、インタープリタ・オブジェ"
"クトがこの言語による記述を解釈するという形で解決可能であるかもしれません。"

#: src/patterns/behavioural/interpreter.md:10
msgid "Basically, for any kind of problems we define:"
msgstr "基本的に、あらゆる種類の問題に対して、以下定義します："

#: src/patterns/behavioural/interpreter.md:12
msgid ""
"- A [domain specific language](https://en.wikipedia.org/wiki/Domain-"
"specific_language),\n"
"- A grammar for this language,\n"
"- An interpreter that solves the problem instances."
msgstr ""
"- [ドメイン固有言語](https://en.wikipedia.org/wiki/Domain-"
"specific_language)、\n"
"- この言語のための文法、\n"
"- 問題インスタンスを解決するインタプリタ。"

#: src/patterns/behavioural/interpreter.md:18
msgid ""
"Our goal is to translate simple mathematical expressions into postfix "
"expressions\n"
"(or [Reverse Polish notation](https://en.wikipedia.org/wiki/"
"Reverse_Polish_notation))\n"
"For simplicity, our expressions consist of ten digits `0`, ..., `9` and two\n"
"operations `+`, `-`. For example, the expression `2 + 4` is translated into\n"
"`2 4 +`."
msgstr ""
"私たちの目標は、簡単な数式を後置記法([逆ポーランド記法](https://en.wikipedia."
"org/wiki/Reverse_Polish_notation)ともに変換することです。\n"
"簡略にするため、式は10桁の数字 `0`, ..., `9` と2つの演算 `+`, `-` で構成され"
"るとします。\n"
"例えば `2 + 4` という式は `2 4 +` に変換されます。"

#: src/patterns/behavioural/interpreter.md:24
msgid "## Context Free Grammar for our problem"
msgstr "## 私たちの問題に対する文脈自由文法"

#: src/patterns/behavioural/interpreter.md:26
msgid ""
"Our task is translating infix expressions into postfix ones. Let's define a "
"context\n"
"free grammar for a set of infix expressions over `0`, ..., `9`, `+`, and `-"
"`,\n"
"where:"
msgstr ""
"私たちのタスクは中置記法を後置記法に変換することです。\n"
"`0`, ..., `9`, `+`, `-` に対応する中置記法の式の集合に対して文脈自由文法を以"
"下に定義します："

#: src/patterns/behavioural/interpreter.md:30
msgid ""
"- Terminal symbols: `0`, `...`, `9`, `+`, `-`\n"
"- Non-terminal symbols: `exp`, `term`\n"
"- Start symbol is `exp`\n"
"- And the following are production rules"
msgstr ""
"- 終端記号：`0`, `...`, `9`, `+`, `-`\n"
"- 非終端記号：exp`, `term`\n"
"- 開始記号は `exp` です\n"
"- そして以下がプロダクションルールです"

#: src/patterns/behavioural/interpreter.md:35
msgid ""
"```ignore\n"
"exp -> exp + term\n"
"exp -> exp - term\n"
"exp -> term\n"
"term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
"```"
msgstr ""
"```ignore\n"
"exp -> exp + term\n"
"exp -> exp - term\n"
"exp -> term\n"
"term -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n"
"```"

#: src/patterns/behavioural/interpreter.md:42
msgid ""
"**NOTE:** This grammar should be further transformed depending on what we "
"are going\n"
"to do with it. For example, we might need to remove left recursion. For "
"more\n"
"details please see [Compilers: Principles,Techniques, and Tools](https://en."
"wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)\n"
"(aka Dragon Book)."
msgstr ""
"**注：** この文法は、これによって私たちが何をしようとしているかによって、さら"
"に変形されるべきです。\n"
"例えば、左再帰を削除する必要があるかもしれません。詳しくは[Compilers: "
"Principles,Techniques, and Tools](https://en.wikipedia.org/wiki/Compilers:"
"_Principles,_Techniques,_and_Tools) (別名 Dragon Book)を参照してください。"

#: src/patterns/behavioural/interpreter.md:47
msgid "## Solution"
msgstr "## ソリューション"

#: src/patterns/behavioural/interpreter.md:49
msgid ""
"We simply implement a recursive descent parser. For simplicity's sake, the "
"code\n"
"panics when an expression is syntactically wrong (for example `2-34` or `2+5-"
"`\n"
"are wrong according to the grammar definition)."
msgstr ""
"再帰降下パーサを実装するだけです。\n"
"簡略にするために、構文的に誤った式があればコードはパニックします(例えば、 "
"`2-34` や `2+5-` は文法定義に照らすと誤りです)。"

#: src/patterns/behavioural/interpreter.md:53
msgid ""
"```rust\n"
"pub struct Interpreter<'a> {\n"
"    it: std::str::Chars<'a>,\n"
"}\n"
"\n"
"impl<'a> Interpreter<'a> {\n"
"\n"
"    pub fn new(infix: &'a str) -> Self {\n"
"        Self { it: infix.chars() }\n"
"    }\n"
"\n"
"    fn next_char(&mut self) -> Option<char> {\n"
"        self.it.next()\n"
"    }\n"
"\n"
"    pub fn interpret(&mut self, out: &mut String) {\n"
"        self.term(out);\n"
"\n"
"        while let Some(op) = self.next_char() {\n"
"            if op == '+' || op == '-' {\n"
"                self.term(out);\n"
"                out.push(op);\n"
"            } else {\n"
"                panic!(\"Unexpected symbol '{}'\", op);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    fn term(&mut self, out: &mut String) {\n"
"        match self.next_char() {\n"
"            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
"            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
"            None => panic!(\"Unexpected end of string\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let mut intr = Interpreter::new(\"2+3\");\n"
"    let mut postfix = String::new();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"23+\");\n"
"\n"
"    intr = Interpreter::new(\"1-2+3-4\");\n"
"    postfix.clear();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"12-3+4-\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"pub struct Interpreter<'a> {\n"
"    it: std::str::Chars<'a>,\n"
"}\n"
"\n"
"impl<'a> Interpreter<'a> {\n"
"\n"
"    pub fn new(infix: &'a str) -> Self {\n"
"        Self { it: infix.chars() }\n"
"    }\n"
"\n"
"    fn next_char(&mut self) -> Option<char> {\n"
"        self.it.next()\n"
"    }\n"
"\n"
"    pub fn interpret(&mut self, out: &mut String) {\n"
"        self.term(out);\n"
"\n"
"        while let Some(op) = self.next_char() {\n"
"            if op == '+' || op == '-' {\n"
"                self.term(out);\n"
"                out.push(op);\n"
"            } else {\n"
"                panic!(\"Unexpected symbol '{}'\", op);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    fn term(&mut self, out: &mut String) {\n"
"        match self.next_char() {\n"
"            Some(ch) if ch.is_digit(10) => out.push(ch),\n"
"            Some(ch) => panic!(\"Unexpected symbol '{}'\", ch),\n"
"            None => panic!(\"Unexpected end of string\"),\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"pub fn main() {\n"
"    let mut intr = Interpreter::new(\"2+3\");\n"
"    let mut postfix = String::new();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"23+\");\n"
"\n"
"    intr = Interpreter::new(\"1-2+3-4\");\n"
"    postfix.clear();\n"
"    intr.interpret(&mut postfix);\n"
"    assert_eq!(postfix, \"12-3+4-\");\n"
"}\n"
"```"

#: src/patterns/behavioural/interpreter.md:105
msgid ""
"There may be a wrong perception that the Interpreter design pattern is about "
"design\n"
"grammars for formal languages and implementation of parsers for these "
"grammars.\n"
"In fact, this pattern is about expressing problem instances in a more "
"specific\n"
"way and implementing functions/classes/structs that solve these problem "
"instances.\n"
"Rust language has `macro_rules!` that allow us to define special syntax and "
"rules\n"
"on how to expand this syntax into source code."
msgstr ""
"Interpreter デザインパターンに対して「形式言語の文法を設計し、その文法に対応"
"したパーサの実装することである」という誤った認識があるかもしれません。\n"
"実際には、このパターンは問題インスタンスをより具体的に表現し、その問題インス"
"タンスを解決する関数/クラス/構造を実装するというものです。\n"
"Rust には `macro_rules!` があり、これにより特別な構文と、この構文をソースコー"
"ドへ展開するためのルールを定義することができます。"

#: src/patterns/behavioural/interpreter.md:112
msgid ""
"In the following example we create a simple `macro_rules!` that computes\n"
"[Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) of `n`\n"
"dimensional vectors. Writing `norm!(x,1,2)` might be easier to express and "
"more\n"
"efficient than packing `x,1,2` into a `Vec` and calling a function "
"computing\n"
"the length."
msgstr ""
"次の例では、 `n` 次元ベクタの[ユークリッド距離](https://en.wikipedia.org/"
"wiki/Euclidean_distance) を計算する、単純な `macro_rules!` を作成します。\n"
"`norm!(x,1,2)` と記述するのは、 `x,1,2` を `Vec` に詰め込んで、距離を計算する"
"関数を呼び出すよりも表現が簡単で効率的です。"

#: src/patterns/behavioural/interpreter.md:118
msgid ""
"```rust\n"
"macro_rules! norm {\n"
"    ($($element:expr),*) => {\n"
"        {\n"
"            let mut n = 0.0;\n"
"            $(\n"
"                n += ($element as f64)*($element as f64);\n"
"            )*\n"
"            n.sqrt()\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -3f64;\n"
"    let y = 4f64;\n"
"\n"
"    assert_eq!(3f64, norm!(x));\n"
"    assert_eq!(5f64, norm!(x, y));\n"
"    assert_eq!(0f64, norm!(0, 0, 0)); \n"
"    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"macro_rules! norm {\n"
"    ($($element:expr),*) => {\n"
"        {\n"
"            let mut n = 0.0;\n"
"            $(\n"
"                n += ($element as f64)*($element as f64);\n"
"            )*\n"
"            n.sqrt()\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"fn main() {\n"
"    let x = -3f64;\n"
"    let y = 4f64;\n"
"\n"
"    assert_eq!(3f64, norm!(x));\n"
"    assert_eq!(5f64, norm!(x, y));\n"
"    assert_eq!(0f64, norm!(0, 0, 0)); \n"
"    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));\n"
"}\n"
"```"

#: src/patterns/behavioural/interpreter.md:144
msgid ""
"- [Interpreter pattern](https://en.wikipedia.org/wiki/Interpreter_pattern)\n"
"- [Context free grammar](https://en.wikipedia.org/wiki/Context-"
"free_grammar)\n"
"- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"
msgstr ""
"- [Interpreter パターン](https://en.wikipedia.org/wiki/Interpreter_pattern)\n"
"- [文脈自由文法](https://en.wikipedia.org/wiki/Context-free_grammar)\n"
"- [macro_rules!](https://doc.rust-lang.org/rust-by-example/macros.html)"

#: src/patterns/behavioural/newtype.md:1
msgid "# Newtype"
msgstr "# Newtype"

#: src/patterns/behavioural/newtype.md:3
msgid ""
"What if in some cases we want a type to behave similar to another type or\n"
"enforce some behaviour at compile time when using only type aliases would\n"
"not be enough?"
msgstr ""
"ある型に別の型と似たような振る舞いをさせたり、コンパイル時にある振る舞いを強"
"制させたりしたいが、\n"
"型エイリアスだけでは不十分な場合どのようにすればよいでしょうか？"

#: src/patterns/behavioural/newtype.md:7
msgid ""
"For example, if we want to create a custom `Display` implementation for "
"`String`\n"
"due to security considerations (e.g. passwords)."
msgstr ""
"例えば、セキュリティを考慮(パスワード等)して、`String` に対しカスタムした "
"`Display` の実装を作成したい場合があります。"

#: src/patterns/behavioural/newtype.md:10
msgid ""
"For such cases we could use the `Newtype` pattern to provide **type "
"safety**\n"
"and **encapsulation**."
msgstr ""
"このような場合、 `Newtype` パターンを使うことで、 **型の安全性** と **カプセ"
"ル化** を提供できます。"

#: src/patterns/behavioural/newtype.md:15
msgid ""
"Use a tuple struct with a single field to make an opaque wrapper for a "
"type.\n"
"This creates a new type, rather than an alias to a type (`type` items)."
msgstr ""
"単一のフィールドを持つタプル構造体を使用して、型の不透明なラッパーを作成しま"
"す。\n"
"これは、型のエイリアス (`type` によるもの) ではなく、新しい型を作成します。"

#: src/patterns/behavioural/newtype.md:20
msgid ""
"```rust\n"
"use std::fmt::Display;\n"
"\n"
"// Create Newtype Password to override the Display trait for String\n"
"struct Password(String);\n"
"\n"
"impl Display for Password {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"****************\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let unsecured_password: String = \"ThisIsMyPassword\".to_string();\n"
"    let secured_password: Password = Password(unsecured_password.clone());\n"
"    println!(\"unsecured_password: {unsecured_password}\");\n"
"    println!(\"secured_password: {secured_password}\");\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::fmt::Display;\n"
"\n"
"// String の Display トレイト をオーバライドするため、新しい型の Password を"
"作成\n"
"struct Password(String);\n"
"\n"
"impl Display for Password {\n"
"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n"
"        write!(f, \"****************\")\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let unsecured_password: String = \"ThisIsMyPassword\".to_string();\n"
"    let secured_password: Password = Password(unsecured_password.clone());\n"
"    println!(\"unsecured_password: {unsecured_password}\");\n"
"    println!(\"secured_password: {secured_password}\");\n"
"}\n"
"```"

#: src/patterns/behavioural/newtype.md:40
msgid ""
"```shell\n"
"unsecured_password: ThisIsMyPassword\n"
"secured_password: ****************\n"
"```"
msgstr ""
"```shell\n"
"unsecured_password: ThisIsMyPassword\n"
"secured_password: ****************\n"
"```"

#: src/patterns/behavioural/newtype.md:47
msgid ""
"The primary motivation for newtypes is abstraction. It allows you to share\n"
"implementation details between types while precisely controlling the "
"interface.\n"
"By using a newtype rather than exposing the implementation type as part of "
"an\n"
"API, it allows you to change implementation backwards compatibly."
msgstr ""
"ニュータイプの主な動機は抽象化です。これによってインタフェースを正確に制御し"
"ながら、型間で実装の詳細を共有することができます。\n"
"実装型をAPIの一部としてさらけ出すのではなく、 newtype を使うことで、後方互換"
"性を保ったまま実装を変更することができます。"

#: src/patterns/behavioural/newtype.md:52
msgid ""
"Newtypes can be used for distinguishing units, e.g., wrapping `f64` to give\n"
"distinguishable `Miles` and `Kilometres`."
msgstr ""
"newtype は単位を区別するために使用できます。\n"
"例えば `f64` をラップすることで、`Miles` と `Kilometers` を区別します。"

#: src/patterns/behavioural/newtype.md:57
msgid ""
"The wrapped and wrapper types are not type compatible (as opposed to using\n"
"`type`), so users of the newtype will never 'confuse' the wrapped and "
"wrapper\n"
"types."
msgstr ""
"ラップ対象の型とラップする側の型の間には、(`type` を使うのとは対照的に)型互換"
"性はありません。\n"
"そのため、 newtype のユーザがこれらの型を「混同」することはありません。"

#: src/patterns/behavioural/newtype.md:61
msgid "Newtypes are a zero-cost abstraction - there is no runtime overhead."
msgstr "newtype はゼロコスト抽象化です。実行時のオーバーヘッドはありません。"

#: src/patterns/behavioural/newtype.md:63
msgid ""
"The privacy system ensures that users cannot access the wrapped type (if "
"the\n"
"field is private, which it is by default)."
msgstr ""
"プライバシーシステムは、 ユーザがラップされた型にアクセスできないことを保証し"
"ます(フィールドがprivateである場合。既定では private)。"

#: src/patterns/behavioural/newtype.md:68
msgid ""
"The downside of newtypes (especially compared with type aliases), is that "
"there\n"
"is no special language support. This means there can be _a lot_ of "
"boilerplate.\n"
"You need a 'pass through' method for every method you want to expose on the\n"
"wrapped type, and an impl for every trait you want to also be implemented "
"for\n"
"the wrapper type."
msgstr ""
"newtype の欠点は（特に型のエイリアスと比べて）、特別な言語サポートがないこと"
"です。\n"
"特別な言語サポートがないことです。つまり、 _多くのボイラーテンプレート_ が必"
"要になります。\n"
"ラップされた型にて公開したいメソッドには「パススルー」メソッドが必要です。ま"
"たラップされた型に実装したいトレイトについても同様です。"

#: src/patterns/behavioural/newtype.md:76
msgid ""
"Newtypes are very common in Rust code. Abstraction or representing units are "
"the\n"
"most common uses, but they can be used for other reasons:"
msgstr ""
"Rustのコードでは、newtype がよく使われます。\n"
"抽象化や単位の表現が最も一般的な使用法ですが、その他の理由でも使用できます："

#: src/patterns/behavioural/newtype.md:79
msgid ""
"- restricting functionality (reduce the functions exposed or traits "
"implemented),\n"
"- making a type with copy semantics have move semantics,\n"
"- abstraction by providing a more concrete type and thus hiding internal "
"types,\n"
"  e.g.,"
msgstr ""
"- 機能の制限(公開される関数や実装されるトレイトを減らす)、\n"
"- コピー・セマンティクスを持つ型にムーブ・セマンティクスを持たせること、\n"
"- より具象的な型を提供することで内部型を隠すことによる抽象化、\n"
"  例えば、"

#: src/patterns/behavioural/newtype.md:84
msgid ""
"```rust,ignore\n"
"pub struct Foo(Bar<T1, T2>);\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub struct Foo(Bar<T1, T2>);\n"
"```"

#: src/patterns/behavioural/newtype.md:88
msgid ""
"Here, `Bar` might be some public, generic type and `T1` and `T2` are some "
"internal\n"
"types. Users of our module shouldn't know that we implement `Foo` by using a "
"`Bar`,\n"
"but what we're really hiding here is the types `T1` and `T2`, and how they "
"are used\n"
"with `Bar`."
msgstr ""
"ここで、`Bar` は public な汎用型であり、`T1` と `T2` は内部型です。\n"
"このモジュールのユーザは `Bar` を使って `Foo` を実装していることを知るべきで"
"はないはずです。\n"
"しかし、ここで本当に隠しているのは `T1` と `T2` という型であり、それらが "
"`Bar` でどのように使われているかということです。"

#: src/patterns/behavioural/newtype.md:95
msgid ""
"- [Advanced Types in the book](https://doc.rust-lang.org/book/ch19-04-"
"advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-"
"safety-and-abstraction)\n"
"- [Newtypes in Haskell](https://wiki.haskell.org/Newtype)\n"
"- [Type aliases](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
"types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more), a crate for deriving "
"many\n"
"  builtin traits on newtypes.\n"
"- [The Newtype Pattern In Rust](https://web.archive.org/web/20230519162111/"
"https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html)"
msgstr ""
"- [Book 内の Advanced Types](https://doc.rust-lang.org/book/ch19-04-advanced-"
"types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-"
"abstraction)\n"
"- [Haskell における newtype](https://wiki.haskell.org/Newtype)\n"
"- [型のエイリアス](https://doc.rust-lang.org/stable/book/ch19-04-advanced-"
"types.html#creating-type-synonyms-with-type-aliases)\n"
"- [derive_more](https://crates.io/crates/derive_more)。\n"
"  newtype に多くのビルドインのトレイトを派生させる crate。\n"
"- [The Newtype Pattern in Rust](https://www.worthe-it.co.za/blog/2020-10-31-"
"newtype-pattern-in-rust.html)"

#: src/patterns/behavioural/RAII.md:1
msgid "# RAII with guards"
msgstr "# ガード付きRAII"

#: src/patterns/behavioural/RAII.md:5
msgid ""
"[RAII][wikipedia] stands for \"Resource Acquisition is Initialisation\" "
"which is a\n"
"terrible name. The essence of the pattern is that resource initialisation is "
"done\n"
"in the constructor of an object and finalisation in the destructor. This "
"pattern\n"
"is extended in Rust by using a RAII object as a guard of some resource and "
"relying\n"
"on the type system to ensure that access is always mediated by the guard "
"object."
msgstr ""
"[RAII][wikipedia]は「Resource Acquisition is Initialisation」の略です。・・・"
"ひどい名前です。\n"
"このパターンの本質は、リソースの初期化をオブジェクトのコンストラクタで行い、"
"ファイナライズをデストラクタで行うというものです。\n"
"RAIIオブジェクトをリソースのガードとして使い、またアクセスが常にガードオブ"
"ジェクトを介することを保証するために型システムに依存することで、Rustではこの"
"パターンが拡張されます。"

#: src/patterns/behavioural/RAII.md:13
msgid ""
"Mutex guards are the classic example of this pattern from the std library "
"(this\n"
"is a simplified version of the real implementation):"
msgstr ""
"ミューテックスのガードは、stdライブラリにあるこのパターンの典型的な例です（こ"
"れは実際の実装を簡略化したものです）："

#: src/patterns/behavioural/RAII.md:16
msgid ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"struct Mutex<T> {\n"
"    // We keep a reference to our data: T here.\n"
"    //..\n"
"}\n"
"\n"
"struct MutexGuard<'a, T: 'a> {\n"
"    data: &'a T,\n"
"    //..\n"
"}\n"
"\n"
"// Locking the mutex is explicit.\n"
"impl<T> Mutex<T> {\n"
"    fn lock(&self) -> MutexGuard<T> {\n"
"        // Lock the underlying OS mutex.\n"
"        //..\n"
"\n"
"        // MutexGuard keeps a reference to self\n"
"        MutexGuard {\n"
"            data: self,\n"
"            //..\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Destructor for unlocking the mutex.\n"
"impl<'a, T> Drop for MutexGuard<'a, T> {\n"
"    fn drop(&mut self) {\n"
"        // Unlock the underlying OS mutex.\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"// Implementing Deref means we can treat MutexGuard like a pointer to T.\n"
"impl<'a, T> Deref for MutexGuard<'a, T> {\n"
"    type Target = T;\n"
"\n"
"    fn deref(&self) -> &T {\n"
"        self.data\n"
"    }\n"
"}\n"
"\n"
"fn baz(x: Mutex<Foo>) {\n"
"    let xx = x.lock();\n"
"    xx.foo(); // foo is a method on Foo.\n"
"    // The borrow checker ensures we can't store a reference to the "
"underlying\n"
"    // Foo which will outlive the guard xx.\n"
"\n"
"    // x is unlocked when we exit this function and xx's destructor is "
"executed.\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"struct Mutex<T> {\n"
"    // ここでデータ T への参照を保持します\n"
"    //..\n"
"}\n"
"\n"
"struct MutexGuard<'a, T: 'a> {\n"
"    data: &'a T,\n"
"    //..\n"
"}\n"
"\n"
"// ミューテックスのロックは明示的です\n"
"impl<T> Mutex<T> {\n"
"    fn lock(&self) -> MutexGuard<T> {\n"
"        // OSのミューテックスをロックします\n"
"        //..\n"
"\n"
"        // MutexGuard は self の参照を保持します\n"
"        MutexGuard {\n"
"            data: self,\n"
"            //..\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// ミューテックスをアンロックするためのデストラクタ\n"
"impl<'a, T> Drop for MutexGuard<'a, T> {\n"
"    fn drop(&mut self) {\n"
"        // Unlock the underlying OS mutex.\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"// Deref を MutexGuard に実装し T へのポインタのように扱えるようにします\n"
"impl<'a, T> Deref for MutexGuard<'a, T> {\n"
"    type Target = T;\n"
"\n"
"    fn deref(&self) -> &T {\n"
"        self.data\n"
"    }\n"
"}\n"
"\n"
"fn baz(x: Mutex<Foo>) {\n"
"    let xx = x.lock();\n"
"    xx.foo(); // foo は Foo のメソッドです\n"
"    // 借用チェッカーは、ガードの xx よりも生存期間が長い Foo への参照を保持"
"できないことを保証します\n"
"\n"
"    // 関数が終了し、 xx のデストラクタが実行されると、 x がアンロックされま"
"す\n"
"}\n"
"```"

#: src/patterns/behavioural/RAII.md:74
msgid ""
"Where a resource must be finalised after use, RAII can be used to do this\n"
"finalisation. If it is an error to access that resource after finalisation, "
"then\n"
"this pattern can be used to prevent such errors."
msgstr ""
"リソースの使用後にファイナライズが必要な場合、RAIIを使用してファイナライズを"
"行うことができます。\n"
"ファイナライズ後にリソースにアクセスすることがエラーとなる場合、このパターン"
"はそのようなエラーを防ぐことに使用できます。"

#: src/patterns/behavioural/RAII.md:80
msgid ""
"Prevents errors where a resource is not finalised and where a resource is "
"used\n"
"after finalisation."
msgstr ""
"リソースがファイナライズされない、もしくはリソースがファイナライズされた後に"
"使用されてしまう、といったエラーを防ぎます。"

#: src/patterns/behavioural/RAII.md:85
msgid ""
"RAII is a useful pattern for ensuring resources are properly deallocated or\n"
"finalised. We can make use of the borrow checker in Rust to statically "
"prevent\n"
"errors stemming from using resources after finalisation takes place."
msgstr ""
"RAIIは、リソースが適切に解放またはファイナライズされることを保証するための有"
"用なパターンです。\n"
"Rustの借用チェッカーを使用することで、ファイナライズ後にリソースを使用するこ"
"とにより生じるエラーを静的に防ぐことが可能です。"

#: src/patterns/behavioural/RAII.md:89
msgid ""
"The core aim of the borrow checker is to ensure that references to data do "
"not\n"
"outlive that data. The RAII guard pattern works because the guard object\n"
"contains a reference to the underlying resource and only exposes such\n"
"references. Rust ensures that the guard cannot outlive the underlying "
"resource\n"
"and that references to the resource mediated by the guard cannot outlive "
"the\n"
"guard. To see how this works it is helpful to examine the signature of "
"`deref`\n"
"without lifetime elision:"
msgstr ""
"借用チェッカーの主な目的は、データへの参照がそのデータ自体より長く生存しない"
"ことを保証することです。\n"
"RAIIガードパターンが機能するのは、\n"
"ガードオブジェクトが基のリソースへの参照を保持し、その参照のみを公開するから"
"です。\n"
"Rustは、ガードが、基のリソースより長く生存しないことを保証するとともに、\n"
"ガードが介するそのリソースへの参照がガードよりも長く生存しないことを保証しま"
"す。\n"
"これがどのように機能するかを見るために、ライフタイムを省略せずに `deref`のシ"
"グネチャを確かめることが助けになるでしょう："

#: src/patterns/behavioural/RAII.md:97
msgid ""
"```rust,ignore\n"
"fn deref<'a>(&'a self) -> &'a T {\n"
"    //..\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn deref<'a>(&'a self) -> &'a T {\n"
"    //..\n"
"}\n"
"```"

#: src/patterns/behavioural/RAII.md:103
msgid ""
"The returned reference to the resource has the same lifetime as `self` "
"(`'a`).\n"
"The borrow checker therefore ensures that the lifetime of the reference to "
"`T`\n"
"is shorter than the lifetime of `self`."
msgstr ""
"戻り値であるリソースへの参照は `self` (`'a`) と同じライフタイムを持ちます。\n"
"したがって、借用チェッカーは `T` への参照のライフタイムが `self` のライフタイ"
"ムよりも短いことを保証します。"

#: src/patterns/behavioural/RAII.md:107
msgid ""
"Note that implementing `Deref` is not a core part of this pattern, it only "
"makes\n"
"using the guard object more ergonomic. Implementing a `get` method on the "
"guard\n"
"works just as well."
msgstr ""
"`Deref` を実装することがこのパターンの核心部分でないことに注意してくださ"
"い。\n"
"ガードオブジェクトをより人間工学的に使えるようにするだけです。\n"
"ガードに `get` メソッドを実装しても同じように動作します。"

#: src/patterns/behavioural/RAII.md:113
msgid "[Finalisation in destructors idiom](../../idioms/dtor-finally.md)"
msgstr "[デストラクタでのファイナライズ](../../idioms/dtor-finally.md)"

#: src/patterns/behavioural/RAII.md:115
msgid ""
"RAII is a common pattern in C++: [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii),\n"
"[wikipedia][wikipedia]."
msgstr ""
"C++ではRAIIは一般的なパターン： [cppreference.com](http://en.cppreference."
"com/w/cpp/language/raii)、\n"
"[wikipedia][ウィキペディア]。"

#: src/patterns/behavioural/RAII.md:120
msgid ""
"[Style guide entry](https://doc.rust-lang.org/1.0.0/style/ownership/raii."
"html)\n"
"(currently just a placeholder)."
msgstr ""
"[Style Guidelines のエントリ](https://doc.rust-lang.org/1.0.0/style/"
"ownership/raii.html)\n"
"(現在は単なるプレースホルダ）。"

#: src/patterns/behavioural/strategy.md:1
msgid "# Strategy (aka Policy)"
msgstr "# Strategy (Polich とも)"

#: src/patterns/behavioural/strategy.md:5
msgid ""
"The [Strategy design pattern](https://en.wikipedia.org/wiki/"
"Strategy_pattern)\n"
"is a technique that enables separation of concerns.\n"
"It also allows to decouple software modules through [Dependency Inversion]"
"(https://en.wikipedia.org/wiki/Dependency_inversion_principle)."
msgstr ""
"[Strategy デザインパターン](https://en.wikipedia.org/wiki/Strategy_pattern)"
"は、関心事の分離を可能にするテクニックです。\n"
"また、[依存関係逆転の原則](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)によって、ソフトウェアモジュールを分離すること"
"も可能になります。"

#: src/patterns/behavioural/strategy.md:9
msgid ""
"The basic idea behind the Strategy pattern is that, given an algorithm "
"solving\n"
"a particular problem, we define only the skeleton of the algorithm at an "
"abstract\n"
"level, and we separate the specific algorithm’s implementation into "
"different parts."
msgstr ""
"Strategyパターンの基本的な考え方は、\n"
"ある特定の問題を解決するアルゴリズムが与えられたとき、\n"
"抽象的なレベルではアルゴリズムの骨組みだけを定義し、\n"
"具体的なアルゴリズムの実装は別の部分に分離する、というものです。"

#: src/patterns/behavioural/strategy.md:13
msgid ""
"In this way, a client using the algorithm may choose a specific "
"implementation,\n"
"while the general algorithm workflow remains the same. In other words, the "
"abstract\n"
"specification of the class does not depend on the specific implementation of "
"the\n"
"derived class, but specific implementation must adhere to the abstract "
"specification.\n"
"This is why we call it \"Dependency Inversion\"."
msgstr ""
"この方法では、アルゴリズムを使用するクライアントは、アルゴリズムの共通のワー"
"クフローをそのままに、具体的な実装を選択することが可能です。\n"
"言い換えれば、クラスの抽象的な仕様が派生クラスの具体的な実装に依存するのでは"
"なく、\n"
"具体的な実装が抽象的な仕様に従う必要があります。\n"
"これが「依存関係逆転」と呼ばれる理由です。"

#: src/patterns/behavioural/strategy.md:21
msgid ""
"Imagine we are working on a project that generates reports every month.\n"
"We need the reports to be generated in different formats (strategies), e."
"g.,\n"
"in `JSON` or `Plain Text` formats.\n"
"But things vary over time, and we don't know what kind of requirement we may "
"get\n"
"in the future. For example, we may need to generate our report in a "
"completely new\n"
"format, or just modify one of the existing formats."
msgstr ""
"私たちは毎月レポートを生成するプロジェクトに取り組んでいるとしましょう。\n"
"このレポートはさまざまな形式(ストラテジ)、例えば `JSON` や `Plain Text` な"
"ど、で生成される必要があります。\n"
"しかし、物事は時間の経過とともに変化するもので、将来どんな要求が来るかわかり"
"ません。\n"
"例えば、まったく新しい形式でレポートを生成する必要があるかもしれませんし、\n"
"あるいは既存のフォーマットの1つを変更するだけかもしれません。"

#: src/patterns/behavioural/strategy.md:30
msgid ""
"In this example our invariants (or abstractions) are `Formatter` and "
"`Report`, while `Text` and `Json` are our strategy structs. These "
"strategies\n"
"have to implement the `Formatter` trait."
msgstr ""
"この例では、 `Formatter` と `Report` が不変（または抽象）な部分であり、対し"
"て `Text` と `Json` がストラテジの構造体です。\n"
"これらのストラテジは `Formatter` トレイトを実装する必要があります。"

#: src/patterns/behavioural/strategy.md:33
msgid ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"type Data = HashMap<String, u32>;\n"
"\n"
"trait Formatter {\n"
"    fn format(&self, data: &Data, buf: &mut String);\n"
"}\n"
"\n"
"struct Report;\n"
"\n"
"impl Report {\n"
"    // Write should be used but we kept it as String to ignore error "
"handling\n"
"    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
"        // backend operations...\n"
"        let mut data = HashMap::new();\n"
"        data.insert(\"one\".to_string(), 1);\n"
"        data.insert(\"two\".to_string(), 2);\n"
"        // generate report\n"
"        g.format(&data, s);\n"
"    }\n"
"}\n"
"\n"
"struct Text;\n"
"impl Formatter for Text {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        for (k, v) in data {\n"
"            let entry = format!(\"{} {}\\n\", k, v);\n"
"            buf.push_str(&entry);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json;\n"
"impl Formatter for Json {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        buf.push('[');\n"
"        for (k, v) in data.into_iter() {\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
"            buf.push_str(&entry);\n"
"            buf.push(',');\n"
"        }\n"
"        if !data.is_empty() {\n"
"            buf.pop(); // remove extra , at the end\n"
"        }\n"
"        buf.push(']');\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut s = String::from(\"\");\n"
"    Report::generate(Text, &mut s);\n"
"    assert!(s.contains(\"one 1\"));\n"
"    assert!(s.contains(\"two 2\"));\n"
"\n"
"    s.clear(); // reuse the same buffer\n"
"    Report::generate(Json, &mut s);\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::collections::HashMap;\n"
"\n"
"type Data = HashMap<String, u32>;\n"
"\n"
"trait Formatter {\n"
"    fn format(&self, data: &Data, buf: &mut String);\n"
"}\n"
"\n"
"struct Report;\n"
"\n"
"impl Report {\n"
"    // Write を使用すべきですが、エラーハンドリングを無視するため String のま"
"まとしています\n"
"    fn generate<T: Formatter>(g: T, s: &mut String) {\n"
"        // バックエンド処理...\n"
"        let mut data = HashMap::new();\n"
"        data.insert(\"one\".to_string(), 1);\n"
"        data.insert(\"two\".to_string(), 2);\n"
"        // レポート生成\n"
"        g.format(&data, s);\n"
"    }\n"
"}\n"
"\n"
"struct Text;\n"
"impl Formatter for Text {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        for (k, v) in data {\n"
"            let entry = format!(\"{} {}\\n\", k, v);\n"
"            buf.push_str(&entry);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"struct Json;\n"
"impl Formatter for Json {\n"
"    fn format(&self, data: &Data, buf: &mut String) {\n"
"        buf.push('[');\n"
"        for (k, v) in data.into_iter() {\n"
"            let entry = format!(r#\"{{\"{}\":\"{}\"}}\"#, k, v);\n"
"            buf.push_str(&entry);\n"
"            buf.push(',');\n"
"        }\n"
"        if !data.is_empty() {\n"
"            buf.pop(); // 最後の余分な , を削除\n"
"        }\n"
"        buf.push(']');\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut s = String::from(\"\");\n"
"    Report::generate(Text, &mut s);\n"
"    assert!(s.contains(\"one 1\"));\n"
"    assert!(s.contains(\"two 2\"));\n"
"\n"
"    s.clear(); // バッファ再利用\n"
"    Report::generate(Json, &mut s);\n"
"    assert!(s.contains(r#\"{\"one\":\"1\"}\"#));\n"
"    assert!(s.contains(r#\"{\"two\":\"2\"}\"#));\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:97
msgid ""
"The main advantage is separation of concerns. For example, in this case "
"`Report`\n"
"does not know anything about specific implementations of `Json` and `Text`,\n"
"whereas the output implementations does not care about how data is "
"preprocessed,\n"
"stored, and fetched. The only thing they have to know is a specific\n"
"trait to implement and its method defining the concrete algorithm "
"implementation processing\n"
"the result, i.e., `Formatter` and `format(...)`."
msgstr ""
"主な利点は関心の分離です。\n"
"例えば、この例の `Report` は、 `Json` と `Text` の具体的な実装については何も"
"知りません。\n"
"その一方では、出力の実装はデータがどのように前処理され、保存され、フェッチさ"
"れるのか気にしません。\n"
"それらが知っていなければならないのは、実装すべき「特定のトレイト」と、結果の"
"処理を行うアルゴリズムの具体的な実装を定義している「そのメソッド」、つまり "
"`Formatter` と `format(...)` 、のみです。"

#: src/patterns/behavioural/strategy.md:106
msgid ""
"For each strategy there must be implemented at least one module, so number "
"of modules\n"
"increases with number of strategies. If there are many strategies to choose "
"from\n"
"then users have to know how strategies differ from one another."
msgstr ""
"各ストラテジ毎に少なくとも1つのモジュールが実装されることになるため、ストラテ"
"ジの数だけモジュールの数が増えます。\n"
"選択できるストラテジーがたくさんある場合、ユーザーはあるストラテジと別のスト"
"ラテジとの違いを知らなければなりません。"

#: src/patterns/behavioural/strategy.md:112
msgid ""
"In the previous example all strategies are implemented in a single file.\n"
"Ways of providing different strategies includes:"
msgstr ""
"前の例では、すべてのストラテジは1つのファイルに実装されていました。\n"
"個々のストラテジーを提供する方法には次のようなものがあります："

#: src/patterns/behavioural/strategy.md:115
msgid ""
"- All in one file (as shown in this example, similar to being separated as "
"modules)\n"
"- Separated as modules, E.g. `formatter::json` module, `formatter::text` "
"module\n"
"- Use compiler feature flags, E.g. `json` feature, `text` feature\n"
"- Separated as crates, E.g. `json` crate, `text` crate"
msgstr ""
"- 一つのファイルにまとめたもの (例で示すように。モジュールとして分離したもの"
"と似ています)\n"
"- モジュールとして分離 (例えば `formatter::json` モジュール、 `formatter::"
"text` モジュール)\n"
"- コンパイラの feature フラグを使う (例えば `json` feature、 `text` "
"feature)\n"
"- crate として分離 (例えば `json` crate、 `text` crate)"

#: src/patterns/behavioural/strategy.md:120
msgid ""
"Serde crate is a good example of the `Strategy` pattern in action. Serde "
"allows\n"
"[full customization](https://serde.rs/custom-serialization.html) of the "
"serialization\n"
"behavior by manually implementing `Serialize` and `Deserialize` traits for "
"our\n"
"type. For example, we could easily swap `serde_json` with `serde_cbor` since "
"they\n"
"expose similar methods. Having this makes the helper crate `serde_transcode` "
"much\n"
"more useful and ergonomic."
msgstr ""
"Serde crateは `Strategy` パターンが実際に使われている良い例です。\n"
"Serdeでは、型に `Serialize` と `Deserialize` を手動で実装することで、シリアラ"
"イズ動作の [フルカスタマイズ](https://serde.rs/custom-serialization.html) が"
"可能です。\n"
"例えば、似たようなメソッドを公開している `serde_json` と `serde_cbor` を簡単"
"に入れ替えることができます。\n"
"これにより、ヘルパー crate `serde_transcode` がより便利で人間工学的なものにな"
"ります。"

#: src/patterns/behavioural/strategy.md:127
msgid ""
"However, we don't need to use traits in order to design this pattern in Rust."
msgstr ""
"しかしながら、Rustでこのパターンを設計するためにトレイトを使うことは必須では"
"ありません。"

#: src/patterns/behavioural/strategy.md:129
msgid ""
"The following toy example demonstrates the idea of the Strategy pattern "
"using Rust\n"
"`closures`:"
msgstr ""
"次の単純化した例は、Rustの `closure` を使った Strategy パターンのアイデアを示"
"しています："

#: src/patterns/behavioural/strategy.md:132
msgid ""
"```rust\n"
"struct Adder;\n"
"impl Adder {\n"
"    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
"    where\n"
"        F: Fn(u8, u8) -> u8,\n"
"    {\n"
"        f(x, y)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let arith_adder = |x, y| x + y;\n"
"    let bool_adder = |x, y| {\n"
"        if x == 1 || y == 1 {\n"
"            1\n"
"        } else {\n"
"            0\n"
"        }\n"
"    };\n"
"    let custom_adder = |x, y| 2 * x + y;\n"
"\n"
"    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
"    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
"    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Adder;\n"
"impl Adder {\n"
"    pub fn add<F>(x: u8, y: u8, f: F) -> u8\n"
"    where\n"
"        F: Fn(u8, u8) -> u8,\n"
"    {\n"
"        f(x, y)\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let arith_adder = |x, y| x + y;\n"
"    let bool_adder = |x, y| {\n"
"        if x == 1 || y == 1 {\n"
"            1\n"
"        } else {\n"
"            0\n"
"        }\n"
"    };\n"
"    let custom_adder = |x, y| 2 * x + y;\n"
"\n"
"    assert_eq!(9, Adder::add(4, 5, arith_adder));\n"
"    assert_eq!(0, Adder::add(0, 0, bool_adder));\n"
"    assert_eq!(5, Adder::add(1, 3, custom_adder));\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:160
msgid "In fact, Rust already uses this idea for `Options`'s `map` method:"
msgstr ""
"実際、Rust はすでに `Options` の `map` メソッドでこのアイデアを使っています："

#: src/patterns/behavioural/strategy.md:162
msgid ""
"```rust\n"
"fn main() {\n"
"    let val = Some(\"Rust\");\n"
"\n"
"    let len_strategy = |s: &str| s.len();\n"
"    assert_eq!(4, val.map(len_strategy).unwrap());\n"
"\n"
"    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
"    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn main() {\n"
"    let val = Some(\"Rust\");\n"
"\n"
"    let len_strategy = |s: &str| s.len();\n"
"    assert_eq!(4, val.map(len_strategy).unwrap());\n"
"\n"
"    let first_byte_strategy = |s: &str| s.bytes().next().unwrap();\n"
"    assert_eq!(82, val.map(first_byte_strategy).unwrap());\n"
"}\n"
"```"

#: src/patterns/behavioural/strategy.md:176
msgid ""
"- [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [Dependency Injection](https://en.wikipedia.org/wiki/"
"Dependency_injection)\n"
"- [Policy Based Design](https://en.wikipedia.org/wiki/Modern_C+"
"+_Design#Policy-based_design)"
msgstr ""
"- [Strategy パターン](https://en.wikipedia.org/wiki/Strategy_pattern)\n"
"- [依存性の注入](https://en.wikipedia.org/wiki/Dependency_injection)\n"
"- [Policy Based Design](https://en.wikipedia.org/wiki/Modern_C+"
"+_Design#Policy-based_design)"

#: src/patterns/behavioural/visitor.md:1
msgid "# Visitor"
msgstr "# Visitor"

#: src/patterns/behavioural/visitor.md:5
msgid ""
"A visitor encapsulates an algorithm that operates over a heterogeneous\n"
"collection of objects. It allows multiple different algorithms to be "
"written\n"
"over the same data without having to modify the data (or their primary\n"
"behaviour)."
msgstr ""
"visitor は、異種のオブジェクトのコレクションを操作するアルゴリズムをカプセル"
"化します。\n"
"これにより、データ(またはその主要な振る舞い)を変更する必要なしに、同じデータ"
"に対して複数の異なるアルゴリズムを書くことができます。"

#: src/patterns/behavioural/visitor.md:10
msgid ""
"Furthermore, the visitor pattern allows separating the traversal of\n"
"a collection of objects from the operations performed on each object."
msgstr ""
"さらに、Visitor パターンでは、オブジェクトの集合の走査を、\n"
"各オブジェクトに対し実行される操作から分離することができます。"

#: src/patterns/behavioural/visitor.md:15
msgid ""
"```rust,ignore\n"
"// The data we will visit\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Expr),\n"
"        Let(Name, Expr),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract visitor\n"
"mod visit {\n"
"    use ast::*;\n"
"\n"
"    pub trait Visitor<T> {\n"
"        fn visit_name(&mut self, n: &Name) -> T;\n"
"        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
"        fn visit_expr(&mut self, e: &Expr) -> T;\n"
"    }\n"
"}\n"
"\n"
"use visit::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - walks the AST interpreting it as "
"code.\n"
"struct Interpreter;\n"
"impl Visitor<i64> for Interpreter {\n"
"    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
"    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
"        match *s {\n"
"            Stmt::Expr(ref e) => self.visit_expr(e),\n"
"            Stmt::Let(..) => unimplemented!(),\n"
"        }\n"
"    }\n"
"\n"
"    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
"        match *e {\n"
"            Expr::IntLit(n) => n,\n"
"            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + self."
"visit_expr(rhs),\n"
"            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - self."
"visit_expr(rhs),\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// visitor が処理することになるデータ\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Expr),\n"
"        Let(Name, Expr),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// visitor の抽象\n"
"mod visit {\n"
"    use ast::*;\n"
"\n"
"    pub trait Visitor<T> {\n"
"        fn visit_name(&mut self, n: &Name) -> T;\n"
"        fn visit_stmt(&mut self, s: &Stmt) -> T;\n"
"        fn visit_expr(&mut self, e: &Expr) -> T;\n"
"    }\n"
"}\n"
"\n"
"use visit::*;\n"
"use ast::*;\n"
"\n"
"// 具体的な実装例 - ASTをコードとして解釈して回る\n"
"struct Interpreter;\n"
"impl Visitor<i64> for Interpreter {\n"
"    fn visit_name(&mut self, n: &Name) -> i64 { panic!() }\n"
"    fn visit_stmt(&mut self, s: &Stmt) -> i64 {\n"
"        match *s {\n"
"            Stmt::Expr(ref e) => self.visit_expr(e),\n"
"            Stmt::Let(..) => unimplemented!(),\n"
"        }\n"
"    }\n"
"\n"
"    fn visit_expr(&mut self, e: &Expr) -> i64 {\n"
"        match *e {\n"
"            Expr::IntLit(n) => n,\n"
"            Expr::Add(ref lhs, ref rhs) => self.visit_expr(lhs) + self."
"visit_expr(rhs),\n"
"            Expr::Sub(ref lhs, ref rhs) => self.visit_expr(lhs) - self."
"visit_expr(rhs),\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/behavioural/visitor.md:69
msgid ""
"One could implement further visitors, for example a type checker, without "
"having\n"
"to modify the AST data."
msgstr ""
"ASTデータを変更することなく、さらなる visitor 、例えば型チェッカーなど、を実"
"装可能です。"

#: src/patterns/behavioural/visitor.md:74
msgid ""
"The visitor pattern is useful anywhere that you want to apply an algorithm "
"to\n"
"heterogeneous data. If data is homogeneous, you can use an iterator-like "
"pattern.\n"
"Using a visitor object (rather than a functional approach) allows the "
"visitor to\n"
"be stateful and thus communicate information between nodes."
msgstr ""
"ビジター・パターンは、異種データにアルゴリズムを適用したい場合に便利です。\n"
"データが同種であれば、イテレータのようなパターンを使うことができます。\n"
"(関数型アプローチと比較して) visitor オブジェクトを使用することにより、\n"
"visitor はステートフルになり、そのためノード間で情報を伝達することができま"
"す。"

#: src/patterns/behavioural/visitor.md:81
msgid ""
"It is common for the `visit_*` methods to return void (as opposed to in the\n"
"example). In that case it is possible to factor out the traversal code and "
"share\n"
"it between algorithms (and also to provide noop default methods). In Rust, "
"the\n"
"common way to do this is to provide `walk_*` functions for each datum. For\n"
"example,"
msgstr ""
"`visit_*` メソッドが void を返すのは(例とは異なり)一般的です。\n"
"この場合、走査コードを分離してアルゴリズム間で共有することが可能です(また、"
"noopデフォルトメソッドを提供することも可能です)。\n"
"Rustでは、データ各個に対して `walk_*` 関数を提供するのが一般的です。\n"
"例えば、"

#: src/patterns/behavioural/visitor.md:87
msgid ""
"```rust,ignore\n"
"pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
"    match *e {\n"
"        Expr::IntLit(_) => {},\n"
"        Expr::Add(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"        Expr::Sub(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub fn walk_expr(visitor: &mut Visitor, e: &Expr) {\n"
"    match *e {\n"
"        Expr::IntLit(_) => {},\n"
"        Expr::Add(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"        Expr::Sub(ref lhs, ref rhs) => {\n"
"            visitor.visit_expr(lhs);\n"
"            visitor.visit_expr(rhs);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/behavioural/visitor.md:103
msgid ""
"In other languages (e.g., Java) it is common for data to have an `accept` "
"method\n"
"which performs the same duty."
msgstr ""
"他の言語（例えばJava）では、データに対し同様の責務を担う `accept` メソッドが"
"あるのが普通です。"

#: src/patterns/behavioural/visitor.md:108
msgid "The visitor pattern is a common pattern in most OO languages."
msgstr ""
"Visitor パターンは、ほとんどのオブジェクト指向言語で一般的なパターンです。"

#: src/patterns/behavioural/visitor.md:110
msgid "[Wikipedia article](https://en.wikipedia.org/wiki/Visitor_pattern)"
msgstr "[ウィキペディア記事](https://en.wikipedia.org/wiki/Visitor_pattern)"

#: src/patterns/behavioural/visitor.md:112
msgid ""
"The [fold](../creational/fold.md) pattern is similar to visitor but "
"produces\n"
"a new version of the visited data structure."
msgstr ""
"[Fold](../creational/fold.md)パターンは Visitor に似ていますが、訪問したデー"
"タ構造の新しいバージョンを生成する点が異なります。"

#: src/patterns/creational/intro.md:1
msgid "# Creational Patterns"
msgstr "# 生成に関するパターン"

#: src/patterns/creational/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Creational_pattern)より："

#: src/patterns/creational/intro.md:5
msgid ""
"> Design patterns that deal with object creation mechanisms, trying to "
"create objects\n"
"> in a manner suitable to the situation. The basic form of object creation "
"could\n"
"> result in design problems or in added complexity to the design. Creational "
"design\n"
"> patterns solve this problem by somehow controlling this object creation."
msgstr ""
"> Design patterns that deal with object creation mechanisms, trying to "
"create objects\n"
"> in a manner suitable to the situation. The basic form of object creation "
"could\n"
"> result in design problems or in added complexity to the design. Creational "
"design\n"
"> patterns solve this problem by somehow controlling this object creation.\n"
"> (オブジェクト生成のメカニズムを扱う、状況に適した方法でオブジェクトを生成し"
"ようとするデザインパターン。\n"
"> 状況に適した方法でオブジェクト生成の基本形は設計上の問題が発生したり、設計"
"が複雑になったりします。\n"
">  生成に関するデザインパターンは、オブジェクト生成を何らかの方法で制御するこ"
"とで、この問題を解決します。)"

#: src/patterns/creational/builder.md:1
msgid "# Builder"
msgstr "# Builder"

#: src/patterns/creational/builder.md:5
msgid "Construct an object with calls to a builder helper."
msgstr "builder ヘルパの呼び出しによりオブジェクトを構築します。"

#: src/patterns/creational/builder.md:9
msgid ""
"```rust\n"
"#[derive(Debug, PartialEq)]\n"
"pub struct Foo {\n"
"    // Lots of complicated fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl Foo {\n"
"    // This method will help users to discover the builder\n"
"    pub fn builder() -> FooBuilder {\n"
"        FooBuilder::default()\n"
"    }\n"
"}\n"
"\n"
"#[derive(Default)]\n"
"pub struct FooBuilder {\n"
"    // Probably lots of optional fields.\n"
"    bar: String,\n"
"}\n"
"\n"
"impl FooBuilder {\n"
"    pub fn new(/* ... */) -> FooBuilder {\n"
"        // Set the minimally required fields of Foo.\n"
"        FooBuilder {\n"
"            bar: String::from(\"X\"),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(mut self, bar: String) -> FooBuilder {\n"
"        // Set the name on the builder itself, and return the builder by "
"value.\n"
"        self.bar = bar;\n"
"        self\n"
"    }\n"
"\n"
"    // If we can get away with not consuming the Builder here, that is an\n"
"    // advantage. It means we can use the FooBuilder as a template for "
"constructing\n"
"    // many Foos.\n"
"    pub fn build(self) -> Foo {\n"
"        // Create a Foo from the FooBuilder, applying all settings in "
"FooBuilder\n"
"        // to Foo.\n"
"        Foo { bar: self.bar }\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn builder_test() {\n"
"    let foo = Foo {\n"
"        bar: String::from(\"Y\"),\n"
"    };\n"
"    let foo_from_builder: Foo = FooBuilder::new().name(String::from(\"Y\"))."
"build();\n"
"    assert_eq!(foo, foo_from_builder);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Debug, PartialEq)]\n"
"pub struct Foo {\n"
"    // たくさんの複雑なフィールド。\n"
"    bar: String,\n"
"}\n"
"\n"
"impl Foo {\n"
"    // このメソッドは、ユーザが builder を見つけるために有用です。\n"
"    pub fn builder() -> FooBuilder {\n"
"        FooBuilder::default()\n"
"    }\n"
"}\n"
"\n"
"#[derive(Default)]\n"
"pub struct FooBuilder {\n"
"    // おそらくたくさんの Option フィールド。\n"
"    bar: String,\n"
"}\n"
"\n"
"impl FooBuilder {\n"
"    pub fn new(/* ... */) -> FooBuilder {\n"
"        // Foo の最小限必須なフィールドを設定します。\n"
"        FooBuilder {\n"
"            bar: String::from(\"X\"),\n"
"        }\n"
"    }\n"
"\n"
"    pub fn name(mut self, bar: String) -> FooBuilder {\n"
"        // builder 自身の name を設定し、builderを値として返します。\n"
"        self.bar = bar;\n"
"        self\n"
"    }\n"
"\n"
"    // ここでBuilderを消費せずに済む場合、そこにはメリットがあります。\n"
"    // それは、複数の Foo を構築するためのテンプレートとして、FooBuilder を利"
"用できることです。\n"
"    pub fn build(self) -> Foo {\n"
"        // FooBuilder の全設定を反映して Foo を構築します。\n"
"        Foo { bar: self.bar }\n"
"    }\n"
"}\n"
"\n"
"#[test]\n"
"fn builder_test() {\n"
"    let foo = Foo {\n"
"        bar: String::from(\"Y\"),\n"
"    };\n"
"    let foo_from_builder: Foo = FooBuilder::new().name(String::from(\"Y\"))."
"build();\n"
"    assert_eq!(foo, foo_from_builder);\n"
"}\n"
"```"

#: src/patterns/creational/builder.md:65
msgid ""
"Useful when you would otherwise require many constructors or where\n"
"construction has side effects."
msgstr ""
"多くのコンストラクタが必要な場合や、オブジェクトを構築する際に副作用がある場"
"合に便利です。"

#: src/patterns/creational/builder.md:70
msgid "Separates methods for building from other methods."
msgstr "構築のためのメソッドを他のメソッドから分離します。"

#: src/patterns/creational/builder.md:72
msgid "Prevents proliferation of constructors."
msgstr "コンストラクタの増殖を防ぎます。"

#: src/patterns/creational/builder.md:74
msgid ""
"Can be used for one-liner initialisation as well as more complex "
"construction."
msgstr "ワンライナーでの初期化にも、より複雑な構築にも使用できます。"

#: src/patterns/creational/builder.md:78
msgid ""
"More complex than creating a struct object directly, or a simple "
"constructor\n"
"function."
msgstr ""
"構造体オブジェクトを直接作成したり、単純なコンストラクタ関数を使用するよりも"
"複雑です。"

#: src/patterns/creational/builder.md:83
msgid ""
"This pattern is seen more frequently in Rust (and for simpler objects) than "
"in\n"
"many other languages because Rust lacks overloading. Since you can only have "
"a\n"
"single method with a given name, having multiple constructors is less nice "
"in\n"
"Rust than in C++, Java, or others."
msgstr ""
"Rustにはオーバーロードがないため、他の多くの言語と比較して、このパターンが頻"
"繁に登場します(またより単純なオブジェクトに適用されます)。\n"
"1つの名前を持つメソッドは1つのみであることから、Rust にて複数のコンストラクタ"
"を定義することは、C++ や Java などと比べてあまり良いことではありません。"

#: src/patterns/creational/builder.md:88
msgid ""
"This pattern is often used where the builder object is useful in its own "
"right,\n"
"rather than being just a builder. For example, see\n"
"[`std::process::Command`](https://doc.rust-lang.org/std/process/struct."
"Command.html)\n"
"is a builder for [`Child`](https://doc.rust-lang.org/std/process/struct."
"Child.html)\n"
"(a process). In these cases, the `T` and `TBuilder` naming pattern is not "
"used."
msgstr ""
"このパターンは、builder オブジェクトが単なる builder としてではなく、それ自体"
"として有用である場合によく使われます。\n"
"例えば[`std::process::Command`](https://doc.rust-lang.org/std/process/struct."
"Command.html)\n"
"は [`Child`](https://doc.rust-lang.org/std/process/struct.Child.html) (プロセ"
"ス) のビルダーです。\n"
"これらの場合、 `T` と `TBuilder` の命名パターンは使用されていません。"

#: src/patterns/creational/builder.md:94
msgid ""
"The example takes and returns the builder by value. It is often more "
"ergonomic\n"
"(and more efficient) to take and return the builder as a mutable reference. "
"The\n"
"borrow checker makes this work naturally. This approach has the advantage "
"that\n"
"one can write code like"
msgstr ""
"例ではbuilderを値として引数に受け、return しています。\n"
"可変参照として引数に受け、return する形式が、多くの場合、より人間工学的(かつ"
"効率的)です。\n"
"借用チェッカーはこれを自然に動作させます。\n"
"このアプローチには下記のようなコードを書けるようになるメリットがあります。"

#: src/patterns/creational/builder.md:99
msgid ""
"```rust,ignore\n"
"let mut fb = FooBuilder::new();\n"
"fb.a();\n"
"fb.b();\n"
"let f = fb.build();\n"
"```"
msgstr ""
"```rust,ignore\n"
"let mut fb = FooBuilder::new();\n"
"fb.a();\n"
"fb.b();\n"
"let f = fb.build();\n"
"```"

#: src/patterns/creational/builder.md:106
msgid "as well as the `FooBuilder::new().a().b().build()` style."
msgstr "`FooBuilder::new().a().b().build()` のスタイルと同様です。"

#: src/patterns/creational/builder.md:110
msgid ""
"- [Description in the style guide](https://web.archive.org/"
"web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders."
"html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder), a crate for "
"automatically\n"
"  implementing this pattern while avoiding the boilerplate.\n"
"- [Constructor pattern](../../idioms/ctor.md) for when construction is "
"simpler.\n"
"- [Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/"
"Builder_pattern)\n"
"- [Construction of complex values](https://web.archive.org/"
"web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety."
"html#c-builder)"
msgstr ""
"- [スタイルガイドの記述](https://web.archive.org/web/20210104103100/https://"
"doc.rust-lang.org/1.12.0/style/ownership/builders.html)\n"
"- [derive_builder](https://crates.io/crates/derive_builder)は、このパターンを"
"自動的に実装するための crate です。\n"
"- [Constructor パターン](../../idioms/ctor.md) は、より単純な構築のためのもの"
"です。\n"
"- [Builder pattern (wikipedia)](https://en.wikipedia.org/wiki/"
"Builder_pattern)\n"
"- [複雑な値の構築](https://web.archive.org/web/20210104103000/https://rust-"
"lang.github.io/api-guidelines/type-safety.html#c-builder)"

#: src/patterns/creational/fold.md:1
msgid "# Fold"
msgstr "# Fold"

#: src/patterns/creational/fold.md:5
msgid ""
"Run an algorithm over each item in a collection of data to create a new "
"item,\n"
"thus creating a whole new collection."
msgstr ""
"データのコレクション内の各項目に対してアルゴリズムを実行し新しい項目を作成、"
"こうして、全く新しいコレクションを作成します。"

#: src/patterns/creational/fold.md:8
msgid ""
"The etymology here is unclear to me. The terms 'fold' and 'folder' are used\n"
"in the Rust compiler, although it appears to me to be more like a map than "
"a\n"
"fold in the usual sense. See the discussion below for more details."
msgstr ""
"この語源は私には理解できません。「fold」と「folder」という用語は、Rustコンパ"
"イラで使われています。\n"
"通常の感覚では fold というより map が近いように思います。詳しくは以下の議論を"
"参照してください。"

#: src/patterns/creational/fold.md:14
msgid ""
"```rust,ignore\n"
"// The data we will fold, a simple AST.\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>),\n"
"        Let(Box<Name>, Box<Expr>),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// The abstract folder\n"
"mod fold {\n"
"    use ast::*;\n"
"\n"
"    pub trait Folder {\n"
"        // A leaf node just returns the node itself. In some cases, we can "
"do this\n"
"        // to inner nodes too.\n"
"        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
"        // Create a new inner node by folding its children.\n"
"        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
"            match *s {\n"
"                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),\n"
"                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e))),\n"
"            }\n"
"        }\n"
"        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
"    }\n"
"}\n"
"\n"
"use fold::*;\n"
"use ast::*;\n"
"\n"
"// An example concrete implementation - renames every name to 'foo'.\n"
"struct Renamer;\n"
"impl Folder for Renamer {\n"
"    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
"        Box::new(Name { value: \"foo\".to_owned() })\n"
"    }\n"
"    // Use the default methods for the other nodes.\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// foldされるデータ。単純なAST。\n"
"mod ast {\n"
"    pub enum Stmt {\n"
"        Expr(Box<Expr>),\n"
"        Let(Box<Name>, Box<Expr>),\n"
"    }\n"
"\n"
"    pub struct Name {\n"
"        value: String,\n"
"    }\n"
"\n"
"    pub enum Expr {\n"
"        IntLit(i64),\n"
"        Add(Box<Expr>, Box<Expr>),\n"
"        Sub(Box<Expr>, Box<Expr>),\n"
"    }\n"
"}\n"
"\n"
"// folderの抽象\n"
"mod fold {\n"
"    use ast::*;\n"
"\n"
"    pub trait Folder {\n"
"        // リーフノードは単にノード自身を返します。多くの状況では、内部ノード"
"についても同様にすることが可能です。\n"
"        fn fold_name(&mut self, n: Box<Name>) -> Box<Name> { n }\n"
"        // 子ノードを fold し新たな内部ノードを作成します。\n"
"        fn fold_stmt(&mut self, s: Box<Stmt>) -> Box<Stmt> {\n"
"            match *s {\n"
"                Stmt::Expr(e) => Box::new(Stmt::Expr(self.fold_expr(e))),\n"
"                Stmt::Let(n, e) => Box::new(Stmt::Let(self.fold_name(n), "
"self.fold_expr(e))),\n"
"            }\n"
"        }\n"
"        fn fold_expr(&mut self, e: Box<Expr>) -> Box<Expr> { ... }\n"
"    }\n"
"}\n"
"\n"
"use fold::*;\n"
"use ast::*;\n"
"\n"
"// 具体的な実装例 - すべての名前を 'foo' にリネームします。\n"
"struct Renamer;\n"
"impl Folder for Renamer {\n"
"    fn fold_name(&mut self, n: Box<Name>) -> Box<Name> {\n"
"        Box::new(Name { value: \"foo\".to_owned() })\n"
"    }\n"
"    // 他のノードに対してはデフォルト実装を使用します。\n"
"}\n"
"```"

#: src/patterns/creational/fold.md:65
msgid ""
"The result of running the `Renamer` on an AST is a new AST identical to the "
"old\n"
"one, but with every name changed to `foo`. A real life folder might have "
"some\n"
"state preserved between nodes in the struct itself."
msgstr ""
"ASTに対して `Renamer` を実行した結果は、すべての名前が `foo` に変更されたこと"
"を除いて元のASTとまったく同一の、新しいASTになります。\n"
"実際の folder では構造体のノード間で何らかの状態を保持する可能性があります。"

#: src/patterns/creational/fold.md:69
msgid ""
"A folder can also be defined to map one data structure to a different (but\n"
"usually similar) data structure. For example, we could fold an AST into a "
"HIR\n"
"tree (HIR stands for high-level intermediate representation)."
msgstr ""
"folder は、あるデータ構造を別の(しかし通常は類似した)データ構造にマッピングす"
"るものとして定義することもできます。\n"
"例えば、ASTをHIRツリーに折り畳むことができます(HIRは high-level intermediate "
"representation (高水準中間表現) の略です)。"

#: src/patterns/creational/fold.md:75
msgid ""
"It is common to want to map a data structure by performing some operation "
"on\n"
"each node in the structure. For simple operations on simple data "
"structures,\n"
"this can be done using `Iterator::map`. For more complex operations, "
"perhaps\n"
"where earlier nodes can affect the operation on later nodes, or where "
"iteration\n"
"over the data structure is non-trivial, using the fold pattern is more\n"
"appropriate."
msgstr ""
"データ構造内の各ノードに対して何らかの操作を実行することで、データ構造をマッ"
"プしたい場合がよくあります。\n"
"これは、単純なデータ構造に対する単純な操作であれば、 `Iterator::map` を使って"
"行えます。\n"
"より複雑な操作、例えば前のノードが後のノードの操作に影響を与えるような操作"
"や、\n"
"データ構造に対するイテレーションが自明でないような操作には、foldパターンを使"
"うことがより適切です。"

#: src/patterns/creational/fold.md:82
msgid ""
"Like the visitor pattern, the fold pattern allows us to separate traversal "
"of a\n"
"data structure from the operations performed to each node."
msgstr ""
"Visitor パターンと同様に Fold パターンでも、データ構造の走査を各ノードに対し"
"て行われる操作から分離することができます。"

#: src/patterns/creational/fold.md:87
msgid ""
"Mapping data structures in this fashion is common in functional languages. "
"In OO\n"
"languages, it would be more common to mutate the data structure in place. "
"The\n"
"'functional' approach is common in Rust, mostly due to the preference for\n"
"immutability. Using fresh data structures, rather than mutating old ones, "
"makes\n"
"reasoning about the code easier in most circumstances."
msgstr ""
"このような形でデータ構造をマッピングすることは、関数型言語では一般的です。\n"
"OO言語では、データ構造をその場で書き換えることがより一般的でしょう。\n"
"Rustでは、主に不変性を好むため、「関数型」アプローチが一般的です。\n"
"Rustでは「関数型」アプローチが一般的です。古いデータ構造を書き換えるのではな"
"く、\n"
"新しいデータ構造を使用することで、ほとんどの状況でコードに関する推論が容易に"
"なります。"

#: src/patterns/creational/fold.md:93
msgid ""
"The trade-off between efficiency and reusability can be tweaked by changing "
"how\n"
"nodes are accepted by the `fold_*` methods."
msgstr ""
"効率と再利用性のトレードオフは、`fold_*` メソッドでノードを受け入れる方法を変"
"更することで調整できます。"

#: src/patterns/creational/fold.md:96
msgid ""
"In the above example we operate on `Box` pointers. Since these own their "
"data\n"
"exclusively, the original copy of the data structure cannot be re-used. On "
"the\n"
"other hand if a node is not changed, reusing it is very efficient."
msgstr ""
"上の例では `Box` ポインタを操作しています。\n"
"これらはそのデータを排他的に所有するため、データ構造の元のコピーを再利用する"
"ことはできません。\n"
"一方、ノードが変更されなければ、それを再利用することは非常に効率的です。"

#: src/patterns/creational/fold.md:100
msgid ""
"If we were to operate on borrowed references, the original data structure "
"can be\n"
"reused; however, a node must be cloned even if unchanged, which can be\n"
"expensive."
msgstr ""
"借用した参照を操作していたのであれば、元のデータ構造を再利用することができま"
"す。\n"
"しかし、変更がなくともノードをクローンする必要があり、コストがかかります。"

#: src/patterns/creational/fold.md:104
msgid ""
"Using a reference counted pointer gives the best of both worlds - we can "
"reuse\n"
"the original data structure, and we don't need to clone unchanged nodes. "
"However,\n"
"they are less ergonomic to use and mean that the data structures cannot be\n"
"mutable."
msgstr ""
"参照カウントされたポインタを使用すると両方の利点が得られます。元のデータ構造"
"を再利用でき、変更されていないノードをクローンする必要がないためです。\n"
"これらは人間工学的に使いにくく、データ構造をミュータブルにできないことを意味"
"します。"

#: src/patterns/creational/fold.md:111
msgid ""
"Iterators have a `fold` method, however this folds a data structure into a\n"
"value, rather than into a new data structure. An iterator's `map` is more "
"like\n"
"this fold pattern."
msgstr ""
"イテレータには `fold` メソッドがありますが、これはデータ構造を新しいデータ構"
"造に fold するのではなく、1つの値に畳み込みます。\n"
"イテレータの `map` が、この Fold パターンには似ています。"

#: src/patterns/creational/fold.md:115
msgid ""
"In other languages, fold is usually used in the sense of Rust's iterators,\n"
"rather than this pattern. Some functional languages have powerful constructs "
"for\n"
"performing flexible maps over data structures."
msgstr ""
"他の言語では、fold は、この Fold パターンではなく、通常Rustのイテレータにおけ"
"る意味 (`fold` メソッド) で使われます。\n"
"関数型言語の中には、データ構造に対して柔軟なマップを行うための強力な構成要素"
"を持つものがあります。"

#: src/patterns/creational/fold.md:119
msgid ""
"The [visitor](../behavioural/visitor.md) pattern is closely related to "
"fold.\n"
"They share the concept of walking a data structure performing an operation "
"on\n"
"each node. However, the visitor does not create a new data structure nor "
"consume\n"
"the old one."
msgstr ""
"[Visitor](../behavioural/visitor.md)パターンは Fold と密接に関連していま"
"す。\n"
"この2つのパターンは、データ構造を巡りながら各ノードに対して操作を行う、という"
"概念を共有しています。\n"
"しかし、Visitor は新しいデータ構造を生成したり、古いデータ構造を消費したりは"
"しません。"

#: src/patterns/structural/intro.md:1
msgid "# Structural Patterns"
msgstr "# 構造に関するパターン"

#: src/patterns/structural/intro.md:3
msgid "From [Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern):"
msgstr "[Wikipedia](https://en.wikipedia.org/wiki/Structural_pattern)より："

#: src/patterns/structural/intro.md:5
msgid ""
"> Design patterns that ease the design by identifying a simple way to "
"realize relationships\n"
"> among entities."
msgstr ""
"> Design patterns that ease the design by identifying a simple way to "
"realize relationships\n"
"> among entities.\n"
"> (エンティティ間の関係を表現するシンプルな方法を特定することで、設計を容易に"
"するデザインパターン。)"

#: src/patterns/structural/compose-structs.md:1
msgid "# Struct decomposition for independent borrowing"
msgstr "# 個別借用のための構造体の分解"

#: src/patterns/structural/compose-structs.md:5
msgid ""
"Sometimes a large struct will cause issues with the borrow checker - "
"although\n"
"fields can be borrowed independently, sometimes the whole struct ends up "
"being\n"
"used at once, preventing other uses. A solution might be to decompose the "
"struct\n"
"into several smaller structs. Then compose these together into the original\n"
"struct. Then each struct can be borrowed separately and have more flexible\n"
"behaviour."
msgstr ""
"大きな構造体では、借用チェッカーにて問題が発生することがあります - \n"
"フィールドを個別に借用できますが、同時に構造体全体が使用されてしまうことにな"
"り、他の使用を妨げることがあります。\n"
"解決策としては、構造体を複数の小さな構造体に分解することです。それから、これ"
"らを元の構造体にまとめます。\n"
"そうすれば、各構造体を個別に借用でき、より柔軟な操作が可能になります。"

#: src/patterns/structural/compose-structs.md:12
msgid ""
"This will often lead to a better design in other ways: applying this design\n"
"pattern often reveals smaller units of functionality."
msgstr ""
"これは、別の形でより良い設計につながることがあります：このデザインパターンを"
"適用することにより、より小さな機能の単位の存在が明らかになることがあります。"

#: src/patterns/structural/compose-structs.md:17
msgid ""
"Here is a contrived example of where the borrow checker foils us in our plan "
"to\n"
"use a struct:"
msgstr "以下は、借用チェッカーが構造体の利用を妨げ失敗させる、作為的な例です："

#: src/patterns/structural/compose-structs.md:20
msgid ""
"```rust\n"
"struct Database {\n"
"    connection_string: String,\n"
"    timeout: u32,\n"
"    pool_size: u32,\n"
"}\n"
"\n"
"fn print_database(database: &Database) {\n"
"    println!(\"Connection string: {}\", database.connection_string);\n"
"    println!(\"Timeout: {}\", database.timeout);\n"
"    println!(\"Pool size: {}\", database.pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut db = Database {\n"
"        connection_string: \"initial string\".to_string(),\n"
"        timeout: 30,\n"
"        pool_size: 100,\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(&db);  // Immutable borrow of `db` happens here\n"
"    // *connection_string = \"new string\".to_string();  // Mutable borrow "
"is used\n"
"                                                       // here\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Database {\n"
"    connection_string: String,\n"
"    timeout: u32,\n"
"    pool_size: u32,\n"
"}\n"
"\n"
"fn print_database(database: &Database) {\n"
"    println!(\"Connection string: {}\", database.connection_string);\n"
"    println!(\"Timeout: {}\", database.timeout);\n"
"    println!(\"Pool size: {}\", database.pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    let mut db = Database {\n"
"        connection_string: \"initial string\".to_string(),\n"
"        timeout: 30,\n"
"        pool_size: 100,\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(&db);  // `db` の不変借用が発生\n"
"    // *connection_string = \"new string\".to_string();  // ここで可変借用を"
"使用\n"
"}\n"
"```"

#: src/patterns/structural/compose-structs.md:47
msgid ""
"We can apply this design pattern and refactor `Database` into three smaller\n"
"structs, thus solving the borrow checking issue:"
msgstr ""
"このデザインパターンを適用し、`Database`を3つの小さな構造体にリファクタリング"
"します。これにより借用チェッカーの問題を解決します："

#: src/patterns/structural/compose-structs.md:50
msgid ""
"```rust\n"
"// Database is now composed of three structs - ConnectionString, Timeout and "
"PoolSize.\n"
"// Let's decompose it into smaller structs\n"
"#[derive(Debug, Clone)]\n"
"struct ConnectionString(String);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct Timeout(u32);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct PoolSize(u32);\n"
"\n"
"// We then compose these smaller structs back into `Database`\n"
"struct Database {\n"
"    connection_string: ConnectionString,\n"
"    timeout: Timeout,\n"
"    pool_size: PoolSize,\n"
"}\n"
"\n"
"// print_database can then take ConnectionString, Timeout and Poolsize "
"struct instead\n"
"fn print_database(connection_str: ConnectionString, \n"
"                  timeout: Timeout, \n"
"                  pool_size: PoolSize) {\n"
"    println!(\"Connection string: {:?}\", connection_str);\n"
"    println!(\"Timeout: {:?}\", timeout);\n"
"    println!(\"Pool size: {:?}\", pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    // Initialize the Database with the three structs\n"
"    let mut db = Database {\n"
"        connection_string: ConnectionString(\"localhost\".to_string()),\n"
"        timeout: Timeout(30),\n"
"        pool_size: PoolSize(100),\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
"    *connection_string = ConnectionString(\"new string\".to_string());\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Databaseを3つの構造体 ConnectionStringとTimeout、PoolSize として構成しま"
"す。\n"
"// まず、より小さな構造体へ分解します。\n"
"#[derive(Debug, Clone)]\n"
"struct ConnectionString(String);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct Timeout(u32);\n"
"\n"
"#[derive(Debug, Clone, Copy)]\n"
"struct PoolSize(u32);\n"
"\n"
"// そして `Database` を 3つのより小さな構造体により構成し直します。\n"
"struct Database {\n"
"    connection_string: ConnectionString,\n"
"    timeout: Timeout,\n"
"    pool_size: PoolSize,\n"
"}\n"
"\n"
"// print_database は ConnectionString と Timeout 、 Poolsize を代わりに引き受"
"けることが可能になります。\n"
"fn print_database(connection_str: ConnectionString, \n"
"                  timeout: Timeout, \n"
"                  pool_size: PoolSize) {\n"
"    println!(\"Connection string: {:?}\", connection_str);\n"
"    println!(\"Timeout: {:?}\", timeout);\n"
"    println!(\"Pool size: {:?}\", pool_size);\n"
"}\n"
"\n"
"fn main() {\n"
"    // Database を 3つの構造体にて初期化します。\n"
"    let mut db = Database {\n"
"        connection_string: ConnectionString(\"localhost\".to_string()),\n"
"        timeout: Timeout(30),\n"
"        pool_size: PoolSize(100),\n"
"    };\n"
"\n"
"    let connection_string = &mut db.connection_string;\n"
"    print_database(connection_string.clone(), db.timeout, db.pool_size);\n"
"    *connection_string = ConnectionString(\"new string\".to_string());\n"
"}\n"
"```"

#: src/patterns/structural/compose-structs.md:94
msgid ""
"This pattern is most useful, when you have a struct that ended up with a lot "
"of\n"
"fields that you want to borrow independently. Thus having a more flexible\n"
"behaviour in the end."
msgstr ""
"このパターンは、独立して借用したいフィールドがたくさんある構造体を持っている"
"場合に、最も便利です。\n"
"結果として、最終的にはより柔軟な操作が可能になります。"

#: src/patterns/structural/compose-structs.md:100
msgid ""
"Decomposition of structs lets you work around limitations in the borrow "
"checker.\n"
"And it often produces a better design."
msgstr ""
"構造体の分解は借用チェッカーの制限を回避するのに利用できます。またより良い設"
"計を生み出すこともあります。"

#: src/patterns/structural/compose-structs.md:105
msgid ""
"It can lead to more verbose code. And sometimes, the smaller structs are "
"not\n"
"good abstractions, and so we end up with a worse design. That is probably a\n"
"'code smell', indicating that the program should be refactored in some way."
msgstr ""
"冗長なコードにつながる可能性があります。またときに、より小さな構造体が良い抽"
"象でなく、より悪い設計になってしまうことがあります。\n"
"これはおそらく「コードの臭い」であり、プログラムを何らかの方法でリファクタす"
"べきことを示しています。"

#: src/patterns/structural/compose-structs.md:111
msgid ""
"This pattern is not required in languages that don't have a borrow checker, "
"so\n"
"in that sense is unique to Rust. However, making smaller units of "
"functionality\n"
"often leads to cleaner code: a widely acknowledged principle of software\n"
"engineering, independent of the language."
msgstr ""
"このパターンは、借用チェッカーを持たない言語では必要ありません。\n"
"その意味ではRust独自のものです。\n"
"しかし、機能の単位を小さくすることがクリーンなコードにつながることは、\n"
"ソフトウェア工学の原則として、言語とは関係なく広く認められています。"

#: src/patterns/structural/compose-structs.md:116
msgid ""
"This pattern relies on Rust's borrow checker to be able to borrow fields\n"
"independently of each other. In the example, the borrow checker knows that "
"`a.b`\n"
"and `a.c` are distinct and can be borrowed independently, it does not try "
"to\n"
"borrow all of `a`, which would make this pattern useless."
msgstr ""
"このパターンは、Rustの借用チェッカーがフィールドを互いに独立して借用できるこ"
"とに依存しています。\n"
"この例では、借用チェッカーは `a.b` と `a.c` が別個のものであり、独立して借用"
"できることを知っており、\n"
"`a` のすべてを借用しようとはしません。そうでなければ、このパターンは役に立た"
"ないところでした。"

#: src/patterns/structural/small-crates.md:1
msgid "# Prefer small crates"
msgstr "# 小さな crate を好む"

#: src/patterns/structural/small-crates.md:5
msgid "Prefer small crates that do one thing well."
msgstr "1つのことをよく熟す小さな crate をより好みましょう。"

#: src/patterns/structural/small-crates.md:7
msgid ""
"Cargo and crates.io make it easy to add third-party libraries, much more so "
"than\n"
"in say C or C++. Moreover, since packages on crates.io cannot be edited or "
"removed\n"
"after publication, any build that works now should continue to work in the "
"future.\n"
"We should take advantage of this tooling, and use smaller, more fine-grained "
"dependencies."
msgstr ""
"cargo と crates.io は、サードパーティーライブラリの追加を、CやC++よりもはるか"
"に簡単なものにします。\n"
"また、crates.io上のパッケージは公開後に編集・削除不可能なため、現在機能してい"
"るビルドは将来も機能し続けるはずです。\n"
"私たちはこのツールを活用し、より小さく、細かな依存関係を使うべきです。"

#: src/patterns/structural/small-crates.md:14
msgid ""
"- Small crates are easier to understand, and encourage more modular code.\n"
"- Crates allow for re-using code between projects.\n"
"  For example, the `url` crate was developed as part of the Servo browser "
"engine,\n"
"  but has since found wide use outside the project.\n"
"- Since the compilation unit\n"
"  of Rust is the crate, splitting a project into multiple crates can allow "
"more of\n"
"  the code to be built in parallel."
msgstr ""
"- 小さな crate は理解しやすく、よりモジュール化されたコードを促進します。\n"
"- crate はプロジェクト間でのコードの再利用を可能にします。\n"
"  例えば、`url` クレートは Servo ブラウザエンジンの一部として開発されました"
"が、\n"
"  その後プロジェクト外で広く使用されるようになりました。\n"
"- Rustのコンパイル単位は crate であるため、\n"
"  プロジェクトを複数の crate に分割することで、より多くのコードを並列にビルド"
"できるようになります。"

#: src/patterns/structural/small-crates.md:24
msgid ""
"- This can lead to \"dependency hell\", when a project depends on multiple "
"conflicting\n"
"  versions of a crate at the same time. For example, the `url` crate has "
"both versions\n"
"  1.0 and 0.5. Since the `Url` from `url:1.0` and the `Url` from `url:0.5` "
"are\n"
"  different types, an HTTP client that uses `url:0.5` would not accept `Url` "
"values\n"
"  from a web scraper that uses `url:1.0`.\n"
"- Packages on crates.io are not curated. A crate may be poorly written, "
"have\n"
"  unhelpful documentation, or be outright malicious.\n"
"- Two small crates may be less optimized than one large one, since the "
"compiler\n"
"  does not perform link-time optimization (LTO) by default."
msgstr ""
"- これはプロジェクトが競合するバージョンの複数の crate に依存しているとき、"
"「依存性地獄」につながる可能性があります。\n"
"  例えば、 `url` crate はバージョン 1.0 と 0.5 があります。 `url:1.0` の "
"`Url` と `url:0.5` の `Url` は異なる型であるため、\n"
"  `url:0.5` を使用するHTTPクライアントは、 `url:1.0` を使用するWebスクレイ"
"パーからの `Url` を受け付けません。\n"
"- crates.io のパッケージはキュレーションされていません。\n"
"  crate には作りが甘かったり、ドキュメントが助けにならないものであったり、あ"
"からさまに悪意のあるものもあります。\n"
"- コンパイラはデフォルトでリンク時最適化(LTO)を行わないので、2つの小さなク"
"レートは1つの大きなクレートよりも最適化されていないかもしれません。"

#: src/patterns/structural/small-crates.md:36
msgid ""
"The [`url`](https://crates.io/crates/url) crate provides tools for working "
"with\n"
"URLs."
msgstr ""
"[`url`](https://crates.io/crates/url) crateはURLを扱うツールを提供します。"

#: src/patterns/structural/small-crates.md:39
msgid ""
"The [`num_cpus`](https://crates.io/crates/num_cpus) crate provides a "
"function to\n"
"query the number of CPUs on a machine."
msgstr ""
"[`num_cpus`](https://crates.io/crates/num_cpus) crate はマシンのCPU数を問い合"
"わせる関数を提供します。"

#: src/patterns/structural/small-crates.md:42
msgid ""
"The [`ref_slice`](https://crates.io/crates/ref_slice) crate provides "
"functions\n"
"for converting `&T` to `&[T]`. (Historical example)"
msgstr ""
"[`ref_slice`](https://crates.io/crates/ref_slice) crate は `&T` を `&[T]` に"
"変換する関数を提供します(歴史的な例)。"

#: src/patterns/structural/small-crates.md:47
msgid "- [crates.io: The Rust community crate host](https://crates.io/)"
msgstr "- [crates.io: Rustコミュニティの crate ホスト](https://crates.io/)"

#: src/patterns/structural/unsafe-mods.md:1
msgid "# Contain unsafety in small modules"
msgstr "# 安全でないものを小さなモジュールに閉じ込める"

#: src/patterns/structural/unsafe-mods.md:5
msgid ""
"If you have `unsafe` code, create the smallest possible module that can "
"uphold\n"
"the needed invariants to build a minimal safe interface upon the unsafety. "
"Embed\n"
"this into a larger module that contains only safe code and presents an "
"ergonomic\n"
"interface. Note that the outer module can contain unsafe functions and "
"methods\n"
"that call directly into the unsafe code. Users may use this to gain speed "
"benefits."
msgstr ""
"`unsafe` なコードがある場合、安全でないコードの上に最小限の安全なインタフェー"
"スを構築するために、必要な不変性を維持できる可能な限り小さなモジュールを作り"
"ましょう。\n"
"これを安全なコードのみ含む大きなモジュールに組み込み、人間工学的なインタ"
"フェースを提供してください。\n"
"外側のモジュールには unsafe なコードを呼び出す unsafe な関数やメソッドを含め"
"でもよいことに注意してください。\n"
"ユーザはこれを使用して、速度の利点を得ることができます。"

#: src/patterns/structural/unsafe-mods.md:13
msgid ""
"- This restricts the unsafe code that must be audited\n"
"- Writing the outer module is much easier, since you can count on the "
"guarantees\n"
"  of the inner module"
msgstr ""
"- これにより、検査が必要な unsafe なコードが制限されます\n"
"- 内側のモジュールによる保証に頼ることで、外側のモジュールを書くことがずっと"
"簡単になります"

#: src/patterns/structural/unsafe-mods.md:19
msgid ""
"- Sometimes, it may be hard to find a suitable interface.\n"
"- The abstraction may introduce inefficiencies."
msgstr ""
"- 適切なインタフェースを見つけるのが難しい場合もあります。\n"
"- 抽象化が非効率をもたらすかもしれません。"

#: src/patterns/structural/unsafe-mods.md:24
msgid ""
"- The [`toolshed`](https://docs.rs/toolshed) crate contains its unsafe "
"operations\n"
"  in submodules, presenting a safe interface to users.\n"
"- `std`'s `String` class is a wrapper over `Vec<u8>` with the added "
"invariant\n"
"  that the contents must be valid UTF-8. The operations on `String` ensure "
"this\n"
"  behavior.\n"
"  However, users have the option of using an `unsafe` method to create a "
"`String`,\n"
"  in which case the onus is on them to guarantee the validity of the "
"contents."
msgstr ""
"- [`toolshed`](https://docs.rs/toolshed) crateは、安全でない操作をサブモ"
"ジュールにとじ込めることで、ユーザーに安全なインターフェイスを提供します。\n"
"- `std` の `String` クラスは、その中身が妥当なUTF-8であるという不変性を追加し"
"た `Vec<u8>` のラッパーです。\n"
"  `String` に対する操作はこの振る舞いを保証します。\n"
"  しかし、ユーザが、その内容の妥当性を保証する責任を持つ前提で、 `String` を"
"作成する `unsafe` メソッドを利用する選択肢があります。"

#: src/patterns/structural/unsafe-mods.md:34
msgid ""
"- [Ralf Jung's Blog about invariants in unsafe code](https://www.ralfj.de/"
"blog/2018/08/22/two-kinds-of-invariants.html)"
msgstr ""
"- [unsafe コードにおける不変性に関する Ralf jung のブログ](https://www.ralfj."
"de/blog/2018/08/22/two-kinds-of-invariants.html)"

#: src/patterns/ffi/intro.md:1
msgid "# FFI Patterns"
msgstr "# FFI に関するパターン"

#: src/patterns/ffi/intro.md:3
msgid ""
"Writing FFI code is an entire course in itself.\n"
"However, there are several idioms here that can act as pointers, and avoid "
"traps\n"
"for inexperienced users of unsafe Rust."
msgstr ""
"FFIコードを書くことは、それ自体が1つの課程です。\n"
"しかしながら、ポインタの役割を担い、`unsafe` Rustの経験の浅いユーザーが陥る罠"
"を回避する、いくつかのイディオムがあります。"

#: src/patterns/ffi/intro.md:7
msgid ""
"This section contains design patterns that may be useful when doing FFI."
msgstr "このセクションでは、FFIを行う際に役立つデザインパターンを紹介します。"

#: src/patterns/ffi/intro.md:9
msgid ""
"1. [Object-Based API](./export.md) design that has good memory safety "
"characteristics,\n"
"   and a clean boundary of what is safe and what is unsafe\n"
"\n"
"2. [Type Consolidation into Wrappers](./wrappers.md) - group multiple Rust "
"types\n"
"   together into an opaque \"object\""
msgstr ""
"1.[オブジェクトベースのAPI](./export.md) は優れたメモリ安全性を設計し、\n"
"   何が安全で何が安全でないかの境界を明確にします。\n"
"\n"
"2.[型のラッパーへの統合](./wrappers.md) - 複数のRust型を不透明な「オブジェク"
"ト」にまとめます。"

#: src/patterns/ffi/export.md:1
msgid "# Object-Based APIs"
msgstr "# オブジェクトベースのAPI"

#: src/patterns/ffi/export.md:5
msgid ""
"When designing APIs in Rust which are exposed to other languages, there are "
"some\n"
"important design principles which are contrary to normal Rust API design:"
msgstr ""
"Rustにて、他の言語へ公開するAPIを設計する場合、通常のRustのAPI設計に反する重"
"要な設計原則がいくつかあります："

# 8/8もう一度訳すこと。読んだ後に。
#: src/patterns/ffi/export.md:8
msgid ""
"1. All Encapsulated types should be _owned_ by Rust, _managed_ by the user,\n"
"   and _opaque_.\n"
"2. All Transactional data types should be _owned_ by the user, and "
"_transparent_.\n"
"3. All library behavior should be functions acting upon Encapsulated types.\n"
"4. All library behavior should be encapsulated into types not based on "
"structure,\n"
"   but _provenance/lifetime_."
msgstr ""
"1. カプセル化された型はすべて、Rustが _所有_ し、ユーザーが _管理_ し、\n"
"   また _不透過的_ であるべきです。\n"
"2. すべてのトランザクションデータ型は、ユーザが _所有_ し、 _透過的_ であるべ"
"きです。\n"
"3. すべてのライブラリの操作は、カプセル化された型に作用する関数であるべきで"
"す。\n"
"4. すべてのライブラリの操作は、構造に基づく型ではなく、_provenance/ライフタイ"
"ム_ に基づく型にカプセル化されるべきです。"

#: src/patterns/ffi/export.md:17
msgid ""
"Rust has built-in FFI support to other languages.\n"
"It does this by providing a way for crate authors to provide C-compatible "
"APIs\n"
"through different ABIs (though that is unimportant to this practice)."
msgstr ""
"Rustには、他の言語へのFFIサポートが組み込まれています。\n"
"これは、クレート作者が異なるABIを通じてC互換のAPIを提供する方法を提供すること"
"で実現しています（このことは当実践には重要ではありませんが）。"

# foreign API はなんと訳すとそれっぽいのだろう。
# 試しに言語間の、と訳してみる
#: src/patterns/ffi/export.md:21
msgid ""
"Well-designed Rust FFI follows C API design principles, while compromising "
"the\n"
"design in Rust as little as possible. There are three goals with any foreign "
"API:"
msgstr ""
"うまく設計されたRust FFIは、C言語のAPI設計の原則に従いつつ、Rustの設計を可能"
"な限り損なわないようにします。\n"
"言語間のAPIには3つのゴールがあります："

#: src/patterns/ffi/export.md:24
msgid ""
"1. Make it easy to use in the target language.\n"
"2. Avoid the API dictating internal unsafety on the Rust side as much as "
"possible.\n"
"3. Keep the potential for memory unsafety and Rust `undefined behaviour` as "
"small\n"
"   as possible."
msgstr ""
"1. ターゲット言語にて使いやすいようにしましょう。\n"
"2. APIが、Rust側での内部的な不安定性を左右することは可能な限り避けましょ"
"う。\n"
"3. メモリの不安定性やRustの `undefined behavior` の可能性をできるだけ小さく保"
"ちましょう。"

#: src/patterns/ffi/export.md:29
msgid ""
"Rust code must trust the memory safety of the foreign language beyond a "
"certain\n"
"point. However, every bit of `unsafe` code on the Rust side is an "
"opportunity for\n"
"bugs, or to exacerbate `undefined behaviour`."
msgstr ""
"Rustコードは、外部言語のメモリ安全性を一定以上信頼しなければなりません。\n"
"しかし、Rust側の `unsafe` コードすべては、バグを発生させたり、 `undefined "
"behaviour` を悪化させるきっかけとなりえます。"

# (Pointer) provenance : (ポインタの)由来
# 同じメモリアドレスを指すポインタを識別することに使用するモノ。コンパイラのVMが認識する情報らしい。コード生成には影響する。この情報は実行時に保持されない。
# https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#pointer-provenance
#: src/patterns/ffi/export.md:33
msgid ""
"For example, if a pointer provenance is wrong, that may be a segfault due "
"to\n"
"invalid memory access. But if it is manipulated by unsafe code, it could "
"become\n"
"full-blown heap corruption."
msgstr ""
"例えば、ポインタの provenance が間違っている場合、それは無効なメモリアクセス"
"が原因のセグメンテーション違反となりえます。\n"
"しかし、それが unsafe コードによって操作された場合、本格的なヒープ破壊を起こ"
"す可能性があります。"

#: src/patterns/ffi/export.md:37
msgid ""
"The Object-Based API design allows for writing shims that have good memory "
"safety\n"
"characteristics, and a clean boundary of what is safe and what is `unsafe`."
msgstr ""
"オブジェクトベースのAPI設計は、メモリ安全性に優れたくさびを記述することを可能"
"にし、`unsafe` なものと安全ななものの境界を明確にするものです。"

#: src/patterns/ffi/export.md:42
msgid ""
"The POSIX standard defines the API to access an on-file database, known as "
"[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/"
"ndbm.h).\n"
"It is an excellent example of an \"object-based\" API."
msgstr ""
"POSIX標準では、[DBM](https://web.archive.org/web/20210105035602/https://www."
"mankier.com/0p/ndbm.h)として知られるオンファイル・データベースにアクセスする"
"ためのAPIを定義しています。\n"
"これは「オブジェクトベース」APIの優れた例です。"

#: src/patterns/ffi/export.md:45
msgid ""
"Here is the definition in C, which hopefully should be easy to read for "
"those\n"
"involved in FFI. The commentary below should help explain it for those who\n"
"miss the subtleties."
msgstr ""
"以下はC言語による定義です。FFIに携わっている人には読みやすいと思います。\n"
"以下の解説は、微妙な点を理解し損ねた人のために役立つはずです。"

#: src/patterns/ffi/export.md:49
msgid ""
"```C\n"
"struct DBM;\n"
"typedef struct { void *dptr, size_t dsize } datum;\n"
"\n"
"int     dbm_clearerr(DBM *);\n"
"void    dbm_close(DBM *);\n"
"int     dbm_delete(DBM *, datum);\n"
"int     dbm_error(DBM *);\n"
"datum   dbm_fetch(DBM *, datum);\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"DBM    *dbm_open(const char *, int, mode_t);\n"
"int     dbm_store(DBM *, datum, datum, int);\n"
"```"
msgstr ""
"```C\n"
"struct DBM;\n"
"typedef struct { void *dptr, size_t dsize } datum;\n"
"\n"
"int     dbm_clearerr(DBM *);\n"
"void    dbm_close(DBM *);\n"
"int     dbm_delete(DBM *, datum);\n"
"int     dbm_error(DBM *);\n"
"datum   dbm_fetch(DBM *, datum);\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"DBM    *dbm_open(const char *, int, mode_t);\n"
"int     dbm_store(DBM *, datum, datum, int);\n"
"```"

#: src/patterns/ffi/export.md:64
msgid "This API defines two types: `DBM` and `datum`."
msgstr "このAPIは2つの型を定義しています： `DBM` と `datum` です。"

#: src/patterns/ffi/export.md:66
msgid ""
"The `DBM` type was called an \"encapsulated\" type above.\n"
"It is designed to contain internal state, and acts as an entry point for "
"the\n"
"library's behavior."
msgstr ""
"`DBM`型は上述した「カプセル化された」型と呼ばれるものです。\n"
"`DBM`型は内部状態を持つように設計されており、ライブラリの操作のエントリポイン"
"トとして振る舞います。"

#: src/patterns/ffi/export.md:70
msgid ""
"It is completely opaque to the user, who cannot create a `DBM` themselves "
"since\n"
"they don't know its size or layout. Instead, they must call `dbm_open`, and "
"that\n"
"only gives them _a pointer to one_."
msgstr ""
"サイズやレイアウトを知らないので、ユーザは `DBM` 直接作成することができませ"
"ん。\n"
"その代わりに、 `dbm_open` を呼び出す必要があります。そしてこれは _DBMへのポイ"
"ンタ_ を与えてくれるだけです。"

#: src/patterns/ffi/export.md:74
msgid ""
"This means all `DBM`s are \"owned\" by the library in a Rust sense.\n"
"The internal state of unknown size is kept in memory controlled by the "
"library,\n"
"not the user. The user can only manage its life cycle with `open` and "
"`close`,\n"
"and perform operations on it with the other functions."
msgstr ""
"これはRust的な感覚で言えば、ライブラリがすべての `DBM` を「所有」している、と"
"いうことになります。\n"
"サイズ不明の内部状態は、ユーザ側ではなく、ライブラリが管理するメモリに保持さ"
"れます。\n"
"ユーザが行えるのは、 `DBM` のライフサイクルを `open` と `close` によって管理"
"し、他の関数によって操作することに限られます。"

#: src/patterns/ffi/export.md:79
msgid ""
"The `datum` type was called a \"transactional\" type above.\n"
"It is designed to facilitate the exchange of information between the library "
"and\n"
"its user."
msgstr ""
"`datum` 型は上述した 「トランザクション」型と呼ばれるものです。\n"
"これはライブラリと利用者の間の情報交換を容易にするために設計されています。"

#: src/patterns/ffi/export.md:83
msgid ""
"The database is designed to store \"unstructured data\", with no pre-defined "
"length\n"
"or meaning. As a result, the `datum` is the C equivalent of a Rust slice: a "
"bunch\n"
"of bytes, and a count of how many there are. The main difference is that "
"there is\n"
"no type information, which is what `void` indicates."
msgstr ""
"データベースは、あらかじめ長さや意味の定義されていない「非構造化データ」を保"
"存するように設計されています。\n"
"その結果、`datum` は C において Rust のスライス - バイトの列であり、その数を"
"カウントされたもの - に相当します。\n"
"主な相違点は、これには型情報がないことです。 `void` はそれを示唆しています。"

#: src/patterns/ffi/export.md:88
msgid ""
"Keep in mind that this header is written from the library's point of view.\n"
"The user likely has some type they are using, which has a known size.\n"
"But the library does not care, and by the rules of C casting, any type "
"behind a\n"
"pointer can be cast to `void`."
msgstr ""
"このヘッダーはライブラリーの視点から記述されていることに留意してください。\n"
"ユーザは、サイズが既知である何らかの型を使用しているはずです。\n"
"しかし、ライブラリはそれについて関知しません。またCのキャストの規則では、あら"
"ゆる型を `void` にキャストできます。"

#: src/patterns/ffi/export.md:93
msgid ""
"As noted earlier, this type is _transparent_ to the user. But also, this "
"type is\n"
"_owned_ by the user.\n"
"This has subtle ramifications, due to that pointer inside it.\n"
"The question is, who owns the memory that pointer points to?"
msgstr ""
"前述したように、この型はユーザーにとって _透過的_ です。しかし同時に、この型"
"はユーザーによって _所有_ されます。\n"
"このことは、内部にあるポインタによって、微妙な影響を及ぼします。\n"
"問題は、そのポインタが指すメモリは誰のものなのか、ということです。"

#: src/patterns/ffi/export.md:98
msgid ""
"The answer for best memory safety is, \"the user\".\n"
"But in cases such as retrieving a value, the user does not know how to "
"allocate\n"
"it correctly (since they don't know how long the value is). In this case, "
"the library\n"
"code is expected to use the heap that the user has access to -- such as the "
"C library\n"
"`malloc` and `free` -- and then _transfer ownership_ in the Rust sense."
msgstr ""
"最高のメモリ安全性のための答えは「ユーザ」です。\n"
"しかし、値を取得するような場合、ユーザは(値の長さを知らないので)どのように値"
"を正しく割り当ればよいのかわかりません。\n"
"この場合ライブラリのコードには、ユーザがアクセスできるヒープを使用 - Cの "
"`malloc` や `free` のように - し、その語、Rust的の意味での _所有権移転_ を行"
"うことが期待されます。"

#: src/patterns/ffi/export.md:104
msgid ""
"This may all seem speculative, but this is what a pointer means in C.\n"
"It means the same thing as Rust: \"user defined lifetime.\"\n"
"The user of the library needs to read the documentation in order to use it "
"correctly.\n"
"That said, there are some decisions that have fewer or greater consequences "
"if users\n"
"do it wrong. Minimizing those are what this best practice is about, and the "
"key\n"
"is to _transfer ownership of everything that is transparent_."
msgstr ""
"まったく観念的ですが、これこそがC言語におけるポインタの意味です。\n"
"これはRustにおける「ユーザー定義のライフタイム」と同じ意味です。\n"
"このライブラリのユーザーは、正しく使うためにドキュメントを読む必要がありま"
"す。\n"
"ドキュメントは、ユーザーが間違った使い方をした場合に、\n"
"大小さまざまな悪い結果をもたらす可能性があることについて記載されています。\n"
"それらを最小限にすることが、このベストプラクティスの目的であり、\n"
"_透過的であるものすべての所有権を移転すること_ が鍵なのです。"

#: src/patterns/ffi/export.md:113
msgid ""
"This minimizes the number of memory safety guarantees the user must uphold "
"to a\n"
"relatively small number:"
msgstr ""
"これにより、ユーザが守らなければならないメモリ安全性保証を、比較的少数に抑え"
"ます："

#: src/patterns/ffi/export.md:116
msgid ""
"1. Do not call any function with a pointer not returned by `dbm_open` "
"(invalid\n"
"   access or corruption).\n"
"2. Do not call any function on a pointer after close (use after free).\n"
"3. The `dptr` on any `datum` must be `NULL`, or point to a valid slice of "
"memory\n"
"   at the advertised length."
msgstr ""
"1. `dbm_open`が返していないポインタを使って関数を呼び出さないでください (無効"
"なアクセスや破損)。\n"
"2. close後のポインタを使って関数を呼び出さないでください（free の後に使用して"
"ください）。\n"
"3. `datum` の `dptr` は `NULL` であるか、または適切な長さの有効なメモリスライ"
"スを指している必要があります。"

#: src/patterns/ffi/export.md:122
msgid ""
"In addition, it avoids a lot of pointer provenance issues.\n"
"To understand why, let us consider an alternative in some depth: key "
"iteration."
msgstr ""
"さらに、ポインタの provenance に関する多くの問題を回避することができます。\n"
"その理由を理解するために、キーの反復という代替案について少し深く検討してみま"
"しょう。"

#: src/patterns/ffi/export.md:125
msgid ""
"Rust is well known for its iterators.\n"
"When implementing one, the programmer makes a separate type with a bounded "
"lifetime\n"
"to its owner, and implements the `Iterator` trait."
msgstr ""
"Rustはイテレータでよく知られています。\n"
"イテレータを実装する場合、プログラマは、所有型に対しライフタイムが制限された"
"別の型を作成し、 `Iterator` トレイトを実装します。"

#: src/patterns/ffi/export.md:129
msgid "Here is how iteration would be done in Rust for `DBM`:"
msgstr "以下は `DBM` に対して行われ得る Rust での反復処理の方法です："

#: src/patterns/ffi/export.md:131
msgid ""
"```rust,ignore\n"
"struct Dbm { ... }\n"
"\n"
"impl Dbm {\n"
"    /* ... */\n"
"    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
"    /* ... */\n"
"}\n"
"\n"
"struct DbmKeysIter<'it> {\n"
"    owner: &'it Dbm,\n"
"}\n"
"\n"
"impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct Dbm { ... }\n"
"\n"
"impl Dbm {\n"
"    /* ... */\n"
"    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }\n"
"    /* ... */\n"
"}\n"
"\n"
"struct DbmKeysIter<'it> {\n"
"    owner: &'it Dbm,\n"
"}\n"
"\n"
"impl<'it> Iterator for DbmKeysIter<'it> { ... }\n"
"```"

#: src/patterns/ffi/export.md:147
msgid ""
"This is clean, idiomatic, and safe. thanks to Rust's guarantees.\n"
"However, consider what a straightforward API translation would look like:"
msgstr ""
"これはクリーンでイディオム的で安全です。Rustの保障によるものです。\n"
"しかし、APIの簡素な翻訳がどのようになるかを考えてみましょう："

#: src/patterns/ffi/export.md:150
msgid ""
"```rust,ignore\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_next(\n"
"    iter: *mut DbmKeysIter,\n"
"    key_out: *const datum\n"
") -> libc::c_int {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
"    // THIS API IS A BAD IDEA! For real applications, use object-based "
"design instead.\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {\n"
"    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの設"
"計を使用してください。\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_next(\n"
"    iter: *mut DbmKeysIter,\n"
"    key_out: *const datum\n"
") -> libc::c_int {\n"
"    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの設"
"計を使用してください。\n"
"}\n"
"#[no_mangle]\n"
"pub extern \"C\" fn dbm_iter_del(*mut DbmKeysIter) {\n"
"    // このAPIは悪い例です! 実際のアプリケーションではオブジェクトベースの設"
"計を使用してください。\n"
"}\n"
"```"

#: src/patterns/ffi/export.md:168
msgid ""
"This API loses a key piece of information: the lifetime of the iterator must "
"not\n"
"exceed the lifetime of the `Dbm` object that owns it. A user of the library "
"could\n"
"use it in a way which causes the iterator to outlive the data it is "
"iterating on,\n"
"resulting in reading uninitialized memory."
msgstr ""
"このAPIは重要な情報を失っています。それは、イテレータのライフタイムはそれを所"
"有する `Dbm` オブジェクトのライフタイムを超えてはいけない、ということです。\n"
"ライブラリのユーザは反復対象のデータよりも長生きするイテレータを使用してしま"
"う可能性があります。\n"
"その結果、初期化されていないメモリを読み込むことになります。"

#: src/patterns/ffi/export.md:173
msgid ""
"This example written in C contains a bug that will be explained afterwards:"
msgstr "C言語で書かれたこの例には後述するバグがあります："

#: src/patterns/ffi/export.md:175
msgid ""
"```C\n"
"int count_key_sizes(DBM *db) {\n"
"    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!\n"
"    datum key;\n"
"    int len = 0;\n"
"\n"
"    if (!dbm_iter_new(db)) {\n"
"        dbm_close(db);\n"
"        return -1;\n"
"    }\n"
"\n"
"    int l;\n"
"    while ((l = dbm_iter_next(owner, &key)) >= 0) { // an error is indicated "
"by -1\n"
"        free(key.dptr);\n"
"        len += key.dsize;\n"
"        if (l == 0) { // end of the iterator\n"
"            dbm_close(owner);\n"
"        }\n"
"    }\n"
"    if l >= 0 {\n"
"        return -1;\n"
"    } else {\n"
"        return len;\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```C\n"
"int count_key_sizes(DBM *db) {\n"
"    // この関数は使わないでください。微妙な、しかし重大なバグがあります!\n"
"    datum key;\n"
"    int len = 0;\n"
"\n"
"    if (!dbm_iter_new(db)) {\n"
"        dbm_close(db);\n"
"        return -1;\n"
"    }\n"
"\n"
"    int l;\n"
"    while ((l = dbm_iter_next(owner, &key)) >= 0) { // エラーを -1 で示しま"
"す\n"
"        free(key.dptr);\n"
"        len += key.dsize;\n"
"        if (l == 0) { // 反復終了\n"
"            dbm_close(owner);\n"
"        }\n"
"    }\n"
"    if l >= 0 {\n"
"        return -1;\n"
"    } else {\n"
"        return len;\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/export.md:202
msgid ""
"This bug is a classic. Here's what happens when the iterator returns the\n"
"end-of-iteration marker:"
msgstr ""
"このバグは古典的なものです。イテレータが反復完了を返したときに起こります："

#: src/patterns/ffi/export.md:205
msgid ""
"1. The loop condition sets `l` to zero, and enters the loop because `0 >= "
"0`.\n"
"2. The length is incremented, in this case by zero.\n"
"3. The if statement is true, so the database is closed. There should be a "
"break\n"
"   statement here.\n"
"4. The loop condition executes again, causing a `next` call on the closed "
"object."
msgstr ""
"1. ループの条件式は `l` を 0 に設定し、`0 >= 0` なのでループに入ります。\n"
"2. len が計上されます。この場合 0 です。\n"
"3. if文は真なので、データベースは閉じられます。ここで break文があるはずでし"
"た。\n"
"4. ループの条件式が再度実行され、closeされたオブジェクトに対して `next` が呼"
"び出されます。"

#: src/patterns/ffi/export.md:211
msgid ""
"The worst part about this bug?\n"
"If the Rust implementation was careful, this code will work most of the "
"time!\n"
"If the memory for the `Dbm` object is not immediately reused, an internal "
"check\n"
"will almost certainly fail, resulting in the iterator returning a `-1` "
"indicating\n"
"an error. But occasionally, it will cause a segmentation fault, or even "
"worse,\n"
"nonsensical memory corruption!"
msgstr ""
"このバグで最悪なことはなんでしょう？\n"
"Rustの実装が慎重なものであれば、このコードはほとんどの場合動いてしまいま"
"す！\n"
"もし `Dbm` オブジェクトのメモリがすぐに再利用されなければ、内部チェックはほぼ"
"確実に失敗し、\n"
"イテレータはエラーを示す `-1` を返します。\n"
"しかし、時にはセグメンテーションフォールトを引き起こしたり、さらに悪いことに"
"わけのわからないメモリ破壊を引き起こすこともあります！"

#: src/patterns/ffi/export.md:218
msgid ""
"None of this can be avoided by Rust.\n"
"From its perspective, it put those objects on its heap, returned pointers to "
"them,\n"
"and gave up control of their lifetimes. The C code simply must \"play nice\"."
msgstr ""
"Rust側はこのどれも避けようがありません。\n"
"Rust側から見れば、オブジェクトをヒープに置き、ポインタを返し、そのライフタイ"
"ムの制御を任せたことになります。\n"
"Cコードが「うまくやる」しかないのです。"

#: src/patterns/ffi/export.md:222
msgid ""
"The programmer must read and understand the API documentation.\n"
"While some consider that par for the course in C, a good API design can "
"mitigate\n"
"this risk. The POSIX API for `DBM` did this by _consolidating the ownership_ "
"of\n"
"the iterator with its parent:"
msgstr ""
"プログラマーはAPIドキュメントを読み、理解しなければなりません。\n"
"C言語では当然のことだと考える人もいますが、優れたAPI設計はこのリスクを軽減す"
"ることができます。\n"
"`DBM` の POSIX API ではイテレータの _所有権をその親に統合する_ ことによりこれ"
"を実現しています。"

#: src/patterns/ffi/export.md:227
msgid ""
"```C\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"```"
msgstr ""
"```C\n"
"datum   dbm_firstkey(DBM *);\n"
"datum   dbm_nextkey(DBM *);\n"
"```"

#: src/patterns/ffi/export.md:232
msgid ""
"Thus, all the lifetimes were bound together, and such unsafety was prevented."
msgstr ""
"こうして、すべてのライフタイムが一つにまとめられ、このような安全性の欠如が予"
"防されています。"

#: src/patterns/ffi/export.md:236
msgid ""
"However, this design choice also has a number of drawbacks, which should be\n"
"considered as well."
msgstr ""
"しかしながら、この設計の選択にはいくつかの欠点があり、十分に検討すべきです。"

#: src/patterns/ffi/export.md:239
msgid ""
"First, the API itself becomes less expressive.\n"
"With POSIX DBM, there is only one iterator per object, and every call "
"changes\n"
"its state. This is much more restrictive than iterators in almost any "
"language,\n"
"even though it is safe. Perhaps with other related objects, whose lifetimes "
"are\n"
"less hierarchical, this limitation is more of a cost than the safety."
msgstr ""
"まず、API自体の表現力が低下します。\n"
"POSIX DBMでは、1つのオブジェクトにつきイテレータは1つしかありません。\n"
"また呼び出しにより状態が変更されます。\n"
"これは、安全であるとはいえ、ほとんどすべての言語のイテレータよりもはるかに制"
"限的なものです。\n"
"おそらく、ライフタイムはそれほど階層的でない他の関連オブジェクトについて"
"は、\n"
"この制限は安全性よりもコストになります。"

#: src/patterns/ffi/export.md:245
msgid ""
"Second, depending on the relationships of the API's parts, significant "
"design effort\n"
"may be involved. Many of the easier design points have other patterns "
"associated\n"
"with them:"
msgstr ""
"次に、APIの部品の関係によっては、設計に多大な労力が必要になるかもしれませ"
"ん。\n"
"より簡単な設計点の多くには、他のパターンが関係しています："

#: src/patterns/ffi/export.md:249
msgid ""
"- [Wrapper Type Consolidation](./wrappers.md) groups multiple Rust types "
"together\n"
"  into an opaque \"object\"\n"
"\n"
"- [FFI Error Passing](../../idioms/ffi/errors.md) explains error handling "
"with integer\n"
"  codes and sentinel return values (such as `NULL` pointers)\n"
"\n"
"- [Accepting Foreign Strings](../../idioms/ffi/accepting-strings.md) allows "
"accepting\n"
"  strings with minimal unsafe code, and is easier to get right than\n"
"  [Passing Strings to FFI](../../idioms/ffi/passing-strings.md)"
msgstr ""
"- [ラッパーへの型の統合](./wrappers.md)は、複数のRustタイプを不透明な「オブ"
"ジェクト」にまとめます。\n"
"\n"
"- [FFI のエラー処理](../../idioms/ffi/errors.md) では整数コードと番兵の戻り"
"値 (`NULL` ポインタなど) によるエラー処理について説明しています。\n"
"\n"
"- [文字列の受け入れ](../../idioms/ffi/accepting-strings.md) は、安全でない"
"コードを最小限に抑えて文字列を受け入れることができます。\n"
"  [文字列の受け渡し](../../idioms/ffi/passing-strings.md) よりも簡単に正しく"
"できます。"

#: src/patterns/ffi/export.md:259
msgid ""
"However, not every API can be done this way.\n"
"It is up to the best judgement of the programmer as to who their audience is."
msgstr ""
"しかしながら、すべてのAPIがこの方法でできるわけではありません。\n"
"利用者が誰であるか、プログラマの最善の判断次第です。"

#: src/patterns/ffi/wrappers.md:1
msgid "# Type Consolidation into Wrappers"
msgstr "# ラッパーへの型の統合"

#: src/patterns/ffi/wrappers.md:5
msgid ""
"This pattern is designed to allow gracefully handling multiple related "
"types,\n"
"while minimizing the surface area for memory unsafety."
msgstr ""
"このパターンは、メモリ安全性の損なわれる表面面積を最小化しつつ、\n"
"関連する複数の型を優雅に扱えるように設計されています。"

#: src/patterns/ffi/wrappers.md:8
msgid ""
"One of the cornerstones of Rust's aliasing rules is lifetimes.\n"
"This ensures that many patterns of access between types can be memory safe,\n"
"data race safety included."
msgstr ""
"Rustのエイリアシングルールの基礎の1つはライフタイムです。\n"
"これにより、型間のアクセスの多くのパターン(データ競合の安全性を含む)がメモリ"
"セーフになります。"

#: src/patterns/ffi/wrappers.md:12
msgid ""
"However, when Rust types are exported to other languages, they are usually "
"transformed\n"
"into pointers. In Rust, a pointer means \"the user manages the lifetime of "
"the pointee.\"\n"
"It is their responsibility to avoid memory unsafety."
msgstr ""
"しかし、Rustの型が他の言語にエクスポートされる場合、通常はポインタに変換され"
"ます。\n"
"Rustでは、ポインタは「ポインタが指すオブジェクトのライフタイムを、ユーザが管"
"理する」ことを意味します。\n"
"メモリの安全性が損なわれないようにすることは、ユーザの責務です。"

#: src/patterns/ffi/wrappers.md:16
msgid ""
"Some level of trust in the user code is thus required, notably around use-"
"after-free\n"
"which Rust can do nothing about. However, some API designs place higher "
"burdens\n"
"than others on the code written in the other language."
msgstr ""
"そのため、ユーザーコードにはある程度の信頼性が要求されます。Rust ではどうしよ"
"うもない 「使用後にfreeすること」 については特にこの通りです。\n"
"とはいえ、APIの設計によっては、ほかの言語によって記述されたコードと比して、高"
"い負担を強いることがあります。"

#: src/patterns/ffi/wrappers.md:20
msgid ""
"The lowest risk API is the \"consolidated wrapper\", where all possible "
"interactions\n"
"with an object are folded into a \"wrapper type\", while keeping the Rust "
"API clean."
msgstr ""
"最もリスクの低いAPIは「統合ラッパー」です。\n"
"RustのAPIをクリーンに保ちながら、オブジェクトとの間のやりとりはすべて「ラッ"
"パー型」に折り畳むものです。"

#: src/patterns/ffi/wrappers.md:25
msgid ""
"To understand this, let us look at a classic example of an API to export: "
"iteration\n"
"through a collection."
msgstr ""
"これを理解するために、エクスポートするAPIの典型的な例として「コレクションのイ"
"テレーション」を見てみましょう。"

#: src/patterns/ffi/wrappers.md:28
msgid "That API looks like this:"
msgstr "このAPIは以下の通りです："

#: src/patterns/ffi/wrappers.md:30
msgid ""
"1. The iterator is initialized with `first_key`.\n"
"2. Each call to `next_key` will advance the iterator.\n"
"3. Calls to `next_key` if the iterator is at the end will do nothing.\n"
"4. As noted above, the iterator is \"wrapped into\" the collection (unlike "
"the native\n"
"   Rust API)."
msgstr ""
"1. イテレータは `first_key` で初期化されます。\n"
"2. `next_key` を呼び出すたびにイテレータが進みます。\n"
"3. イテレータが末尾にある場合に `next_key` を呼び出しても何も起こりません。\n"
"4. 上述の通り、イテレータはコレクションに「ラップ」されます(Rust ネイティブ "
"のAPI とは異なる部分です)。"

#: src/patterns/ffi/wrappers.md:36
msgid ""
"If the iterator implements `nth()` efficiently, then it is possible to make "
"it\n"
"ephemeral to each function call:"
msgstr ""
"イテレータが `nth()` を効率的に実装しているならば、\n"
"関数の各呼び出しに対してイテレータを短命なものとすることが可能です。"

#: src/patterns/ffi/wrappers.md:39
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"}\n"
"\n"
"impl MySetWrapper {\n"
"    pub fn first_key(&mut self) -> Option<&Key> {\n"
"        self.iter_next = 0;\n"
"        self.next_key()\n"
"    }\n"
"    pub fn next_key(&mut self) -> Option<&Key> {\n"
"        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
"            self.iter_next += 1;\n"
"            Some(next)\n"
"        } else {\n"
"            None\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"}\n"
"\n"
"impl MySetWrapper {\n"
"    pub fn first_key(&mut self) -> Option<&Key> {\n"
"        self.iter_next = 0;\n"
"        self.next_key()\n"
"    }\n"
"    pub fn next_key(&mut self) -> Option<&Key> {\n"
"        if let Some(next) = self.myset.keys().nth(self.iter_next) {\n"
"            self.iter_next += 1;\n"
"            Some(next)\n"
"        } else {\n"
"            None\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:61
msgid "As a result, the wrapper is simple and contains no `unsafe` code."
msgstr "結果、ラッパーはシンプルで、 `unsafe` コードを含みません。"

#: src/patterns/ffi/wrappers.md:65
msgid ""
"This makes APIs safer to use, avoiding issues with lifetimes between types.\n"
"See [Object-Based APIs](./export.md) for more on the advantages and "
"pitfalls\n"
"this avoids."
msgstr ""
"これにより、APIをより安全に使用できるようになり、型間のライフタイムの問題を避"
"けることができます。\n"
"[オブジェクトベースのAPI](./export.md) には、この利点と、これにより回避できる"
"落とし穴についてさらなる記載があります。"

#: src/patterns/ffi/wrappers.md:71
msgid ""
"Often, wrapping types is quite difficult, and sometimes a Rust API "
"compromise\n"
"would make things easier."
msgstr ""
"多くの場合、型のラッピングは非常に難しいものです。事を簡単にするために Rust "
"API を妥協することになるかもしれません。"

#: src/patterns/ffi/wrappers.md:74
msgid ""
"As an example, consider an iterator which does not efficiently implement "
"`nth()`.\n"
"It would definitely be worth putting in special logic to make the object "
"handle\n"
"iteration internally, or to support a different access pattern efficiently "
"that\n"
"only the Foreign Function API will use."
msgstr ""
"例として、`nth()` の実装が効率的でないイテレータを考えてみましょう。\n"
"オブジェクトに内部にて反復を処理するような特殊なロジックを組むことや、\n"
"FFI の API から使用されるためだけに効率的に異なるアクセスパターンをサポートす"
"ること、\n"
"これらには間違いなく価値があります。"

#: src/patterns/ffi/wrappers.md:79
msgid "### Trying to Wrap Iterators (and Failing)"
msgstr "### イテレータのラップに挑戦(そして失敗)"

#: src/patterns/ffi/wrappers.md:81
msgid ""
"To wrap any type of iterator into the API correctly, the wrapper would need "
"to\n"
"do what a C version of the code would do: erase the lifetime of the "
"iterator,\n"
"and manage it manually."
msgstr ""
"どのようなタイプのイテレータでもAPIに正しくラップするためには、ラッパーはC"
"バージョンのコードが行うようなことを行う必要があります。つまりイテレータのラ"
"イフタイムを消去し、それを手動で管理することです。"

#: src/patterns/ffi/wrappers.md:85
msgid "Suffice it to say, this is _incredibly_ difficult."
msgstr "言うまでもなく、これは _信じられないほど_ 難しいことです。"

#: src/patterns/ffi/wrappers.md:87
msgid "Here is an illustration of just _one_ pitfall."
msgstr "ここで、 落とし穴をたった _ひとつ_ 、ご紹介しましょう。"

#: src/patterns/ffi/wrappers.md:89
msgid "A first version of `MySetWrapper` would look like this:"
msgstr "最初のバージョンの `MySetWrapper` は次のようになります："

#: src/patterns/ffi/wrappers.md:91
msgid ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"    // created from a transmuted Box<KeysIter + 'self>\n"
"    iterator: Option<NonNull<KeysIter<'static>>>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct MySetWrapper {\n"
"    myset: MySet,\n"
"    iter_next: usize,\n"
"    // Box<KeysIter + 'self> を transmute して作成\n"
"    iterator: Option<NonNull<KeysIter<'static>>>,\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:100
msgid ""
"With `transmute` being used to extend a lifetime, and a pointer to hide it,\n"
"it's ugly already. But it gets even worse: _any other operation can cause\n"
"Rust `undefined behaviour`_."
msgstr ""
"`transmute` は寿命の延長に使われ、ポインタはそれを隠すのに使われます。\n"
"もうすでに醜いですね。しかし、さらに悪くなります： _他のあらゆる操作がRust "
"の `未定義の動作` を引き起こします_ 。"

#: src/patterns/ffi/wrappers.md:104
msgid ""
"Consider that the `MySet` in the wrapper could be manipulated by other\n"
"functions during iteration, such as storing a new value to the key it was\n"
"iterating over. The API doesn't discourage this, and in fact some similar C\n"
"libraries expect it."
msgstr ""
"ラッパー内の `MySet` は、イテレーション中に他の関数によって操作される可能性が"
"あります。\n"
"例えば、イテレーション中に新しい値を格納するなどです。APIはこれを禁じておら"
"ず、実際のところ同様のCライブラリの中にはこれを想定しているものもあります。"

#: src/patterns/ffi/wrappers.md:109
msgid "A simple implementation of `myset_store` would be:"
msgstr "`myset_store` の単純な実装は次のようになります："

#: src/patterns/ffi/wrappers.md:111
msgid ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // other module content\n"
"\n"
"    pub fn myset_store(\n"
"        myset: *mut MySetWrapper,\n"
"        key: datum,\n"
"        value: datum) -> libc::c_int {\n"
"\n"
"        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.\n"
"\n"
"        let myset: &mut MySet = unsafe { // SAFETY: whoops, UB occurs in "
"here!\n"
"            &mut (*myset).myset\n"
"        };\n"
"\n"
"        /* ...check and cast key and value data... */\n"
"\n"
"        match myset.store(casted_key, casted_value) {\n"
"            Ok(_) => 0,\n"
"            Err(e) => e.into()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"pub mod unsafe_module {\n"
"\n"
"    // モジュールの他のコンテンツ\n"
"\n"
"    pub fn myset_store(\n"
"        myset: *mut MySetWrapper,\n"
"        key: datum,\n"
"        value: datum) -> libc::c_int {\n"
"\n"
"        // このコードを使用しないでください。不具合を実証することは危険で"
"す。\n"
"\n"
"        let myset: &mut MySet = unsafe { // SAFETY: あぁ・・・ここで UB が発"
"生します！\n"
"            &mut (*myset).myset\n"
"        };\n"
"\n"
"        /* ...キーと値のデータをチェックし、キャスト... */\n"
"\n"
"        match myset.store(casted_key, casted_value) {\n"
"            Ok(_) => 0,\n"
"            Err(e) => e.into()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/patterns/ffi/wrappers.md:137
msgid ""
"If the iterator exists when this function is called, we have violated one of "
"Rust's\n"
"aliasing rules. According to Rust, the mutable reference in this block must "
"have\n"
"_exclusive_ access to the object. If the iterator simply exists, it's not "
"exclusive,\n"
"so we have `undefined behaviour`! "
msgstr ""
"この関数が呼ばれたときにイテレータが存在していた場合、Rustののエイリアシング"
"ルールに違反したことになります。\n"
"Rustによると、このブロック内の可変参照はオブジェクトへの _排他的_ アクセスで"
"なければなりません。\n"
"イテレータが単に存在しているだけで、排他的ではなくなります。よって "
"`undefined behaviour` が発生します!"

#: src/patterns/ffi/wrappers.md:142
msgid ""
"To avoid this, we must have a way of ensuring that mutable reference really "
"is exclusive.\n"
"That basically means clearing out the iterator's shared reference while it "
"exists,\n"
"and then reconstructing it. In most cases, that will still be less efficient "
"than\n"
"the C version."
msgstr ""
"これを避けるには、可変参照が本当に排他的であることを保証する方法を持たなけれ"
"ばなりません。\n"
"これは基本的に、イテレータの共有参照が存在する間にそれを消去し、後に再構築す"
"ることを意味します。\n"
"たいていの場合、それでもCのバージョンより効率は悪くなります。"

#: src/patterns/ffi/wrappers.md:147
msgid ""
"Some may ask: how can C do this more efficiently?\n"
"The answer is, it cheats. Rust's aliasing rules are the problem, and C "
"simply ignores\n"
"them for its pointers. In exchange, it is common to see code that is "
"declared\n"
"in the manual as \"not thread safe\" under some or all circumstances. In "
"fact,\n"
"the [GNU C library](https://manpages.debian.org/buster/manpages/attributes.7."
"en.html)\n"
"has an entire lexicon dedicated to concurrent behavior!"
msgstr ""
"Cではどうすればもっと効率的にできるのか？疑問に思う人もいるでしょう。\n"
"答えは・・・ズルです。Rustのエイリアシングルールが問題なのであり、Cではそのポ"
"インタについてルールを無視します。\n"
"その代わりに、マニュアルで特定の(もしくはすべての)状況にて「スレッドセーフで"
"はない」と宣言されているコードをよく見かけます。\n"
"実際に[GNU Cライブラリ](https://manpages.debian.org/buster/manpages/"
"attributes.7.en.html)には、\n"
"並列動作に特化した用語集があります！"

#: src/patterns/ffi/wrappers.md:154
msgid ""
"Rust would rather make everything memory safe all the time, for both safety "
"and\n"
"optimizations that C code cannot attain. Being denied access to certain "
"shortcuts\n"
"is the price Rust programmers need to pay."
msgstr ""
"むしろRustは、安全性とCコードでは達成できない最適化の両方を実現するために、す"
"べてを常にメモリセーフにします。\n"
"特定のショートカットへのアクセスを拒否されることは、Rustプログラマが支払う価"
"値のある代償です。"

#: src/patterns/ffi/wrappers.md:158
msgid ""
"For the C programmers out there scratching their heads, the iterator need\n"
"not be read _during_ this code cause the UB. The exclusivity rule also "
"enables\n"
"compiler optimizations which may cause inconsistent observations by the "
"iterator's\n"
"shared reference (e.g. stack spills or reordering instructions for "
"efficiency).\n"
"These observations may happen _any time after_ the mutable reference is "
"created."
msgstr ""
"頭を悩ませているCプログラマーのために言っておくと、UBを引き起こすこのコード中"
"の間に、イテレータを読み出す必要はありません。\n"
"また排他的ルールはコンパイラの一部の最適化を有効にしますが、これはイテレータ"
"の共有参照からみて一貫性のない現象(例えば、スタックの漏洩や、効率化のための命"
"令の並び替え)を引き起こすことがあります。\n"
"このような現象は、 可変参照を生成した後は _いつでも_ 発生する可能性がありま"
"す。"

#: src/anti_patterns/index.md:1
msgid "# Anti-patterns"
msgstr "# アンチパターン"

#: src/anti_patterns/index.md:3
msgid ""
"An [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) is a solution "
"to\n"
"a \"recurring problem that is usually ineffective and risks being highly\n"
"counterproductive\". Just as valuable as knowing how to solve a problem, is\n"
"knowing how _not_ to solve it. Anti-patterns give us great counter-examples "
"to\n"
"consider relative to design patterns. Anti-patterns are not confined to "
"code.\n"
"For example, a process can be an anti-pattern, too."
msgstr ""
"[アンチパターン](https://en.wikipedia.org/wiki/Anti-pattern)とは\n"
"「通常、効果がなく、大きな逆効果になるリスクのある、頻繁に見られる問題のある"
"こと」に対するソリューションです。\n"
"問題を解決する方法を知ることと同じくらい価値があるのは、問題を解決しない方法"
"を知ることです。\n"
"アンチパターンは、デザインパターンに対して、考慮すべき素晴らしい反例を与えて"
"くれます。\n"
"アンチパターンはコードに限ったことではありません。\n"
"例えば、プロセスもアンチパターンになりえます。"

#: src/anti_patterns/borrow_clone.md:1
msgid "# Clone to satisfy the borrow checker"
msgstr "# 借用チェッカーを満足させるためのクローン"

#: src/anti_patterns/borrow_clone.md:5
msgid ""
"The borrow checker prevents Rust users from developing otherwise unsafe code "
"by\n"
"ensuring that either: only one mutable reference exists, or potentially many "
"but\n"
"all immutable references exist. If the code written does not hold true to "
"these\n"
"conditions, this anti-pattern arises when the developer resolves the "
"compiler\n"
"error by cloning the variable."
msgstr ""
"借用チェッカーは、Rustユーザが安全でないコードを開発することを、次のことを確"
"保することで防ぎます：\n"
"1つだけの可変参照が存在するか、もしくは幾つでもよいがすべて不変である参照が存"
"在すること。\n"
"もし書かれたコードがこれらの条件を満たさない場合に、\n"
"コンパイラのエラーを解決するために開発者が変数のクローンを作成したとき、\n"
"このアンチパターンが発生します。"

#: src/anti_patterns/borrow_clone.md:13
msgid ""
"```rust\n"
"// define any variable\n"
"let mut x = 5;\n"
"\n"
"// Borrow `x` -- but clone it first\n"
"let y = &mut (x.clone());\n"
"\n"
"// without the x.clone() two lines prior, this line would fail on compile "
"as\n"
"// x has been borrowed\n"
"// thanks to x.clone(), x was never borrowed, and this line will run.\n"
"println!(\"{}\", x);\n"
"\n"
"// perform some action on the borrow to prevent rust from optimizing this\n"
"//out of existence\n"
"*y += 1;\n"
"```"
msgstr ""
"```rust\n"
"// 変数を定義\n"
"let mut x = 5;\n"
"\n"
"// `x` を借用 -- ただし、先だってクローンする\n"
"let y = &mut (x.clone());\n"
"\n"
"// 2行前の x.clone() 無しでは、xが借用されているためこの行がコンパイルエラー"
"になります。\n"
"// x.clone() により、 x は借用されていないため、この行が動作します。\n"
"println!(\"{}\", x);\n"
"\n"
"// Rust がこれを消去する形の最適化を防ぐため、何らかの操作をします。\n"
"*y += 1;\n"
"```"

#: src/anti_patterns/borrow_clone.md:32
msgid ""
"It is tempting, particularly for beginners, to use this pattern to resolve\n"
"confusing issues with the borrow checker. However, there are serious\n"
"consequences. Using `.clone()` causes a copy of the data to be made. Any "
"changes\n"
"between the two are not synchronized -- as if two completely separate "
"variables\n"
"exist."
msgstr ""
"特に初心者の方にとっては、借入チェッカーによるややこしい問題を、このパターン"
"を使って解決したくなるものです。\n"
"しかし、この方法は深刻な悪影響があります。\n"
"`.clone()` を使うと、存在するデータのコピーが作成されます。\n"
"この2つの間の変更は同期されません -- 完全に別の2つの変数が存在することと同じ"
"です。"

#: src/anti_patterns/borrow_clone.md:38
msgid ""
"There are special cases -- `Rc<T>` is designed to handle clones "
"intelligently.\n"
"It internally manages exactly one copy of the data, and cloning it will "
"only\n"
"clone the reference."
msgstr ""
"特別なケースがあります -- `Rc<T>` はクローンをインテリジェントに扱うように設"
"計されています。\n"
"内部的にデータのコピーを1つだけ持っており、クローンを作成しても参照だけをク"
"ローンします。"

#: src/anti_patterns/borrow_clone.md:42
msgid ""
"There is also `Arc<T>` which provides shared ownership of a value of type T\n"
"that is allocated in the heap. Invoking `.clone()` on `Arc` produces a new "
"`Arc`\n"
"instance, which points to the same allocation on the heap as the source "
"`Arc`,\n"
"while increasing a reference count."
msgstr ""
"また、ヒープに確保されたT型の値に対する共有所有権を提供する `Arc<T>` もありま"
"す。\n"
"`Arc` に対して `.clone()` を呼び出すと、新しい `Arc` インスタンスが生成されま"
"すが、\n"
"このインスタンスは元とヒープの同じ値を指しています。また同時に、参照カウンタ"
"がインクリメントされます。"

#: src/anti_patterns/borrow_clone.md:47
msgid ""
"In general, clones should be deliberate, with full understanding of the\n"
"consequences. If a clone is used to make a borrow checker error disappear,\n"
"that's a good indication this anti-pattern may be in use."
msgstr ""
"一般に、クローンはその影響を十全に理解し、意図的に行われるべきものです。\n"
"もしも借用チェッカーのエラーを消すためにクローンが使われてるなら、それはこの"
"アンチパターンの使われている可能性を示す兆候と言えます。"

#: src/anti_patterns/borrow_clone.md:51
msgid ""
"Even though `.clone()` is an indication of a bad pattern, sometimes\n"
"**it is fine to write inefficient code**, in cases such as when:"
msgstr ""
"`.clone()` は悪しきパターンの表れですが、ときに **非効率なコードを書いてもよ"
"い** こともあります。\n"
"次のようなケースです："

#: src/anti_patterns/borrow_clone.md:54
msgid ""
"- the developer is still new to ownership\n"
"- the code doesn't have great speed or memory constraints\n"
"  (like hackathon projects or prototypes)\n"
"- satisfying the borrow checker is really complicated, and you prefer to\n"
"  optimize readability over performance"
msgstr ""
"- 開発者が所有権に慣れていない\n"
"- コードの速度やメモリに大きな制約がない場合\n"
"  (ハッカソンプロジェクトやプロトタイプなど)\n"
"- 借用チェッカーを満足させることが本当に複雑で難しく、\n"
"  パフォーマンスよりも読みやすさを最適化したい"

#: src/anti_patterns/borrow_clone.md:60
msgid ""
"If an unnecessary clone is suspected, The [Rust Book's chapter on Ownership]"
"(https://doc.rust-lang.org/book/ownership.html)\n"
"should be understood fully before assessing whether the clone is required or "
"not."
msgstr ""
"不必要なクローンが疑われる場合、[Rust Book の所有権の章](https://doc.rust-"
"lang.org/book/ownership.html)\n"
"を十分に理解した上で、クローンが必要かどうかを判断してください。"

#: src/anti_patterns/borrow_clone.md:63
msgid ""
"Also be sure to always run `cargo clippy` in your project, which will detect "
"some\n"
"cases in which `.clone()` is not necessary, like [1](https://rust-lang."
"github.io/rust-clippy/master/index.html#redundant_clone),\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_on_copy),\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) or "
"[4](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_double_ref)."
msgstr ""
"また、プロジェクト内で常に `cargo clippy` を実行するようにしてください。\n"
"これは[1](https://rust-lang.github.io/rust-clippy/master/index."
"html#redundant_clone)、\n"
"[2](https://rust-lang.github.io/rust-clippy/master/index."
"html#clone_on_copy)、\n"
"[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone)、[4]"
"(https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref)"
"のような `clone()` が不要なケースをいくつか検出します。"

#: src/anti_patterns/borrow_clone.md:70
msgid ""
"- [`mem::{take(_), replace(_)}` to keep owned values in changed enums](../"
"idioms/mem-replace.md)\n"
"- [`Rc<T>` documentation, which handles .clone() intelligently](http://doc."
"rust-lang.org/std/rc/)\n"
"- [`Arc<T>` documentation, a thread-safe reference-counting pointer](https://"
"doc.rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Tricks with ownership in Rust](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"
msgstr ""
"- [変更するenum値の所有された値を維持する `mem::{take(_), replace(_)}`](../"
"idioms/mem-replace.md)\n"
"- [`Rc<T>` のドキュメント ( .clone() をインテリジェントに扱う)](http://doc."
"rust-lang.org/std/rc/)\n"
"- [`Arc<T>` のドキュメント (スレッドセーフな参照カウンタ付きポインタ)]"
"(https://doc.rust-lang.org/std/sync/struct.Arc.html)\n"
"- [Rust における所有権のトリック](https://web.archive.org/web/20210120233744/"
"https://xion.io/post/code/rust-borrowchk-tricks.html)"

#: src/anti_patterns/deny-warnings.md:1
msgid "# `#![deny(warnings)]`"
msgstr "# `#![deny(warnings)]`"

#: src/anti_patterns/deny-warnings.md:5
msgid ""
"A well-intentioned crate author wants to ensure their code builds without\n"
"warnings. So they annotate their crate root with the following:"
msgstr ""
"善意のあるcrate作成者は、自分たちのコードが警告なしでビルドされることを保証し"
"たいと考えています。\n"
"そこで、彼らはcrateのルートに次のようなアノテーションを付けます："

#: src/anti_patterns/deny-warnings.md:10
msgid ""
"```rust\n"
"#![deny(warnings)]\n"
"\n"
"// All is well.\n"
"```"
msgstr ""
"```rust\n"
"#![deny(warnings)]\n"
"\n"
"// すべて問題なし\n"
"```"

#: src/anti_patterns/deny-warnings.md:18
msgid "It is short and will stop the build if anything is amiss."
msgstr "これは簡単で、もし何か間違いがあるならビルドが止まります。"

#: src/anti_patterns/deny-warnings.md:20
msgid "## Drawbacks"
msgstr "## デメリット"

#: src/anti_patterns/deny-warnings.md:22
msgid ""
"By disallowing the compiler to build with warnings, a crate author opts out "
"of\n"
"Rust's famed stability. Sometimes new features or old misfeatures need a "
"change\n"
"in how things are done, thus lints are written that `warn` for a certain "
"grace\n"
"period before being turned to `deny`."
msgstr ""
"コンパイラが警告付きでビルドすることを禁止することにより、\n"
"Rustの有名な安定性から、crate作成者が切り離されてしまうことになります。\n"
"時に、新しい機能や古い問題ある機能により、物事の進め方を変える必要がでてくる"
"ことがあります。\n"
"このような場合に、lintは十分な一定の期間 `warn` し、その後に `deny` に切り替"
"えるように記述されます。"

#: src/anti_patterns/deny-warnings.md:27
msgid ""
"For example, it was discovered that a type could have two `impl`s with the "
"same\n"
"method. This was deemed a bad idea, but in order to make the transition "
"smooth,\n"
"the `overlapping-inherent-impls` lint was introduced to give a warning to "
"those\n"
"stumbling on this fact, before it becomes a hard error in a future release."
msgstr ""
"例えば、ある型が同じメソッドを持つ2つの`impl`を持つことができることが発見され"
"ました。\n"
"これは悪いアイデアだと判断されました。\n"
"しかしスムーズに移行するために、`overlapping-inherent-impls`というlintが導入"
"を導入し、\n"
"将来のリリースで完全なエラーとされる前に、この事実につまずいた人に警告を与え"
"るようにしました。"

#: src/anti_patterns/deny-warnings.md:32
msgid ""
"Also sometimes APIs get deprecated, so their use will emit a warning where\n"
"before there was none."
msgstr ""
"また、APIが非推奨になることもあります。この場合、それを使用していると、今まで"
"無かった警告が出るようになります。"

#: src/anti_patterns/deny-warnings.md:35
msgid ""
"All this conspires to potentially break the build whenever something changes."
msgstr ""
"これらすべてが、何かが変わるたびにビルドを壊してしまう可能性を持っています。"

#: src/anti_patterns/deny-warnings.md:37
msgid ""
"Furthermore, crates that supply additional lints (e.g. [rust-clippy]) can "
"no\n"
"longer be used unless the annotation is removed. This is mitigated with\n"
"[--cap-lints]. The `--cap-lints=warn` command line argument, turns all "
"`deny`\n"
"lint errors into warnings."
msgstr ""
"さらに、追加のlintを提供するcrate（[rust-clippy]など）は、このアノテーション"
"を削除しない限り使用できなくなりました。\n"
"これは[--cap-lints]で緩和されます。\n"
"コマンドライン引数に `--cap-lints=warn` を指定すると、すべての `deny` lint エ"
"ラーを警告に変えます。"

#: src/anti_patterns/deny-warnings.md:42
#: src/functional/generics-type-classes.md:227
msgid "## Alternatives"
msgstr "## 代替案"

#: src/anti_patterns/deny-warnings.md:44
msgid ""
"There are two ways of tackling this problem: First, we can decouple the "
"build\n"
"setting from the code, and second, we can name the lints we want to deny\n"
"explicitly."
msgstr ""
"この問題に対処する方法は2つあります。\n"
"一つは、コードからビルド設定を切り離すことです。\n"
"もう一つは、denyしたい lint を明示的に指定することです。"

#: src/anti_patterns/deny-warnings.md:48
msgid "The following command line will build with all warnings set to `deny`:"
msgstr ""
"次のコマンドラインは、すべての警告を `deny` に設定してビルドを行います："

#: src/anti_patterns/deny-warnings.md:50
msgid "`RUSTFLAGS=\"-D warnings\" cargo build`"
msgstr "`RUSTFLAGS=\"-D warnings\" cargo build`"

#: src/anti_patterns/deny-warnings.md:52
msgid ""
"This can be done by any individual developer (or be set in a CI tool like\n"
"Travis, but remember that this may break the build when something changes)\n"
"without requiring a change to the code."
msgstr ""
"これは個々の開発者が（あるいはTravisのようなCIツールでも。ただし変更があった"
"ときビルドが壊れる可能性に注意は必要）コードに変更を加えずに行えます。"

#: src/anti_patterns/deny-warnings.md:56
msgid ""
"Alternatively, we can specify the lints that we want to `deny` in the code.\n"
"Here is a list of warning lints that is (hopefully) safe to deny (as of "
"Rustc 1.48.0):"
msgstr ""
"あるいは、コード中で `deny` したいlintを指定することもできます。\n"
"以下は、(たぶん) 安全にdenyできる警告リントのリストです (Rustc 1.48.0 時点)："

#: src/anti_patterns/deny-warnings.md:59
msgid ""
"```rust,ignore\n"
"#![deny(bad_style,\n"
"       const_err,\n"
"       dead_code,\n"
"       improper_ctypes,\n"
"       non_shorthand_field_patterns,\n"
"       no_mangle_generic_items,\n"
"       overflowing_literals,\n"
"       path_statements,\n"
"       patterns_in_fns_without_body,\n"
"       private_in_public,\n"
"       unconditional_recursion,\n"
"       unused,\n"
"       unused_allocation,\n"
"       unused_comparisons,\n"
"       unused_parens,\n"
"       while_true)]\n"
"```"
msgstr ""
"```rust,ignore\n"
"#![deny(bad_style,\n"
"       const_err,\n"
"       dead_code,\n"
"       improper_ctypes,\n"
"       non_shorthand_field_patterns,\n"
"       no_mangle_generic_items,\n"
"       overflowing_literals,\n"
"       path_statements,\n"
"       patterns_in_fns_without_body,\n"
"       private_in_public,\n"
"       unconditional_recursion,\n"
"       unused,\n"
"       unused_allocation,\n"
"       unused_comparisons,\n"
"       unused_parens,\n"
"       while_true)]\n"
"```"

#: src/anti_patterns/deny-warnings.md:78
msgid ""
"In addition, the following `allow`ed lints may be a good idea to `deny`:"
msgstr "さらに、以下の`allow`されたリントを`deny`するのはよい考えでしょう："

#: src/anti_patterns/deny-warnings.md:80
msgid ""
"```rust,ignore\n"
"#![deny(missing_debug_implementations,\n"
"       missing_docs,\n"
"       trivial_casts,\n"
"       trivial_numeric_casts,\n"
"       unused_extern_crates,\n"
"       unused_import_braces,\n"
"       unused_qualifications,\n"
"       unused_results)]\n"
"```"
msgstr ""
"```rust,ignore\n"
"#![deny(missing_debug_implementations,\n"
"       missing_docs,\n"
"       trivial_casts,\n"
"       trivial_numeric_casts,\n"
"       unused_extern_crates,\n"
"       unused_import_braces,\n"
"       unused_qualifications,\n"
"       unused_results)]\n"
"```"

#: src/anti_patterns/deny-warnings.md:91
msgid "Some may also want to add `missing-copy-implementations` to their list."
msgstr ""
"また、`missing-copy-implementations` をリストに加えたい人もいるでしょう。"

#: src/anti_patterns/deny-warnings.md:93
msgid ""
"Note that we explicitly did not add the `deprecated` lint, as it is fairly\n"
"certain that there will be more deprecated APIs in the future."
msgstr ""
"`deprecated`のlintを明示的に追加していないことに注意してください。\n"
"将来的に非推奨のAPIが増えることは確実だからです。"

#: src/anti_patterns/deny-warnings.md:98
msgid ""
"- [A collection of all clippy lints](https://rust-lang.github.io/rust-clippy/"
"master)\n"
"- [deprecate attribute] documentation\n"
"- Type `rustc -W help` for a list of lints on your system. Also type\n"
"  `rustc --help` for a general list of options\n"
"- [rust-clippy] is a collection of lints for better Rust code"
msgstr ""
"- [すべての crippy lint](https://rust-lang.github.io/rust-clippy/master)\n"
"- [deprecated属性] のドキュメント\n"
"- `rustc -W help` と入力するとあなたのシステム上の lint のリストが表示されま"
"す。\n"
"  また`rustc --help` と入力すると一般的なオプションのリストが表示されます\n"
"- [rust-clippy] はより良い Rust コードのための lint のコレクションです"

#: src/anti_patterns/deref.md:1
msgid "# `Deref` polymorphism"
msgstr "# `Deref` ポリモーフィズム"

#: src/anti_patterns/deref.md:5
msgid ""
"Misuse the `Deref` trait to emulate inheritance between structs, and thus "
"reuse\n"
"methods."
msgstr ""
"構造体間の継承をエミュレートする目的での `Deref` トレイトの悪用。これによりメ"
"ソッドを再利用しようとすること。"

#: src/anti_patterns/deref.md:10
msgid ""
"Sometimes we want to emulate the following common pattern from OO languages "
"such\n"
"as Java:"
msgstr ""
"JavaのようなOO言語から、次のような一般的なパターンをエミュレートしたいことが"
"あります："

#: src/anti_patterns/deref.md:13
msgid ""
"```java\n"
"class Foo {\n"
"    void m() { ... }\n"
"}\n"
"\n"
"class Bar extends Foo {}\n"
"\n"
"public static void main(String[] args) {\n"
"    Bar b = new Bar();\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""
"```java\n"
"class Foo {\n"
"    void m() { ... }\n"
"}\n"
"\n"
"class Bar extends Foo {}\n"
"\n"
"public static void main(String[] args) {\n"
"    Bar b = new Bar();\n"
"    b.m();\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:26
msgid "We can use the deref polymorphism anti-pattern to do so:"
msgstr "deref ポリモーフィズムのアンチパターンを使い、これを行います："

#: src/anti_patterns/deref.md:28
msgid ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo,\n"
"}\n"
"\n"
"impl Deref for Bar {\n"
"    type Target = Foo;\n"
"    fn deref(&self) -> &Foo {\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} };\n"
"    b.m();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::ops::Deref;\n"
"\n"
"struct Foo {}\n"
"\n"
"impl Foo {\n"
"    fn m(&self) {\n"
"        //..\n"
"    }\n"
"}\n"
"\n"
"struct Bar {\n"
"    f: Foo,\n"
"}\n"
"\n"
"impl Deref for Bar {\n"
"    type Target = Foo;\n"
"    fn deref(&self) -> &Foo {\n"
"        &self.f\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    let b = Bar { f: Foo {} };\n"
"    b.m();\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:56
msgid ""
"There is no struct inheritance in Rust. Instead we use composition and "
"include\n"
"an instance of `Foo` in `Bar` (since the field is a value, it is stored "
"inline,\n"
"so if there were fields, they would have the same layout in memory as the "
"Java\n"
"version (probably, you should use `#[repr(C)]` if you want to be sure))."
msgstr ""
"Rustには構造体の継承はありません。\n"
"代わりにコンポジションを使用し、 `Foo` のインスタンスを `Bar` の持ち物にしま"
"す(\n"
"フィールドは値なのでインラインに保持されます。\n"
"したがってフィールドがあるのであれば、それらはJavaのバージョンと同じメモリレ"
"イアウトとなるでしょう(おそらくは。確実にそうしたいなら\n"
"`#[repr(C)]` を使うべきです))。"

#: src/anti_patterns/deref.md:61
msgid ""
"In order to make the method call work we implement `Deref` for `Bar` with "
"`Foo`\n"
"as the target (returning the embedded `Foo` field). That means that when we\n"
"dereference a `Bar` (for example, using `*`) then we will get a `Foo`. That "
"is\n"
"pretty weird. Dereferencing usually gives a `T` from a reference to `T`, "
"here we\n"
"have two unrelated types. However, since the dot operator does implicit\n"
"dereferencing, it means that the method call will search for methods on "
"`Foo` as\n"
"well as `Bar`."
msgstr ""
"メソッドコールを機能させるために、`Bar` に対して `Foo` をターゲットとして "
"`Deref` を実装します（埋め込まれた `Foo` フィールドを返します）。\n"
"これは (例えば `*` を使い) `Bar` を参照外しすると、 `Foo` が返されるというこ"
"とになります。\n"
"これはかなり奇怪なことです。\n"
"参照外しは通常 `T` の参照に対して `T` を返します。\n"
"例で扱っているのは２つの関連しない型です。\n"
"しかしながら、ドット演算子は暗黙的な参照外しを行うため、\n"
"メソッド呼び出しは `Bar` に対してと同様に `Foo` のメソッドを検索することにな"
"ります。"

#: src/anti_patterns/deref.md:71
msgid "You save a little boilerplate, e.g.,"
msgstr "ちょっとしたボイラーテンプレートを省けます。例えは、"

#: src/anti_patterns/deref.md:73
msgid ""
"```rust,ignore\n"
"impl Bar {\n"
"    fn m(&self) {\n"
"        self.f.m()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl Bar {\n"
"    fn m(&self) {\n"
"        self.f.m()\n"
"    }\n"
"}\n"
"```"

#: src/anti_patterns/deref.md:83
msgid ""
"Most importantly this is a surprising idiom - future programmers reading "
"this in\n"
"code will not expect this to happen. That's because we are misusing the "
"`Deref`\n"
"trait rather than using it as intended (and documented, etc.). It's also "
"because\n"
"the mechanism here is completely implicit."
msgstr ""
"最も重要なことは、これは人を驚かせるイディオムであるということです - \n"
"コードのこれを読む後のプログラマーは、このようなことが起こるとは思わないで"
"しょう。\n"
"これは私たちが `Deref` トレイトを、その意図(およびドキュメント等)に反して、誤"
"用しているからです。\n"
"またこのメカニズムは完全に暗黙的なものだからです。"

#: src/anti_patterns/deref.md:88
msgid ""
"This pattern does not introduce subtyping between `Foo` and `Bar` like\n"
"inheritance in Java or C++ does. Furthermore, traits implemented by `Foo` "
"are\n"
"not automatically implemented for `Bar`, so this pattern interacts badly "
"with\n"
"bounds checking and thus generic programming."
msgstr ""
"このパターンでは、JavaやC++の継承のように`Foo` と `Bar` の間に部分型を導入す"
"ることはありません。\n"
"さらに、 `Foo` で実装された trait は自動的に `Bar` で実装されるわけではありま"
"せん。\n"
"そのため、このパターンは境界チェックと相性が悪くなり、それゆえにジェネリック"
"プログラミングとの相性も悪くなります。"

# 2023/8/20 訳中思考メモ：
# いまいち意味がとれていない。どういうこと？
# (A)ほとんどのOO言語では：
# self (java なら this) は
# 「サブクラスへの参照」？そう？・・・うーん。
# 定義されているクラス、およびそのサブクラスへの参照というならわかる気はする。
# (B)このパターンでは：
# 「メソッドが定義されているクラス」。
# implしたstructで、ここではstructをクラスのように扱おうとしているのだから、ここだけなら、まぁ理解はできるような。
# (A)との対比を考える。
# `Foo` の impl 時の self は あくまで `Foo` である。
# これはパターンの意図するサブタイプ（を deref で模倣したもの)、これを含めた表現になっていない、という感じかな。
# `Bar` が `Foo` のサブタイプもどきのつもりだが、`Foo` の impl 内の self はサブタイプを含めた表現でない。
# これが表にでてくる状況はまずそうそうないんだろう。リフレクションとか出てくると影響しそうではある。
# いずれにせよ、動きだけ模倣して、意味的には異なる状態といのは、危うい。
# 言語仕様的なものと異なる意味を持たせると、理解しにくいだけでなく、言語仕様上の意味を前提にした言語拡張や第三者のライブラリ等々と組み合わせられなくなる。
#: src/anti_patterns/deref.md:93
msgid ""
"Using this pattern gives subtly different semantics from most OO languages "
"with\n"
"regards to `self`. Usually it remains a reference to the sub-class, with "
"this\n"
"pattern it will be the 'class' where the method is defined."
msgstr ""
"このパターンを使うことは、`self`に関して、ほとんどのOO言語とは微妙に異なるセ"
"マンティクスを与えます。\n"
"通常はこれはサブクラスに対する参照のままですが、このパターンではメソッドが定"
"義されている「クラス」に対するものになります。"

#: src/anti_patterns/deref.md:97
msgid ""
"Finally, this pattern only supports single inheritance, and has no notion "
"of\n"
"interfaces, class-based privacy, or other inheritance-related features. So, "
"it\n"
"gives an experience that will be subtly surprising to programmers used to "
"Java\n"
"inheritance, etc."
msgstr ""
"最後に、このパターンは単一継承のみをサポートし、インターフェイス、クラスベー"
"スのプライバシー、\n"
"その他の継承に関連する機能はありません。\n"
"そのためJavaの継承などに慣れているプログラマにとっては、微妙に驚くような経験"
"をすることになります。"

#: src/anti_patterns/deref.md:104
msgid ""
"There is no one good alternative. Depending on the exact circumstances it "
"might\n"
"be better to re-implement using traits or to write out the facade methods "
"to\n"
"dispatch to `Foo` manually. We do intend to add a mechanism for inheritance\n"
"similar to this to Rust, but it is likely to be some time before it reaches\n"
"stable Rust. See these [blog](http://aturon.github.io/blog/2015/09/18/"
"reuse/)\n"
"[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-"
"structs-part-4-extended-enums-and-thin-traits/)\n"
"and this [RFC issue](https://github.com/rust-lang/rfcs/issues/349) for more "
"details."
msgstr ""
"唯一の良い代替案はありません。\n"
"それぞれの状況によっては\n"
"トレイトを再実装するのがよいかもしれませんし、または手動で `Foo` にディスパッ"
"チするファサードメソッドを書くのがよいかもしれません。\n"
"このような継承の仕組みがRustに追加されようとしていますが、しかし安定版の "
"Rust に至るまでに時間がかかりそうです。\n"
"詳細は [blog](http://aturon.github.io/blog/2015/09/18/reuse/)\n"
"[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-"
"structs-part-4-extended-enums-and-thin-traits/)\n"
"や [RFC issue](https://github.com/rust-lang/rfcs/issues/349) \n"
"を参照してください。"

#: src/anti_patterns/deref.md:112
msgid ""
"The `Deref` trait is designed for the implementation of custom pointer "
"types.\n"
"The intention is that it will take a pointer-to-`T` to a `T`, not convert\n"
"between different types. It is a shame that this isn't (probably cannot be)\n"
"enforced by the trait definition."
msgstr ""
"`Deref` トレイトはカスタムポインタ型の実装のために設計されています。\n"
"これは、`T` へのポインタを `T` に変換するもので、異なる型間の変換を行うもので"
"はありません。\n"
"このことをトレイトの定義により強制されない（おそらくはできない）のは残念で"
"す。"

#: src/anti_patterns/deref.md:117
msgid ""
"Rust tries to strike a careful balance between explicit and implicit "
"mechanisms,\n"
"favouring explicit conversions between types. Automatic dereferencing in the "
"dot\n"
"operator is a case where the ergonomics strongly favour an implicit "
"mechanism,\n"
"but the intention is that this is limited to degrees of indirection, not\n"
"conversion between arbitrary types."
msgstr ""
"Rustは、明示的なメカニズムと暗黙的なメカニズムのバランスを慎重に取ろうとして"
"います。\n"
"そして型間の変換では明示的な変換を支持しています。\n"
"ドット演算子での自動参照外しは、人間工学的に暗黙的なメカニズムを強く支持する"
"ケースですが、\n"
"これは間接的な程度に限定されており、任意の型間の変換を行うものではありませ"
"ん。"

#: src/anti_patterns/deref.md:125
msgid ""
"- [Collections are smart pointers idiom](../idioms/deref.md).\n"
"- Delegation crates for less boilerplate like [delegate](https://crates.io/"
"crates/delegate)\n"
"  or [ambassador](https://crates.io/crates/ambassador)\n"
"- [Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."
msgstr ""
"- イディオムの [スマートポインタとしてのコレクション](../idioms/deref.md)。\n"
"- [delegate](https://crates.io/crates/delegate)や[ambassador](https://crates."
"io/crates/ambassador)ような、ボイラーテンプレートを減らすデリゲーション"
"crate。\n"
"- [`Deref` トレイトのドキュメント](https://doc.rust-lang.org/std/ops/trait."
"Deref.html)."

#: src/functional/index.md:1
msgid "# Functional Usage of Rust"
msgstr "# Rustので関数型使用法"

#: src/functional/index.md:3
msgid ""
"Rust is an imperative language, but it follows many\n"
"[functional programming](https://en.wikipedia.org/wiki/"
"Functional_programming) paradigms."
msgstr ""
"Rustは命令型言語ですが、数々の[関数型プログラミング](https://en.wikipedia."
"org/wiki/Functional_programming)\n"
"のパラダイムを模範としています。"

#: src/functional/index.md:6
msgid ""
"> In computer science, _functional programming_ is a programming paradigm "
"where\n"
"> programs are constructed by applying and composing functions.\n"
"> It is a declarative programming paradigm in which function definitions "
"are\n"
"> trees of expressions that each return a value, rather than a sequence of\n"
"> imperative statements which change the state of the program."
msgstr ""
"> In computer science, _functional programming_ is a programming paradigm "
"where\n"
"> programs are constructed by applying and composing functions.\n"
"> It is a declarative programming paradigm in which function definitions "
"are\n"
"> trees of expressions that each return a value, rather than a sequence of\n"
"> imperative statements which change the state of the program.\n"
"> (コンピュータサイエンスにおいて、関数型プログラミングとは、関数の適用と合成"
"によってプログラムを構成するプログラミングパラダイムです。\n"
"> これは宣言的なプログラミングパラダイムです。その関数の定義は、プログラムの"
"状態を変更する命令文の列ではなく、値を返す式のツリーです。)"

#: src/functional/paradigms.md:1
msgid "# Programming paradigms"
msgstr "# プログラミングパラダイム"

#: src/functional/paradigms.md:3
msgid ""
"One of the biggest hurdles to understanding functional programs when coming\n"
"from an imperative background is the shift in thinking. Imperative programs\n"
"describe **how** to do something, whereas declarative programs describe\n"
"**what** to do. Let's sum the numbers from 1 to 10 to show this."
msgstr ""
"関数型プログラミングを理解する上で、命令型プログラミング出身者にとって最大の"
"ハードルのひとつは、考え方の転換です。\n"
"命令型プログラムは **どうやるのか** を記述するのに対し、\n"
"宣言型プログラムは **何をするのか** を記述します。\n"
"これを示すために1から10までの数字を合計してみましょう。"

#: src/functional/paradigms.md:8
msgid "## Imperative"
msgstr "## 命令型"

#: src/functional/paradigms.md:10
msgid ""
"```rust\n"
"let mut sum = 0;\n"
"for i in 1..11 {\n"
"    sum += i;\n"
"}\n"
"println!(\"{}\", sum);\n"
"```"
msgstr ""
"```rust\n"
"let mut sum = 0;\n"
"for i in 1..11 {\n"
"    sum += i;\n"
"}\n"
"println!(\"{}\", sum);\n"
"```"

#: src/functional/paradigms.md:18
msgid ""
"With imperative programs, we have to play compiler to see what is "
"happening.\n"
"Here, we start with a `sum` of `0`.\n"
"Next, we iterate through the range from 1 to 10.\n"
"Each time through the loop, we add the corresponding value in the range.\n"
"Then we print it out."
msgstr ""
"命令型プログラムでは、何が起こっているのかを確認するためにコンパイラを演じな"
"ければなりません。\n"
"ここでは、まず `sum` が `0` から始めます。\n"
"次に、1から10までの範囲を繰り返します。\n"
"ループの各回で、ループ範囲内の対応する値を加算します。\n"
"そして結果を出力します。"

#: src/functional/paradigms.md:24
msgid ""
"| `i` | `sum` |\n"
"| :-: | :---: |\n"
"|  1  |   1   |\n"
"|  2  |   3   |\n"
"|  3  |   6   |\n"
"|  4  |  10   |\n"
"|  5  |  15   |\n"
"|  6  |  21   |\n"
"|  7  |  28   |\n"
"|  8  |  36   |\n"
"|  9  |  45   |\n"
"| 10  |  55   |"
msgstr ""
"| `i` | `sum` |\n"
"| :-: | :---: |\n"
"|  1  |   1   |\n"
"|  2  |   3   |\n"
"|  3  |   6   |\n"
"|  4  |  10   |\n"
"|  5  |  15   |\n"
"|  6  |  21   |\n"
"|  7  |  28   |\n"
"|  8  |  36   |\n"
"|  9  |  45   |\n"
"| 10  |  55   |"

#: src/functional/paradigms.md:37
msgid ""
"This is how most of us start out programming. We learn that a program is a "
"set\n"
"of steps."
msgstr ""
"私たちの多くは、こうしてプログラミングを始めました。\n"
"私たちはプログラムをステップの集まりだと学んできました。"

#: src/functional/paradigms.md:40
msgid "## Declarative"
msgstr "## 宣言的"

#: src/functional/paradigms.md:42
msgid ""
"```rust\n"
"println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
"```"
msgstr ""
"```rust\n"
"println!(\"{}\", (1..11).fold(0, |a, b| a + b));\n"
"```"

#: src/functional/paradigms.md:46
msgid ""
"Whoa! This is really different! What's going on here?\n"
"Remember that with declarative programs we are describing **what** to do,\n"
"rather than **how** to do it. `fold` is a function that [composes](https://"
"en.wikipedia.org/wiki/Function_composition)\n"
"functions. The name is a convention from Haskell."
msgstr ""
"おぉ!これは全く異なりますね!何が起こっているのでしょう?\n"
"宣言型プログラムでは、**どうやるのか** ではなく、**何をするのか** を記述して"
"いることに留意してください。\n"
"`fold`は関数を[合成](https://en.wikipedia.org/wiki/Function_composition)する"
"関数です。\n"
"この関数名はHaskellからの慣例です。"

#: src/functional/paradigms.md:51
msgid ""
"Here, we are composing functions of addition (this closure: `|a, b| a + b`)\n"
"with a range from 1 to 10. The `0` is the starting point, so `a` is `0` at\n"
"first. `b` is the first element of the range, `1`. `0 + 1 = 1` is the "
"result.\n"
"So now we `fold` again, with `a = 1`, `b = 2` and so `1 + 2 = 3` is the "
"next\n"
"result. This process continues until we get to the last element in the "
"range,\n"
"`10`."
msgstr ""
"ここでは、足し算の関数（クロージャ：`|a, b| a + b`）を1から10までの範囲に対し"
"合成しています。\n"
"この `0` は開始点です。よって `a` は最初は `0` です。\n"
"`b` は範囲の最初の要素である `1` です。 `0 + 1 = 1` が結果になります。\n"
"そして `a = 1` 、 `b=2` としてまた `fold` (折り返)し、 `1 + 2 = 3` が次の結果"
"になります。\n"
"このプロセスは範囲の最後の要素である `10` まで繰り返されます。"

#: src/functional/paradigms.md:58
msgid ""
"| `a` | `b` | result |\n"
"| :-: | :-: | :----: |\n"
"|  0  |  1  |   1    |\n"
"|  1  |  2  |   3    |\n"
"|  3  |  3  |   6    |\n"
"|  6  |  4  |   10   |\n"
"| 10  |  5  |   15   |\n"
"| 15  |  6  |   21   |\n"
"| 21  |  7  |   28   |\n"
"| 28  |  8  |   36   |\n"
"| 36  |  9  |   45   |\n"
"| 45  | 10  |   55   |"
msgstr ""
"| `a` | `b` | result |\n"
"| :-: | :-: | :----: |\n"
"|  0  |  1  |   1    |\n"
"|  1  |  2  |   3    |\n"
"|  3  |  3  |   6    |\n"
"|  6  |  4  |   10   |\n"
"| 10  |  5  |   15   |\n"
"| 15  |  6  |   21   |\n"
"| 21  |  7  |   28   |\n"
"| 28  |  8  |   36   |\n"
"| 36  |  9  |   45   |\n"
"| 45  | 10  |   55   |"

#: src/functional/generics-type-classes.md:1
msgid "# Generics as Type Classes"
msgstr "# 型クラスとしてのジェネリック"

#: src/functional/generics-type-classes.md:5
msgid ""
"Rust's type system is designed more like functional languages (like "
"Haskell)\n"
"rather than imperative languages (like Java and C++). As a result, Rust can "
"turn\n"
"many kinds of programming problems into \"static typing\" problems. This is "
"one\n"
"of the biggest wins of choosing a functional language, and is critical to "
"many\n"
"of Rust's compile time guarantees."
msgstr ""
"Rustの型システムは、(JavaやC++のような)命令型言語ではなく、(Haskellのような)"
"関数型言語のように設計されています。\n"
"その結果、Rustは多くのプログラミング上の問題を「静的型付け」の問題にすること"
"ができます。\n"
"これは関数型言語を選択する最大の利点の1つでありまたRustのコンパイル時保証の多"
"くにとって重要なものです。"

#: src/functional/generics-type-classes.md:11
msgid ""
"A key part of this idea is the way generic types work. In C++ and Java, for\n"
"example, generic types are a meta-programming construct for the compiler.\n"
"`vector<int>` and `vector<char>` in C++ are just two different copies of "
"the\n"
"same boilerplate code for a `vector` type (known as a `template`) with two\n"
"different types filled in."
msgstr ""
"この考え方の重要な部分は、ジェネリック型の動作方法です。\n"
"例えばC++やJavaでは、ジェネリック型はコンパイラのメタプログラミングの構成要素"
"です。\n"
"C++ における `vector<int>` や `vector<char>` は、 `vector` 型のボイラーテンプ"
"レート( `template` として知られるもの ) の\n"
"(それに異なる2つの型を埋め込んだ)異なる2つのコピーにすぎません。"

#: src/functional/generics-type-classes.md:17
msgid ""
"In Rust, a generic type parameter creates what is known in functional "
"languages\n"
"as a \"type class constraint\", and each different parameter filled in by an "
"end\n"
"user _actually changes the type_. In other words, `Vec<isize>` and "
"`Vec<char>`\n"
"_are two different types_, which are recognized as distinct by all parts of "
"the\n"
"type system."
msgstr ""
"Rustでは、ジェネリック型パラメータは関数型言語で「型クラス制約」として知られ"
"ているものを作成します。\n"
"and エンドユーザが埋め込むそれぞれの異なるパラメータは、 _実際に型を変えます"
"_ 。\n"
"言い換えると、 `Vec<isize> と `Vec<char>` は2つの _異なる型_ です。\n"
"これらは型システムのすべての箇所にて、別個の型として認識されます。"

#: src/functional/generics-type-classes.md:23
msgid ""
"This is called **monomorphization**, where different types are created from\n"
"**polymorphic** code. This special behavior requires `impl` blocks to "
"specify\n"
"generic parameters. Different values for the generic type cause different "
"types,\n"
"and different types can have different `impl` blocks."
msgstr ""
"これは **モノモーフィズム(単相化)** と呼ばれ、 **ポリモーフィック(多相の)** "
"コードから異なる型が作成されます。\n"
"この特別な振る舞いには、`impl`ブロックにジェネリックパラメータを指定する必要"
"があります。\n"
"ジェネリック型に異なる値を与えれば、異なる型が生成されます。\n"
"そして、異なる型は異なる `impl` ブロックを持つことができます。"

# 2023/8/26 いまいち意味が取れない。
# ---
# OO言語の継承はbehaviorを継承できる。
# でも、「to particular members of a type class」に「additional behavior」 を付加するだけでなく
# 「extra behavior」 も付加しちゃうよ！
# ---
# ・・・これはなんだろ？以下がぱっと思いついたが・・・
# (1)
# BaseClass を SubClass が継承する。
# 継承したかった振る舞いが、BaseClassのメソッドなどで表現されていたら、
# これが SubClassにとっての additinal behavior である。
# そして BaseClass の他の振る舞いは extra behavior である。
# (2)
# BaseClassがすでにある。機能拡張したものが必要だ。
# BaseClassをSubClass に継承させ、SubClassに機能追加を行う。
# これが additinal behavior の付加。
# でもその気になれば、当初その気がなかった別の機能をSubClassに追加できる。
# それが extra behavior 。
# ---
# ここで「additional behavior」の付加についての追加説明である、
# 「to particular members of a type class」を考える。
# ある型クラスの特定のメンバ、というのは BaseClass に対し SubClass を指すように聞こえる。BaseClasssという型の範囲に対し、その一部はSubClassであり、そこにadditinal behaviorを追加する。
# ---
# (1)でいいのかな？ほかのブロックと組み合わせてよんだとき意味がとおるかな・・・
#: src/functional/generics-type-classes.md:28
msgid ""
"In object-oriented languages, classes can inherit behavior from their "
"parents.\n"
"However, this allows the attachment of not only additional behavior to\n"
"particular members of a type class, but extra behavior as well."
msgstr ""
"オブジェクト指向言語では、クラスは親から振る舞いを継承することができます。\n"
"しかしながらこれは、\n"
"ある型クラスの特定のメンバに対して、\n"
"追加的な振る舞いだけを付加することを可能にするにとどまらず、\n"
"同様に余分な振る舞いを付加することも許容します。"

#: src/functional/generics-type-classes.md:32
msgid ""
"The nearest equivalent is the runtime polymorphism in Javascript and "
"Python,\n"
"where new members can be added to objects willy-nilly by any constructor.\n"
"However, unlike those languages, all of Rust's additional methods can be "
"type\n"
"checked when they are used, because their generics are statically defined. "
"That\n"
"makes them more usable while remaining safe."
msgstr ""
"最も近いのは、JavascriptやPythonのランタイムポリモーフィズムです。\n"
"これらの言語では、あらゆるコンストラクタにより、思ったときにオブジェクトに新"
"しいメンバを追加可能です。\n"
"しかしながら、これらの言語と異なりRustでは、追加されたメソッドは使用時にすべ"
"て型チェックされます。\n"
"なぜなら、それらジェネリックは静的に定義されているからです。\n"
"これはより使いやすく、かつ安全性を確保したものになっています。"

#: src/functional/generics-type-classes.md:40
msgid ""
"Suppose you are designing a storage server for a series of lab machines.\n"
"Because of the software involved, there are two different protocols you "
"need\n"
"to support: BOOTP (for PXE network boot), and NFS (for remote mount storage)."
msgstr ""
"あなたは、一連のラボマシン用のストレージサーバを設計しているとします。\n"
"関連するソフトウェアのため、次の2つの異なるプロトコルをサポートする必要があり"
"ます：BOOTP（PXEネットワークブート用）とNFS（リモートマウントストレージ用）で"
"す。"

#: src/functional/generics-type-classes.md:44
msgid ""
"Your goal is to have one program, written in Rust, which can handle both of\n"
"them. It will have protocol handlers and listen for both kinds of requests. "
"The\n"
"main application logic will then allow a lab administrator to configure "
"storage\n"
"and security controls for the actual files."
msgstr ""
"あなたの目標は、Rustで書かれた1つのプログラムで、その両方を処理できるようにす"
"ることです。\n"
"です。このプログラムは(2つの)プロトコルハンドラを持ち、両方のリクエストを待ち"
"受けます。\n"
"そしてメインのアプリケーションロジックは、ラボの管理者が、実際のファイルのた"
"めの、ストレージとセキュリティ制御を設定できるようにします。"

#: src/functional/generics-type-classes.md:49
msgid ""
"The requests from machines in the lab for files contain the same basic\n"
"information, no matter what protocol they came from: an authentication "
"method,\n"
"and a file name to retrieve. A straightforward implementation would look\n"
"something like this:"
msgstr ""
"ラボのマシンからの、ファイルに対してのリクエストは同じ基本情報を含みます。\n"
"どのプロトコルからであっても、認証方法と取得したいファイルの名前はありま"
"す。\n"
"ストレートな実装はこのようになるでしょう："

#: src/functional/generics-type-classes.md:54
msgid ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"enum AuthInfo {\n"
"    Nfs(crate::nfs::AuthInfo),\n"
"    Bootp(crate::bootp::AuthInfo),\n"
"}\n"
"\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:66
msgid ""
"This design might work well enough. But now suppose you needed to support\n"
"adding metadata that was _protocol specific_. For example, with NFS, you\n"
"wanted to determine what their mount point was in order to enforce "
"additional\n"
"security rules."
msgstr ""
"この設計は十分に機能するかもしれません。\n"
"しかし、次に _プロトコル固有_ のメタデータの追加をサポートする必要があるとし"
"ます。\n"
"例えば、NFSでは、あなたは追加のセキュリティ規則を実施するために、\n"
"マウントポイントを何にするか決定したいとします。"

#: src/functional/generics-type-classes.md:71
msgid ""
"The way the current struct is designed leaves the protocol decision until\n"
"runtime. That means any method that applies to one protocol and not the "
"other\n"
"requires the programmer to do a runtime check."
msgstr ""
"現在の構造体の設計では、プロトコルは実行時まで決定されません。\n"
"つまり、一方のプロトコルにて適用されもう一方ではそうしないすべてのメソッドで"
"は、プログラマが実行時チェックを行う必要があります。"

#: src/functional/generics-type-classes.md:75
msgid "Here is how getting an NFS mount point would look:"
msgstr "NFSマウントポイントの取得方法は以下のようになります："

#: src/functional/generics-type-classes.md:77
msgid ""
"```rust,ignore\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"    mount_point: Option<PathBuf>,\n"
"}\n"
"\n"
"impl FileDownloadRequest {\n"
"    // ... other methods ...\n"
"\n"
"    /// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
"    /// return None.\n"
"    pub fn mount_point(&self) -> Option<&Path> {\n"
"        self.mount_point.as_ref()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct FileDownloadRequest {\n"
"    file_name: PathBuf,\n"
"    authentication: AuthInfo,\n"
"    mount_point: Option<PathBuf>,\n"
"}\n"
"\n"
"impl FileDownloadRequest {\n"
"    // ... ほかのメソッド ...\n"
"\n"
"    /// NFSリクエストであれば、NFSマウントポイントを取得する。そうでなければ "
"None を返す。\n"
"    pub fn mount_point(&self) -> Option<&Path> {\n"
"        self.mount_point.as_ref()\n"
"    }\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:95
msgid ""
"Every caller of `mount_point()` must check for `None` and write code to "
"handle\n"
"it. This is true even if they know only NFS requests are ever used in a "
"given\n"
"code path!"
msgstr ""
"`mount_point()`のすべての呼び出し元は `None` をチェックして、それを処理する"
"コードを書かなければなりません。\n"
"これは、たとえそのコードパス上ではNFS リクエストしか使われないと知っていたと"
"してもです!"

#: src/functional/generics-type-classes.md:99
msgid ""
"It would be far more optimal to cause a compile-time error if the different\n"
"request types were confused. After all, the entire path of the user's code,\n"
"including what functions from the library they use, will know whether a "
"request\n"
"is an NFS request or a BOOTP request."
msgstr ""
"もし異なるリクエストタイプが混同されるのであれば、コンパイル時エラーを発生さ"
"せる方がはるかに最適でしょう。\n"
"結局のところ、ユーザのコードパス全体は、\n"
"このライブラリのどの関数を使うかも含め、\n"
"あるリクエストがNFSリクエストかBOOTPリクエストか、わかっていることでしょう。"

#: src/functional/generics-type-classes.md:104
msgid ""
"In Rust, this is actually possible! The solution is to _add a generic type_ "
"in\n"
"order to split the API."
msgstr ""
"Rustでは、実際にこれができます!\n"
"解決策は、APIを分割するために _ジェネリック型を追加_ することです。"

#: src/functional/generics-type-classes.md:107
msgid "Here is what that looks like:"
msgstr "これは以下のようになります："

#: src/functional/generics-type-classes.md:109
msgid ""
"```rust\n"
"use std::path::{Path, PathBuf};\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFS session management omitted\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // no authentication in bootp\n"
"}\n"
"\n"
"// private module, lest outside users invent their own protocol kinds!\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf};\n"
"    use super::{bootp, nfs};\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        type AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo;\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo,\n"
"        mount_point: PathBuf,\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&self) -> &Path {\n"
"            &self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs {\n"
"        type AuthInfo = nfs::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // no additional metadata\n"
"\n"
"    impl ProtoKind for Bootp {\n"
"        type AuthInfo = bootp::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // keep internal to prevent impls\n"
"pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> {\n"
"    file_name: PathBuf,\n"
"    protocol: P,\n"
"}\n"
"\n"
"// all common API parts go into a generic impl block\n"
"impl<P: ProtoKind> FileDownloadRequest<P> {\n"
"    fn file_path(&self) -> &Path {\n"
"        &self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&self) -> P::AuthInfo {\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// all protocol-specific impls go into their own block\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&self) -> &Path {\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // your code here\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use std::path::{Path, PathBuf};\n"
"\n"
"mod nfs {\n"
"    #[derive(Clone)]\n"
"    pub(crate) struct AuthInfo(String); // NFSセッション管理は省略\n"
"}\n"
"\n"
"mod bootp {\n"
"    pub(crate) struct AuthInfo(); // bootpでは認証なし\n"
"}\n"
"\n"
"// 外部のユーザが独自のプロトコルを作れないようにするため、 private なモ"
"ジュールです！\n"
"mod proto_trait {\n"
"    use std::path::{Path, PathBuf};\n"
"    use super::{bootp, nfs};\n"
"\n"
"    pub(crate) trait ProtoKind {\n"
"        type AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo;\n"
"    }\n"
"\n"
"    pub struct Nfs {\n"
"        auth: nfs::AuthInfo,\n"
"        mount_point: PathBuf,\n"
"    }\n"
"\n"
"    impl Nfs {\n"
"        pub(crate) fn mount_point(&self) -> &Path {\n"
"            &self.mount_point\n"
"        }\n"
"    }\n"
"\n"
"    impl ProtoKind for Nfs {\n"
"        type AuthInfo = nfs::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            self.auth.clone()\n"
"        }\n"
"    }\n"
"\n"
"    pub struct Bootp(); // 追加のメタデータなし\n"
"\n"
"    impl ProtoKind for Bootp {\n"
"        type AuthInfo = bootp::AuthInfo;\n"
"        fn auth_info(&self) -> Self::AuthInfo {\n"
"            bootp::AuthInfo()\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"use proto_trait::ProtoKind; // impl を防ぐため、非publicを維持\n"
"pub use proto_trait::{Nfs, Bootp}; // 呼び出し元に見えるよう再エクスポート\n"
"\n"
"struct FileDownloadRequest<P: ProtoKind> {\n"
"    file_name: PathBuf,\n"
"    protocol: P,\n"
"}\n"
"\n"
"// すべての共通のAPIは、ジェネリックの impl ブロックに入れます\n"
"impl<P: ProtoKind> FileDownloadRequest<P> {\n"
"    fn file_path(&self) -> &Path {\n"
"        &self.file_name\n"
"    }\n"
"\n"
"    fn auth_info(&self) -> P::AuthInfo {\n"
"        self.protocol.auth_info()\n"
"    }\n"
"}\n"
"\n"
"// すべてのプロトコル固有の実装は、それぞれのブロックに入れます\n"
"impl FileDownloadRequest<Nfs> {\n"
"    fn mount_point(&self) -> &Path {\n"
"        self.protocol.mount_point()\n"
"    }\n"
"}\n"
"\n"
"fn main() {\n"
"    // ここにあなたのコード\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:190
msgid ""
"With this approach, if the user were to make a mistake and use the wrong\n"
"type;"
msgstr "このアプローチでは、もしユーザが間違えて異なる型を使ってしまったとき："

#: src/functional/generics-type-classes.md:193
msgid ""
"```rust,ignore\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?;\n"
"    while let Some(request) = socket.next_request()? {\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\"),\n"
"            _ => {} // continue on...\n"
"        }\n"
"        // Rest of the code here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn main() {\n"
"    let mut socket = crate::bootp::listen()?;\n"
"    while let Some(request) = socket.next_request()? {\n"
"        match request.mount_point().as_ref()\n"
"            \"/secure\" => socket.send(\"Access denied\"),\n"
"            _ => {} // 続く...\n"
"        }\n"
"        // ここに残りのコード\n"
"    }\n"
"}\n"
"```"

#: src/functional/generics-type-classes.md:206
msgid ""
"They would get a syntax error. The type `FileDownloadRequest<Bootp>` does "
"not\n"
"implement `mount_point()`, only the type `FileDownloadRequest<Nfs>` does. "
"And\n"
"that is created by the NFS module, not the BOOTP module of course!"
msgstr ""
"構文エラーが発生します。\n"
"型 `FileDownloadRequest<Bootp>` は `mount_point()` を実装していません。\n"
"`FileDownloadRequest<Nfs>` 型だけが実装しています。\n"
"またもちろん、これはNFSモジュールによって作成されるもので、BOOTPモジュールに"
"よるって作成されるものではありません！"

#: src/functional/generics-type-classes.md:212
#, fuzzy
msgid ""
"First, it allows fields that are common to multiple states to be de-"
"duplicated.\n"
"By making the non-shared fields generic, they are implemented once."
msgstr ""
"第一に、複数のステートに共通するフィールドの重複をなくすことができます。\n"
"非共有フィールドを汎用的なものにすることで、それらは一度だけ実装されます。"

#: src/functional/generics-type-classes.md:215
#, fuzzy
msgid ""
"Second, it makes the `impl` blocks easier to read, because they are broken "
"down\n"
"by state. Methods common to all states are typed once in one block, and "
"methods\n"
"unique to one state are in a separate block."
msgstr ""
"第二に、`impl`ブロックが状態別に分割されているので読みやすくなります。\n"
"ブロックは状態ごとに分解されます。すべてのステートに共通するメソッドは1つのブ"
"ロックに1回型付けされ、1つのステートに固有のメソッドは別のブロックに型付けさ"
"れます。\n"
"は別のブロックになります。"

#: src/functional/generics-type-classes.md:219
#, fuzzy
msgid ""
"Both of these mean there are fewer lines of code, and they are better "
"organized."
msgstr "どちらもコード行数が少なく、整理されています。"

#: src/functional/generics-type-classes.md:223
#, fuzzy
msgid ""
"This currently increases the size of the binary, due to the way "
"monomorphization\n"
"is implemented in the compiler. Hopefully the implementation will be able "
"to\n"
"improve in the future."
msgstr ""
"これは現在、コンパイラの単型化の実装方法によってバイナリのサイズを大きくして"
"います。\n"
"が実装されているためです。将来的に実装が改善されることを願っています。\n"
"将来的に改善されることを願っています。"

#: src/functional/generics-type-classes.md:229
#, fuzzy
msgid ""
"- If a type seems to need a \"split API\" due to construction or partial\n"
"  initialization, consider the\n"
"  [Builder Pattern](../patterns/creational/builder.md) instead.\n"
"\n"
"- If the API between types does not change -- only the behavior does -- "
"then\n"
"  the [Strategy Pattern](../patterns/behavioural/strategy.md) is better "
"used\n"
"  instead."
msgstr ""
"- ある型が、構築や部分的な初期化によって「分割API」を必要とするようであれば\n"
"  を検討してください。\n"
"  [Builderパターン](../patterns/creational/builder.md)を検討してください。\n"
"\n"
"- 型間のAPIが変化しない場合 -- 振る舞いだけが変化する場合 -- は\n"
"  代わりに[Strategyパターン](../patterns/behavioural/strategy.md)を使うのがよ"
"いでしょう。\n"
"  を使うのがよいでしょう。"

#: src/functional/generics-type-classes.md:239
#, fuzzy
msgid "This pattern is used throughout the standard library:"
msgstr "このパターンは標準ライブラリ全体で使われています："

#: src/functional/generics-type-classes.md:241
#, fuzzy
msgid ""
"- `Vec<u8>` can be cast from a String, unlike every other type of `Vec<T>`."
"[^1]\n"
"- They can also be cast into a binary heap, but only if they contain a type\n"
"  that implements the `Ord` trait.[^2]\n"
"- The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
msgstr ""
"- Vec<u8>` は、他の全ての `Vec<T>` の型とは異なり、文字列からキャストすること"
"ができます[^1]。\n"
"- また、バイナリヒープにキャストすることもできます。\n"
"  を実装している場合に限ります[^2]。\n"
"- to_string` メソッドは `str` 型の `Cow` に対してのみ特化されています[^3]。"

#: src/functional/generics-type-classes.md:246
#, fuzzy
msgid "It is also used by several popular crates to allow API flexibility:"
msgstr ""
"また、APIの柔軟性を可能にするために、いくつかの人気のあるクレートで使用されて"
"います："

#: src/functional/generics-type-classes.md:248
#, fuzzy
msgid ""
"- The `embedded-hal` ecosystem used for embedded devices makes extensive use "
"of\n"
"  this pattern. For example, it allows statically verifying the "
"configuration of\n"
"  device registers used to control embedded pins. When a pin is put into a "
"mode,\n"
"  it returns a `Pin<MODE>` struct, whose generic determines the functions\n"
"  usable in that mode, which are not on the `Pin` itself. [^4]\n"
"\n"
"- The `hyper` HTTP client library uses this to expose rich APIs for "
"different\n"
"  pluggable requests. Clients with different connectors have different "
"methods\n"
"  on them as well as different trait implementations, while a core set of\n"
"  methods apply to any connector. [^5]\n"
"\n"
"- The \"type state\" pattern -- where an object gains and loses API based on "
"an\n"
"  internal state or invariant -- is implemented in Rust using the same "
"basic\n"
"  concept, and a slightly different technique. [^6]"
msgstr ""
"- 組み込み機器に使われる`embedded-hal`エコシステムは、このパターンを多用して"
"います。\n"
"  このパターンを多用しています。例えば、組み込みピンの制御に使われる\n"
"  例えば、組み込みピンの制御に使われるデバイスレジスタの構成を静的に検証する"
"ことができます。ピンがあるモードになると\n"
"  ピンがあるモードになると、`Pin<MODE>` 構造体を返します。\n"
"  そのジェネリックは `Pin` 自体にはない、そのモードで使用可能な関数を決定しま"
"す。[^4]\n"
"\n"
"- HTTPクライアントライブラリ `hyper` は、さまざまなプラグイン可能なリクエスト"
"のためのリッチなAPIを公開するためにこれを使っています。\n"
"  を公開しています。異なるコネクタを持つクライアントは異なるメソッド\n"
"  メソッドのコアセットはどのコネクタにも適用されます。\n"
"  メソッドはどのコネクタにも適用されます。[^5]\n"
"\n"
"- 型状態(type state) \"パターン -- 内部状態や不変量に基づいてオブジェクトが"
"APIを得たり失ったりするパターン -- は、Rustでも同じものを使って実装されていま"
"す。\n"
"  オブジェクトが内部状態や不変量に基づいてAPIを得たり失ったりする「型状態」パ"
"ターンは、Rustでも同じ基本概念と少し異なる手法を使って実装されています。\n"
"  型状態\" パターンが実装されています。[^6]"

#: src/functional/generics-type-classes.md:263
#, fuzzy
msgid ""
"See: [impl From\\<CString\\> for Vec\\<u8\\>](https://doc.rust-lang."
"org/1.59.0/src/std/ffi/c_str.rs.html#803-811)"
msgstr ""
"参照：[impl From<CString> for Vec<u8>](https://doc.rust-lang.org/1.59.0/src/"
"std/ffi/c_str.rs.html#803-811)"

#: src/functional/generics-type-classes.md:265
#, fuzzy
msgid ""
"See: [impl\\<T\\> From\\<Vec\\<T, Global\\>\\> for BinaryHeap\\<T\\>]"
"(https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs."
"html#1345-1354)"
msgstr ""
"参照：[impl <T> From<Vec<T, Global>> for BinaryHeap<T>](https://doc.rust-"
"lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354)"

#: src/functional/generics-type-classes.md:267
#, fuzzy
msgid ""
"See: [impl\\<'\\_\\> ToString for Cow\\<'\\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"
msgstr ""
"参照：[impl <' \\_xxxx ToString for Cow<' \\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"

#: src/functional/generics-type-classes.md:269
#, fuzzy
msgid ""
"Example:\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0."
"html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct."
"PA0.html)"
msgstr ""
"例\n"
"[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0."
"html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct."
"PA0.html)"

#: src/functional/generics-type-classes.md:272
#, fuzzy
msgid ""
"See:\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs."
"rs/hyper/0.14.5/hyper/client/struct.Client.html)"
msgstr ""
"ご覧ください：\n"
"[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://docs."
"rs/hyper/0.14.5/hyper/client/struct.Client.html)"

#: src/functional/generics-type-classes.md:275
#, fuzzy
msgid ""
"See:\n"
"[The Case for the Type State Pattern](https://web.archive.org/"
"web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-"
"typestate-pattern-the-typestate-pattern-itself/)\n"
"and\n"
"[Rusty Typestate Series (an extensive thesis)](https://web.archive.org/"
"web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-"
"series/rust-typestate-index)"
msgstr ""
"ご覧ください：\n"
"[型状態パターンのケース](https://web.archive.org/web/20210325065112/https://"
"www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-"
"pattern-itself/)\n"
"そして\n"
"[ラスティ・タイプステート・シリーズ（広範な論文）](https://web.archive.org/"
"web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-"
"series/rust-typestate-index)"

#: src/functional/lenses.md:1
#, fuzzy
msgid "# Lenses and Prisms"
msgstr "# レンズとプリズム"

#: src/functional/lenses.md:3
#, fuzzy
msgid ""
"This is a pure functional concept that is not frequently used in Rust.\n"
"Nevertheless, exploring the concept may be helpful to understand other\n"
"patterns in Rust APIs, such as [visitors](../patterns/behavioural/visitor."
"md).\n"
"They also have niche use cases."
msgstr ""
"これは純粋な関数型の概念で、Rustではあまり使われません。\n"
"とはいえ、この概念を調べることは、[visitor]（.\n"
"visitors](../patterns/behavioural/visitor.md)のようなRust APIにおける他のパ"
"ターンを理解するのに役立つかもしれません。\n"
"これらのパターンにもニッチな使用例があります。"

#: src/functional/lenses.md:8
#, fuzzy
msgid "## Lenses: Uniform Access Across Types"
msgstr "## レンズ種類を問わない均一なアクセス"

#: src/functional/lenses.md:10
#, fuzzy
msgid ""
"A lens is a concept from functional programming languages that allows\n"
"accessing parts of a data type in an abstract, unified way.[^1]\n"
"In basic concept, it is similar to the way Rust traits work with type "
"erasure,\n"
"but it has a bit more power and flexibility."
msgstr ""
"レンズは関数型プログラミング言語の概念で、データ型の一部に抽象的かつ統一的な"
"方法でアクセスすることができます[^1]。\n"
"抽象的で統一された方法でデータ型の一部にアクセスできるようにする関数型プログ"
"ラミング言語の概念です[^1]。\n"
"基本的な概念としては、Rust の trait が型消去を行うのと似ています、\n"
"しかし、もう少し強力で柔軟性があります。"

#: src/functional/lenses.md:15
#, fuzzy
msgid ""
"For example, suppose a bank contains several JSON formats for customer\n"
"data.\n"
"This is because they come from different databases or legacy systems.\n"
"One database contains the data needed to perform credit checks:"
msgstr ""
"たとえば、ある銀行が顧客データ用に複数のJSON形式を用意しているとします。\n"
"形式があるとします。\n"
"これは、異なるデータベースまたはレガシーシステムから来たものだからです。\n"
"あるデータベースには、信用調査を実行するために必要なデータが含まれています："

#: src/functional/lenses.md:20
#, fuzzy
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"dob\": \"2002-02-24\",\n"
"  [...]\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"name\"：\"Jane Doe\"、\n"
"  \"dob\"：\"2002-02-24\",\n"
"  [...]\n"
"  \"customer_id\"：1048576332,\n"
"}\n"
"```"

#: src/functional/lenses.md:28
#, fuzzy
msgid "Another one contains the account information:"
msgstr "もうひとつは口座情報："

#: src/functional/lenses.md:30
#, fuzzy
msgid ""
"```json\n"
"{ \"customer_id\": 1048576332,\n"
"  \"accounts\": [\n"
"      { \"account_id\": 2121,\n"
"        \"account_type: \"savings\",\n"
"        \"joint_customer_ids\": [],\n"
"        [...]\n"
"      },\n"
"      { \"account_id\": 2122,\n"
"        \"account_type: \"checking\",\n"
"        \"joint_customer_ids\": [1048576333],\n"
"        [...]\n"
"      },\n"
"  ]\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"customer_id\"：1048576332,\n"
"  \"accounts\"：[\n"
"      { \"account_id\"：2121,\n"
"        \"account_type：\"貯蓄\"、\n"
"        \"joint_customer_ids\"：[],\n"
"        [...]\n"
"      },\n"
"      { \"account_id\"：2122,\n"
"        \"account_type：「当座預金\n"
"        \"joint_customer_ids\"：[1048576333],\n"
"        [...]\n"
"      },\n"
"  ]\n"
"}\n"
"```"

#: src/functional/lenses.md:47
#, fuzzy
msgid ""
"Notice that both types have a customer ID number which corresponds to a "
"person.\n"
"How would a single function handle both records of different types?"
msgstr ""
"どちらのタイプも個人に対応する顧客ID番号を持っていることに注目してくださ"
"い。\n"
"異なるタイプのレコードを1つの関数で処理するにはどうすればよいでしょうか。"

#: src/functional/lenses.md:50
#, fuzzy
msgid ""
"In Rust, a `struct` could represent each of these types, and a trait would "
"have\n"
"a `get_customer_id` function they would implement:"
msgstr ""
"Rust では、 `struct` はこれらの型を表すことができます。\n"
"は `get_customer_id` 関数を実装します："

#: src/functional/lenses.md:53
#, fuzzy
msgid ""
"```rust\n"
"use std::collections::HashSet;\n"
"\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"pub trait CustomerId {\n"
"    fn get_customer_id(&self) -> u64;\n"
"}\n"
"\n"
"pub struct CreditRecord {\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"impl CustomerId for CreditRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"pub struct AccountRecord {\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"impl CustomerId for AccountRecord {\n"
"    fn get_customer_id(&self) -> u64 {\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"// static polymorphism: only one type, but each function call can choose it\n"
"fn unique_ids_set<R: CustomerId>(records: &[R]) -> HashSet<u64> {\n"
"    records.iter().map(|r| r.get_customer_id()).collect()\n"
"}\n"
"\n"
"// dynamic dispatch: iterates over any type with a customer ID, collecting "
"all\n"
"// values together\n"
"fn unique_ids_iter<I>(iterator: I) -> HashSet<u64>\n"
"    where I: Iterator<Item=Box<dyn CustomerId>>\n"
"{\n"
"    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
"}\n"
"```"
msgstr ""
"ラスト\n"
"std::collections::HashSetを使用します；\n"
"\n"
"pub struct Account {\n"
"    account_id: u32、\n"
"    account_type：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"pub trait CustomerId { 顧客ID\n"
"    fn get_customer_id(&amp;self) -&gt; u64；\n"
"}\n"
"\n"
"pub struct CreditRecord { { 顧客ID: u64\n"
"    customer_id: u64、\n"
"    name: String、\n"
"    dob：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"impl CustomerId for CreditRecord { クレジットレコードのための顧客ID\n"
"    fn get_customer_id(&amp;self) -&gt; u64 {.\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"pub struct AccountRecord {\n"
"    customer_id: u64、\n"
"    accounts：Vec<Account> 、\n"
"}\n"
"\n"
"impl CustomerId for AccountRecord { 以下のようになります。\n"
"    fn get_customer_id(&amp;self) -&gt; u64 {.\n"
"        self.customer_id\n"
"    }\n"
"}\n"
"\n"
"// 静的多相性: 型は1つだけですが、各関数呼び出しで選択できます。\n"
"fn unique_ids_set<R: CustomerId>(records: &amp;[R]) -&gt; HashSet<u64> {.\n"
"    records.iter().map(|r| r.get_customer_id()).collect()\n"
"}\n"
"\n"
"// 動的なディスパッチ: 顧客 ID を持つ任意の型を繰り返し処理し、 // すべての値"
"を収集します。\n"
"// すべての値を収集します。\n"
"fn unique_ids_iter<I>(iterator: I) -&gt; HashSet<u64>\n"
"    ここで I: Iterator&lt;Item=Box<dyn CustomerId>&gt; です。\n"
"{\n"
"    iterator.map(|r| r.as_ref().get_customer_id()).collect()\n"
"}\n"
"```"

#: src/functional/lenses.md:104
#, fuzzy
msgid ""
"Lenses, however, allow the code supporting customer ID to be moved from the\n"
"_type_ to the _accessor function_.\n"
"Rather than implementing a trait on each type, all matching structures can\n"
"simply be accessed the same way."
msgstr ""
"しかし、レンズは、顧客IDをサポートするコードを、_type_から_accessor function_"
"に移すことを可能にします。\n"
"型_から_アクセサ関数_に移すことができます。\n"
"それぞれの型に trait を実装するのではなく、すべてのマッチする構造体に同じ方法"
"でアクセスすることができます。\n"
"にアクセスできるようになります。"

#: src/functional/lenses.md:109
#, fuzzy
msgid ""
"While the Rust language itself does not support this (type erasure is the\n"
"preferred solution to this problem), the [lens-rs crate](https://github.com/"
"TOETOE55/lens-rs/blob/master/guide.md) allows code\n"
"that feels like this to be written with macros:"
msgstr ""
"Rust言語自体はこれをサポートしていませんが（型消去がこの問題の望ましい解決策"
"です。\n"
"型消去がこの問題に対する望ましい解決策です）、[lens-rs crate](https://github."
"com/TOETOE55/lens-rs/blob/master/guide.md)では、マクロを使ってこのようなコー"
"ドを書くことができます。\n"
"をマクロで書くことができます："

#: src/functional/lenses.md:113
#, fuzzy
msgid ""
"```rust,ignore\n"
"use std::collections::HashSet;\n"
"\n"
"use lens_rs::{optics, Lens, LensRef, Optics};\n"
"\n"
"#[derive(Clone, Debug, Lens /* derive to allow lenses to work */)]\n"
"pub struct CreditRecord {\n"
"    #[optic(ref)] // macro attribute to allow viewing this field\n"
"    customer_id: u64,\n"
"    name: String,\n"
"    dob: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug)]\n"
"pub struct Account {\n"
"    account_id: u32,\n"
"    account_type: String,\n"
"    // other fields omitted\n"
"}\n"
"\n"
"#[derive(Clone, Debug, Lens)]\n"
"pub struct AccountRecord {\n"
"    #[optic(ref)]\n"
"    customer_id: u64,\n"
"    accounts: Vec<Account>,\n"
"}\n"
"\n"
"fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -> HashSet<u64>\n"
"where\n"
"    T: LensRef<Optics![customer_id], u64>, // any type with this field\n"
"{\n"
"    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
"}\n"
"```"
msgstr ""
"``rust,ignore\n"
"std::collections::HashSetを使用します；\n"
"\n"
"use lens_rs::{optics, Lens, LensRef, Optics}；\n"
"\n"
"#[derive(Clone, Debug, Lens /* レンズを動作させるための派生 */)].\n"
"pub struct CreditRecord {\n"
"    #[optic(ref)] // このフィールドを表示するためのマクロ属性\n"
"    customer_id: u64、\n"
"    name: 文字列、\n"
"    dob：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"#[derive(Clone, Debug)] (派生(クローン), デバッグ)\n"
"pub struct Account {\n"
"    account_id: u32、\n"
"    account_type：文字列、\n"
"    // その他のフィールドは省略\n"
"}\n"
"\n"
"#[derive(Clone, Debug, Lens)] を参照してください。\n"
"pub struct AccountRecord {\n"
"    #[optic(ref)]\n"
"    customer_id: u64、\n"
"    accounts：Vec<Account> 、\n"
"}\n"
"\n"
"fn unique_ids_lens<T>(iter: impl Iterator<Item = T>) -&gt; HashSet<u64>\n"
"ここで\n"
"    T: LensRef<Optics![customer_id], u64>, // このフィールドを持つ任意の型\n"
"{\n"
"    iter.map(|r| *r.view_ref(optics!(customer_id))).collect()\n"
"}\n"
"```"

#: src/functional/lenses.md:149
#, fuzzy
msgid ""
"The version of `unique_ids_lens` shown here allows any type to be in the "
"iterator,\n"
"so long as it has an attribute called `customer_id` which can be accessed "
"by\n"
"the function.\n"
"This is how most functional programming languages operate on lenses."
msgstr ""
"ここで紹介する `unique_ids_lens` のバージョンでは、どのような型でもイテレータ"
"に含めることができます、\n"
"関数がアクセスできる `customer_id` という属性を持っている限り、どんな型でもイ"
"テレータに入れることができます。\n"
"という属性を持つ限り、どんな型でもイテレータに入れることができます。\n"
"これは、ほとんどの関数型プログラミング言語がレンズを操作する方法です。"

#: src/functional/lenses.md:154
#, fuzzy
msgid ""
"Rather than macros, they achieve this with a technique known as "
"\"currying\".\n"
"That is, they \"partially construct\" the function, leaving the type of the\n"
"final parameter (the value being operated on) unfilled until the function "
"is\n"
"called.\n"
"Thus it can be called with different types dynamically even from one place "
"in\n"
"the code.\n"
"That is what the `optics!` and `view_ref` in the example above simulates."
msgstr ""
"マクロではなく、\"currying \"と呼ばれるテクニックでこれを実現します。\n"
"つまり、関数を \"部分的に構築 \"し、最終パラメータ（操作される値）の型は関数"
"が実行されるまで未記入のままにしておくのです。\n"
"つまり、関数を \"部分的に構築 \"し、関数が呼び出されるまで、最終パラメータ"
"（操作される値）の型は未記入のままにしておくのです。\n"
"関数が呼び出されるまで、最終パラメータ（操作される値）の型は未記入のままにし"
"ておきます。\n"
"そのため、関数が呼び出されるまで、最終パラメータ（演算される値）の型は未記入"
"のままです。\n"
"を動的に呼び出すことができます。\n"
"上の例の `optics!` と `view_ref` はそれをシミュレートしています。"

#: src/functional/lenses.md:162
#, fuzzy
msgid ""
"The functional approach need not be restricted to accessing members.\n"
"More powerful lenses can be created which both _set_ and _get_ data in a\n"
"structure.\n"
"But the concept really becomes interesting when used as a building block "
"for\n"
"composition.\n"
"That is where the concept appears more clearly in Rust."
msgstr ""
"関数的アプローチは、メンバーへのアクセスに限定される必要はありません。\n"
"より強力なレンズを作成することができます。\n"
"構造体の\n"
"しかし、このコンセプトが本当に面白くなるのは\n"
"コンポジションです。\n"
"Rustでは、この概念がより明確に現れます。"

#: src/functional/lenses.md:169
#, fuzzy
msgid "## Prisms: A Higher-Order form of \"Optics\""
msgstr "#プリズム高次の \"光学\""

#: src/functional/lenses.md:171
#, fuzzy
msgid ""
"A simple function such as `unique_ids_lens` above operates on a single "
"lens.\n"
"A _prism_ is a function that operates on a _family_ of lenses.\n"
"It is one conceptual level higher, using lenses as a building block, and\n"
"continuing the metaphor, is part of a family of \"optics\".\n"
"It is the main one that is useful in understanding Rust APIs, so will be "
"the\n"
"focus here."
msgstr ""
"上記の`unique_ids_lens`のような単純な関数は1つのレンズを操作します。\n"
"prism_はレンズの_ファミリーを操作する関数です。\n"
"これは、レンズを構成要素として使用する、1つ上の概念的なレベルです。\n"
"この比喩を続けると、「光学」のファミリーの一部です。\n"
"RustのAPIを理解する上で有用な主要なものなので、ここで取り上げます。\n"
"に焦点を当てます。"

#: src/functional/lenses.md:178
#, fuzzy
msgid ""
"The same way that traits allow \"lens-like\" design with static polymorphism "
"and\n"
"dynamic dispatch, prism-like designs appear in Rust APIs which split "
"problems\n"
"into multiple associated types to be composed.\n"
"A good example of this is the traits in the parsing crate _Serde_."
msgstr ""
"静的なポリモーフィズムと動的なディスパッチで「レンズのような」設計ができるの"
"と同じように、Rust APIではプリズムのような設計が可能です。\n"
"プリズムのような設計がRust APIに登場します。\n"
"を複数の関連型に分割して構成します。\n"
"この良い例が、構文解析クレート _Serde_ の traits です。"

#: src/functional/lenses.md:183
#, fuzzy
msgid ""
"Trying to understand the way _Serde_ works by only reading the API is a\n"
"challenge, especially the first time.\n"
"Consider the `Deserializer` trait, implemented by some type in any library\n"
"which parses a new format:"
msgstr ""
"APIを読むだけで、_Serde_の仕組みを理解しようとするのは難しいことです。\n"
"特に最初のうちは大変です。\n"
"デシリアライザ`の特徴を考えてみましょう。\n"
"を考えてみましょう："

#: src/functional/lenses.md:188
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Deserializer<'de>: Sized {\n"
"    type Error: Error;\n"
"\n"
"    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de>;\n"
"\n"
"    // remainder ommitted\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait デシリアライザ<'de>: Sized {\n"
"    type Error: Error;\n"
"\n"
"    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::"
"Error>\n"
"    where\n"
"        V: Visitor<'de> ；\n"
"\n"
"    fn deserialize_bool<V>(self, visitor: V) -&gt; 結果<V::Value, Self::"
"Error>\n"
"    ここで\n"
"        V: Visitor&lt;'de&gt;；\n"
"\n"
"    // 余りは省略\n"
"}\n"
"```"

#: src/functional/lenses.md:204
#, fuzzy
msgid ""
"For a trait that is just supposed to parse data from a format and return a\n"
"value, this looks odd."
msgstr ""
"フォーマットからデータをパースして\n"
"これは奇妙に見えます。"

#: src/functional/lenses.md:207
#, fuzzy
msgid "Why are all the return types type erased?"
msgstr "なぜリターンタイプはすべて消去されるのですか？"

#: src/functional/lenses.md:209
#, fuzzy
msgid ""
"To understand that, we need to keep the lens concept in mind and look at\n"
"the definition of the `Visitor` type that is passed in generically:"
msgstr ""
"これを理解するためには、レンズの概念を念頭に置き、一般的に渡される `Visitor` "
"型の定義を見てみる必要があります。\n"
"を見る必要があります："

#: src/functional/lenses.md:212
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Visitor<'de>: Sized {\n"
"    type Value;\n"
"\n"
"    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n"
"    where\n"
"        E: Error;\n"
"\n"
"    // remainder omitted\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait Visitor&lt;'de&gt;: サイズ {.\n"
"    型の値；\n"
"\n"
"    fn visit_bool&lt;E&gt;(self, v: bool) -&gt; 結果&lt;Self::Value, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    fn visit_u64&lt;E&gt;(self, v: u64) -&gt; 結果&lt;Self::値, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    fn visit_str&lt;E&gt;(self, v: &amp;str) -&gt; 結果&lt;Self::値, E&gt;.\n"
"    ここで\n"
"        E: エラー；\n"
"\n"
"    // 余りは省略\n"
"}\n"
"```"

#: src/functional/lenses.md:232
#, fuzzy
msgid ""
"The job of the `Visitor` type is to construct values in the _Serde_ data "
"model,\n"
"which are represented by its associated `Value` type."
msgstr ""
"Visitor`型の仕事は_Serde_データモデルで値を構築することです、\n"
"その値は `Value` 型によって表現されます。"

#: src/functional/lenses.md:235
#, fuzzy
msgid ""
"These values represent parts of the Rust value being deserialized.\n"
"If this fails, it returns an `Error` type - an error type determined by the\n"
"`Deserializer` when its methods were called."
msgstr ""
"これらの値は、デシリアライズされる Rust 値の一部を表します。\n"
"失敗した場合は `Error` 型を返します。\n"
"メソッドが呼び出されたときに `Deserializer` によって決定されたエラータイプで"
"す。"

#: src/functional/lenses.md:239
#, fuzzy
msgid ""
"This highlights that `Deserializer` is similar to `CustomerId` from "
"earlier,\n"
"allowing any format parser which implements it to create `Value`s based on "
"what\n"
"it parsed.\n"
"The `Value` trait is acting like a lens in functional programming languages."
msgstr ""
"これは `Deserializer` が先ほどの `CustomerId` と似ていることを強調していま"
"す、\n"
"を実装したフォーマットパーサであれば、そのパーサがパースした内容に基づいて "
"`Value` を作成することができます。\n"
"を生成することができます。\n"
"Value` 特性は関数型プログラミング言語におけるレンズのようなものです。"

#: src/functional/lenses.md:244
#, fuzzy
msgid ""
"But unlike the `CustomerId` trait, the return types of `Visitor` methods "
"are\n"
"_generic_, and the concrete `Value` type is _determined by the Visitor "
"itself_."
msgstr ""
"しかし、 `CustomerId` 特性と異なり、 `Visitor` メソッドの戻り値の型は "
"_generic_ です。\n"
"一般的なもので、具体的な `Value` の型は Visitor 自身によって決まります。"

#: src/functional/lenses.md:247
#, fuzzy
msgid ""
"Instead of acting as one lens, it effectively acts as a family of\n"
"lenses, one for each concrete type of `Visitor`."
msgstr ""
"つのレンズとして機能するのではなく、事実上、レンズのファミリーとして機能しま"
"す。\n"
"レンズのファミリーとして機能します。"

#: src/functional/lenses.md:250
#, fuzzy
msgid ""
"The `Deserializer` API is based on having a generic set of \"lenses\" work "
"across\n"
"a set of other generic types for \"observation\".\n"
"It is a _prism_."
msgstr ""
"デシリアライザーのAPIは、\"レンズ \"の一般的なセットが、\"観察 \"のために他の"
"一般的なタイプ\n"
"観察 \"のために他の一般的な型のセットをまたいで動作させることに基づいていま"
"す。\n"
"これは_prism_です。"

#: src/functional/lenses.md:254
#, fuzzy
msgid "For example, consider the identity record from earlier but simplified:"
msgstr "例えば、先ほどのID記録を単純化して考えてみましょう："

#: src/functional/lenses.md:256
#, fuzzy
msgid ""
"```json\n"
"{ \"name\": \"Jane Doe\",\n"
"  \"customer_id\": 1048576332,\n"
"}\n"
"```"
msgstr ""
"``json\n"
"{ \"name\"：\"Jane Doe\"、\n"
"  \"customer_id\"：1048576332,\n"
"}\n"
"```"

#: src/functional/lenses.md:262
#, fuzzy
msgid ""
"How would the _Serde_ library deserialize this JSON into `struct "
"CreditRecord`?"
msgstr ""
"Serde_ライブラリはこのJSONをどのように`struct CreditRecord`にデシリアライズし"
"ますか？"

#: src/functional/lenses.md:264
#, fuzzy
msgid ""
"1. The user would call a library function to deserialize the data. This "
"would\n"
"   create a `Deserializer` based on the JSON format.\n"
"1. Based on the fields in the struct, a `Visitor` would be created (more on\n"
"   that in a moment) which knows how to create each type in a generic data\n"
"   model that was needed to represent it: `u64` and `String`.\n"
"1. The deserializer would make calls to the `Visitor` as it parsed items.\n"
"1. The `Visitor` would indicate if the items found were expected, and if "
"not,\n"
"   raise an error to indicate deserialization has failed."
msgstr ""
"1.ユーザーはライブラリ関数を呼び出してデータをデシリアライズします。これは\n"
"   JSON フォーマットに基づいた `Deserializer` を作成します。\n"
"1.構造体のフィールドに基づいて、一般的なデータ型の各データ型を作成する方法を"
"知っている `Visitor` が作成されます。\n"
"   を作成することになります。\n"
"   型（`u64` と `String`）を作成する方法を知っています。\n"
"1.デシリアライザはアイテムをパースするときに `Visitor` を呼び出します。\n"
"1.Visitor` は見つかったアイテムが期待されたものであるかどうかを示し、期待され"
"たものでない場合はエラーを発生させます、\n"
"   デシリアライズに失敗したことを示すエラーを発生させます。"

#: src/functional/lenses.md:273
#, fuzzy
msgid "For our very simple structure above, the expected pattern would be:"
msgstr "上記の非常に単純な構造の場合、予想されるパターンは次のようになります："

#: src/functional/lenses.md:275
#, fuzzy
msgid ""
"1. Visit a map (_Serde_'s equvialent to `HashMap` or JSON's dictionary).\n"
"1. Visit a string key called \"name\".\n"
"1. Visit a string value, which will go into the `name` field.\n"
"1. Visit a string key called \"customer_id\".\n"
"1. Visit a string value, which will go into the `customer_id` field.\n"
"1. Visit the end of the map."
msgstr ""
"1.マップ（_Serde_ の `HashMap` や JSON の辞書に相当するもの）にアクセスしま"
"す。\n"
"1.name \"という文字列キーにアクセスします。\n"
"1.name`フィールドに入る文字列の値にアクセスします。\n"
"1.customer_id \"という文字列キーにアクセスします。\n"
"1.customer_id`フィールドに入る文字列の値にアクセスします。\n"
"1.マップの最後にアクセスします。"

#: src/functional/lenses.md:282
#, fuzzy
msgid "But what determines which \"observation\" pattern is expected?"
msgstr ""
"しかし、どの \"観測 \"パターンが期待されるかは、何によって決まるのでしょう"
"か？"

#: src/functional/lenses.md:284
#, fuzzy
msgid ""
"A functional programming language would be able to use currying to create\n"
"reflection of each type based on the type itself.\n"
"Rust does not support that, so every single type would need to have its own\n"
"code written based on its fields and their properties."
msgstr ""
"関数型プログラミング言語であれば、カリー（currying）を使って、型自体に基づい"
"た各型の\n"
"を作成することができます。\n"
"Rustはそれをサポートしていないため、すべての型が、そのフィールドとプロパティ"
"に基づいて独自の\n"
"コードを書く必要があります。"

#: src/functional/lenses.md:289
#, fuzzy
msgid "_Serde_ solves this usability challenge with a derive macro:"
msgstr "Serde_はderiveマクロでこの使い勝手の問題を解決します："

#: src/functional/lenses.md:291
#, fuzzy
msgid ""
"```rust,ignore\n"
"use serde::Deserialize;\n"
"\n"
"#[derive(Deserialize)]\n"
"struct IdRecord {\n"
"    name: String,\n"
"    customer_id: String,\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"serde::Deserialize を使用します；\n"
"\n"
"#[derive(Deserialize)] を参照してください。\n"
"struct IdRecord {\n"
"    name: 文字列、\n"
"    customer_id：文字列、\n"
"}\n"
"```"

#: src/functional/lenses.md:301
#, fuzzy
msgid ""
"That macro simply generates an impl block causing the struct to implement a\n"
"trait called `Deserialize`."
msgstr ""
"このマクロは、単に struct に `Deserialize` という trait を実装させる impl ブ"
"ロックを生成します。\n"
"という trait を実装させます。"

#: src/functional/lenses.md:304
#, fuzzy
msgid "It is defined this way:"
msgstr "このように定義されています："

#: src/functional/lenses.md:306
#, fuzzy
msgid ""
"```rust,ignore\n"
"pub trait Deserialize<'de>: Sized {\n"
"    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
"    where\n"
"        D: Deserializer<'de>;\n"
"}\n"
"```"
msgstr ""
"錆、無視\n"
"pub trait Deserialize<'de>: Sized {\n"
"    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n"
"    where\n"
"        D: Deserializer<'de> ；\n"
"}\n"
"```"

#: src/functional/lenses.md:314
#, fuzzy
msgid ""
"This is the function that determines how to create the struct itself.\n"
"Code is generated based on the struct's fields.\n"
"When the parsing library is called - in our example, a JSON parsing library "
"-\n"
"it creates a `Deserializer` and calls `Type::deserialize` with it as a\n"
"parameter."
msgstr ""
"これは、構造体自体の作成方法を決定する関数です。\n"
"コードは構造体のフィールドに基づいて生成されます。\n"
"構文解析ライブラリが呼び出されると（この例では JSON 構文解析ライブラリ）、"
"`Deserializer` が作成され、それを使用して `Type::deserialize` が呼び出されま"
"す。\n"
"が呼び出されると、`Deserializer` が作成され、それをパラメータとして `Type::"
"deserialize` が呼び出されます。\n"
"を呼び出します。"

#: src/functional/lenses.md:320
#, fuzzy
msgid ""
"The `deserialize` code will then create a `Visitor` which will have its "
"calls\n"
"\"refracted\" by the `Deserializer`.\n"
"If everything goes well, eventually that `Visitor` will construct a value\n"
"corresponding to the type being parsed and return it."
msgstr ""
"そして `deserialize` コードは `Visitor` を作成し、その呼び出しは "
"`Deserializer` によって \"refract\" されます。\n"
"その呼び出しは `Deserializer` によって \"refracted\" されます。\n"
"すべてがうまくいけば、最終的に `Visitor` はパースされた型に対応する値を構築"
"し、それを返します。\n"
"を作成し、それを返します。"

#: src/functional/lenses.md:325
#, fuzzy
msgid ""
"For a complete example, see the [_Serde_ documentation](https://serde.rs/"
"deserialize-struct.html)."
msgstr ""
"完全な例については、[_Serde_ documentation](https://serde.rs/deserialize-"
"struct.html) を参照してください。"

#: src/functional/lenses.md:327
#, fuzzy
msgid "To wrap up, this is the power of _Serde_:"
msgstr "最後に、これがセルデの力です："

#: src/functional/lenses.md:329
#, fuzzy
msgid ""
"1. The structure being parsed is represented by an `impl` block for "
"`Deserialize`\n"
"1. The input data format (e.g. JSON) is represented by a `Deserializer` "
"called\n"
"   by `Deserialize`\n"
"1. The `Deserializer` acts like a prism which \"refracts\" lens-like "
"`Visitor`\n"
"   calls which actually build the data value"
msgstr ""
"1.パースされる構造は `Deserialize` 用の `impl` ブロックで表現されます。\n"
"1.入力データフォーマット（例えば JSON）は `Deserializer` の\n"
"   によって呼び出されます。\n"
"1.この `Deserializer` はプリズムのように動作し、レンズのような `Visitor` 呼び"
"出しを \"屈折\" させます。\n"
"   を呼び出します。"

#: src/functional/lenses.md:335
#, fuzzy
msgid ""
"The result is that types to be deserialized only implement the \"top layer\" "
"of\n"
"the API, and file formats only need to implement the \"bottom layer\".\n"
"Each piece can then \"just work\" with the rest of the ecosystem, since "
"generic\n"
"types will bridge them."
msgstr ""
"その結果、デシリアライズされる型はAPIの \"トップ・レイヤー \"のみを実装し、"
"ファイル・フォーマットは \"ボトム・レイヤー \"のみを実装すればよいことになり"
"ます。\n"
"デシリアライズされる型はAPIの \"トップレイヤー \"のみを実装し、ファイルフォー"
"マットは \"ボトムレイヤー \"のみを実装すればよいということです。\n"
"その結果、デシリアライズされる型はAPIの \"最上層 \"のみを実装し、ファイル"
"フォーマットは \"最下層 \"のみを実装すればよくなります。\n"
"型がそれらの橋渡しをしてくれるからです。"

#: src/functional/lenses.md:340
#, fuzzy
msgid ""
"To emphasize, the only reason this model works on any format and any type "
"is\n"
"because the `Deserializer` trait's output type **is specified by the\n"
"implementor of `Visitor` it is passed**, rather than being tied to one "
"specific\n"
"type.\n"
"This was not true in the account example earlier."
msgstr ""
"強調しておきますが、このモデルがどのようなフォーマットでもどのような型でも動"
"作する唯一の理由は\n"
"なぜなら `Deserializer` 特性の出力型は **渡される `Visitor` の実装者によって"
"指定されるからです。\n"
"の実装者によって指定されるからです。\n"
"の実装者によって指定されるからです。\n"
"これは先ほどの口座の例では当てはまりませんでした。"

#: src/functional/lenses.md:346
#, fuzzy
msgid ""
"Rust's generic-inspired type system can bring it close to these concepts "
"and\n"
"use their power, as shown in this API design.\n"
"But it may also need procedural macros to create bridges for its generics."
msgstr ""
"Rustのジェネリックにインスパイアされた型システムは、このAPI設計に示されている"
"ように、これらの概念に近づけ、その力を利用することができます。\n"
"このAPI設計で示されているように、その力を利用することができます。\n"
"しかし、ジェネリックのためのブリッジを作成するための手続き型マクロも必要かも"
"しれません。"

#: src/functional/lenses.md:350
#, fuzzy
msgid "## See Also"
msgstr "## See Also"

#: src/functional/lenses.md:352
#, fuzzy
msgid ""
"- [lens-rs crate](https://crates.io/crates/lens-rs) for a pre-built lenses\n"
"  implementation, with a cleaner interface than these examples\n"
"- [serde](https://serde.rs) itself, which makes these concepts intuitive "
"for\n"
"  end users (i.e. defining the structs) without needing to undestand the\n"
"  details\n"
"- [luminance](https://github.com/phaazon/luminance-rs) is a crate for "
"drawing\n"
"  computer graphics that uses lens API design, including proceducal macros "
"to\n"
"  create full prisms for buffers of different pixel types that remain "
"generic\n"
"- [An Article about Lenses in Scala](https://web.archive.org/"
"web/20221128185849/https://medium.com/zyseme-technology/functional-"
"references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
"  that is very readable even without Scala expertise.\n"
"- [Paper: Profunctor Optics: Modular Data\n"
"  Accessors](https://web.archive.org/web/20220701102832/https://arxiv.org/"
"ftp/arxiv/papers/1703/1703.10857.pdf)"
msgstr ""
"- [lens-rs crate](https://crates.io/crates/lens-rs)は、これらの例よりもすっき"
"りとしたインターフェイスを持つ、あらかじめ組み込まれたレンズの実装です。\n"
"  を実装しています。\n"
"- [serde](https://serde.rs)そのものです。\n"
"  を理解することなく、エンドユーザー (構造体の定義など) がこれらの概念を直感"
"的に理解できるようにします。\n"
"  詳細\n"
"- [luminance](https://github.com/phaazon/luminance-rs)は、レンズAPIの設計を使"
"用した、コンピュータグラフィックスを描画するためのクレートです。\n"
"  レンズ API デザインを使用するコンピュータグラフィックス用のクレートです。\n"
"  汎用のまま、異なるピクセルタイプのバッファのための完全なプリズムを作成しま"
"す。\n"
"- [Scala におけるレンズについての記事](https://web.archive.org/"
"web/20221128185849/https://medium.com/zyseme-technology/functional-"
"references-lens-and-other-optics-in-scala-e5f7e2fdafe)\n"
"  Scalaの専門知識がなくても非常に読みやすいものです。\n"
"- 論文プロファンクタ光学系．モジュラーデータ\n"
"  アクセサ](https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/"
"arxiv/papers/1703/1703.10857.pdf)"

#: src/functional/lenses.md:365
#, fuzzy
msgid ""
"[School of Haskell: A Little Lens Starter Tutorial](https://web.archive.org/"
"web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-"
"beyond/pick-of-the-week/a-little-lens-starter-tutorial)"
msgstr ""
"[Haskellの学校：小さなレンズ・スターター・チュートリアル](https://web."
"archive.org/web/20221128190041/https://www.schoolofhaskell.com/school/to-"
"infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial)"

#: src/additional_resources/index.md:1
#, fuzzy
msgid "# Additional resources"
msgstr "# その他のリソース"

#: src/additional_resources/index.md:3
#, fuzzy
msgid "A collection of complementary helpful content"
msgstr "補完的なお役立ちコンテンツ集"

#: src/additional_resources/index.md:5
#, fuzzy
msgid "## Talks"
msgstr "## Talks"

#: src/additional_resources/index.md:7
#, fuzzy
msgid ""
"- [Design Patterns in Rust](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by\n"
"  Nicholas Cameron at the PDRust (2016)\n"
"- [Writing Idiomatic Libraries in Rust](https://www.youtube.com/watch?"
"v=0zOg8_B71gE)\n"
"  by Pascal Hertleif at RustFest (2017)\n"
"- [Rust Programming Techniques](https://www.youtube.com/watch?v=vqavdUGKeb4) "
"by\n"
"  Nicholas Cameron at LinuxConfAu (2018)"
msgstr ""
"- [Rustのデザインパターン](https://www.youtube.com/watch?v=Pm_oO0N5B9k) by\n"
"  ニコラス・キャメロン＠PDRust (2016)\n"
"- [Rustでイディオマティックなライブラリを書く](https://www.youtube.com/watch?"
"v=0zOg8_B71gE)\n"
"  by Pascal Hertleif at RustFest (2017)\n"
"- [Rustプログラミングテクニック](https://www.youtube.com/watch?"
"v=vqavdUGKeb4)\n"
"  ニコラス・キャメロン at LinuxConfAu (2018)"

#: src/additional_resources/index.md:14
#, fuzzy
msgid "## Books (Online)"
msgstr "## 書籍（オンライン）"

#: src/additional_resources/index.md:16
#, fuzzy
msgid "- [The Rust API Guidelines](https://rust-lang.github.io/api-guidelines)"
msgstr "- [Rust APIガイドライン](https://rust-lang.github.io/api-guidelines)"

#: src/additional_resources/design-principles.md:1
#, fuzzy
msgid "# Design principles"
msgstr "# デザインの原則"

#: src/additional_resources/design-principles.md:3
#, fuzzy
msgid "## A brief overview over common design principles"
msgstr "## 一般的な設計原則の概要"

#: src/additional_resources/design-principles.md:7
#, fuzzy
msgid "## [SOLID](https://en.wikipedia.org/wiki/SOLID)"
msgstr "## ♪ [SOLID](https://en.wikipedia.org/wiki/SOLID)"

#: src/additional_resources/design-principles.md:9
#, fuzzy
msgid ""
"- [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/"
"Single-responsibility_principle):\n"
"  A class should only have a single responsibility, that is, only changes "
"to\n"
"  one part of the software's specification should be able to affect the\n"
"  specification of the class.\n"
"- [Open/Closed Principle (OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle):\n"
"  \"Software entities ... should be open for extension, but closed for\n"
"  modification.\"\n"
"- [Liskov Substitution Principle (LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle):\n"
"  \"Objects in a program should be replaceable with instances of their "
"subtypes\n"
"  without altering the correctness of that program.\"\n"
"- [Interface Segregation Principle (ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle):\n"
"  \"Many client-specific interfaces are better than one general-purpose\n"
"  interface.\"\n"
"- [Dependency Inversion Principle (DIP)](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle):\n"
"  One should \"depend upon abstractions, [not] concretions.\""
msgstr ""
"- [単一責任原則(SRP)](https://en.wikipedia.org/wiki/Single-"
"responsibility_principle)：\n"
"  クラスは単一の責任だけを持つべきです。\n"
"  ソフトウェアの仕様の一部分の変更だけが、クラスの仕様に影響を与えることがで"
"きます。\n"
"  クラスの仕様に影響を与えることができるべきです。\n"
"- [オープン/クローズド原則(OCP)](https://en.wikipedia.org/wiki/"
"Open%E2%80%93closed_principle)：\n"
"  「ソフトウェア・エンティティは......拡張に対してはオープンであるべきです"
"が、変更に対してはクローズドであるべきです。\n"
"  \"。\n"
"- [リスコフ置換原則(LSP)](https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle)：\n"
"  「プログラム中のオブジェクトは、そのサブタイプのインスタンスと置き換え可能"
"であるべきです。\n"
"  そのプログラムの正しさを変えることなく。\"\n"
"- [インタフェース分離の原則(ISP)](https://en.wikipedia.org/wiki/"
"Interface_segregation_principle)：\n"
"  \"多くのクライアント固有のインタフェースは、1つの汎用インタフェースより\n"
"  インタフェースよりも優れている\" [Dependency Inversion Principle (ISP)]()\n"
"- [依存関係逆転の原則(DIP)](https://en.wikipedia.org/wiki/"
"Dependency_inversion_principle)：\n"
"  人は \"抽象的なものに依存すべきであり、具体的なものに依存すべきではない\"。"

#: src/additional_resources/design-principles.md:25
#, fuzzy
msgid ""
"## [DRY (Don’t Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"
msgstr ""
"## [DRY (Don't Repeat Yourself)](https://en.wikipedia.org/wiki/"
"Don%27t_repeat_yourself)"

#: src/additional_resources/design-principles.md:27
#, fuzzy
msgid ""
"\"Every piece of knowledge must have a single, unambiguous, authoritative\n"
"representation within a system\""
msgstr ""
"「すべての知識は、システム内で単一の、曖昧さのない、権威ある表現を持たなけれ"
"ばなりません。\n"
"システム内で表現されなければならない\""

#: src/additional_resources/design-principles.md:30
#, fuzzy
msgid "## [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)"
msgstr "## [KISSの原則](https://en.wikipedia.org/wiki/KISS_principle)"

#: src/additional_resources/design-principles.md:32
#, fuzzy
msgid ""
"most systems work best if they are kept simple rather than made "
"complicated;\n"
"therefore, simplicity should be a key goal in design, and unnecessary\n"
"complexity should be avoided"
msgstr ""
"ほとんどのシステムは、複雑にするよりもシンプルにした方がうまく機能します；\n"
"したがって、シンプルであることが設計の重要な目標であり、不必要な複雑さは避け"
"るべきです。\n"
"を避けるべきです。"

#: src/additional_resources/design-principles.md:36
#, fuzzy
msgid "## [Law of Demeter (LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"
msgstr "## [デメテルの法則(LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter)"

#: src/additional_resources/design-principles.md:38
#, fuzzy
msgid ""
"a given object should assume as little as possible about the structure or\n"
"properties of anything else (including its subcomponents), in accordance "
"with\n"
"the principle of \"information hiding\""
msgstr ""
"あるオブジェクトは、他のもの（そのサブコンポーネントを含む）の構造や特性につ"
"いて、できる限り推測しないようにすべきです。\n"
"情報隠蔽」の原則に従い\n"
"\"情報隠蔽 \"の原則に従って"

#: src/additional_resources/design-principles.md:42
#, fuzzy
msgid ""
"## [Design by contract (DbC)](https://en.wikipedia.org/wiki/"
"Design_by_contract)"
msgstr ""
"## [契約による設計（DbC）](https://en.wikipedia.org/wiki/Design_by_contract)"

#: src/additional_resources/design-principles.md:44
#, fuzzy
msgid ""
"software designers should define formal, precise and verifiable interface\n"
"specifications for software components, which extend the ordinary definition "
"of\n"
"abstract data types with preconditions, postconditions and invariants"
msgstr ""
"ソフトウエア設計者は、ソフトウエア・コンポーネントのインターフェイス仕様につ"
"いて、通常の定義を拡張した、形式的で正確かつ検証可能なものを定義する必要があ"
"ります。\n"
"ソフトウェア・コンポーネントのインターフェイス仕様を定義すべきです。\n"
"抽象データ型の定義を拡張し、前提条件、後件条件、不変条件"

#: src/additional_resources/design-principles.md:48
#, fuzzy
msgid ""
"## [Encapsulation](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"
msgstr ""
"## [Encapsulation](https://en.wikipedia.org/wiki/"
"Encapsulation_(computer_programming))"

#: src/additional_resources/design-principles.md:50
#, fuzzy
msgid ""
"bundling of data with the methods that operate on that data, or the "
"restricting\n"
"of direct access to some of an object's components. Encapsulation is used "
"to\n"
"hide the values or state of a structured data object inside a class, "
"preventing\n"
"unauthorized parties' direct access to them."
msgstr ""
"データとそのデータを操作するメソッドのバンドルや、オブジェクトのコンポーネン"
"トの一部への直接アクセスの制限。\n"
"オブジェクトのコンポーネントの一部への直接アクセスを制限します。カプセル化"
"は\n"
"構造化されたデータオブジェクトの値や状態をクラス内に隠すことで、 許可されてい"
"ない人がオブジェクトに直接アクセスできないようにします。\n"
"構造化されたデータオブジェクトの値や状態をクラス内に隠し、 許可されていない人"
"が直接アクセスできないようにします。"

#: src/additional_resources/design-principles.md:55
#, fuzzy
msgid ""
"## [Command-Query-Separation(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"
msgstr ""
"## [コマンドクエリ分離(CQS)](https://en.wikipedia.org/wiki/"
"Command%E2%80%93query_separation)"

#: src/additional_resources/design-principles.md:57
#, fuzzy
msgid ""
"“Functions should not produce abstract side effects...only commands\n"
"(procedures) will be permitted to produce side effects.” - Bertrand Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"\"関数は抽象的な副作用を発生させるべきではありません。\n"
"(手続き）のみが副作用を生成することを許されます。\" - バートランド・マイ"
"ヤー\n"
"オブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:61
#, fuzzy
msgid ""
"## [Principle of least astonishment (POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"
msgstr ""
"## [最小驚嘆の原則(POLA)](https://en.wikipedia.org/wiki/"
"Principle_of_least_astonishment)"

#: src/additional_resources/design-principles.md:63
#, fuzzy
msgid ""
"a component of a system should behave in a way that most users will expect "
"it\n"
"to behave. The behavior should not astonish or surprise users"
msgstr ""
"システムのコンポーネントは、ほとんどのユーザーが期待するような振る舞いをする"
"ものでなければなりません。\n"
"であるべきです。その振る舞いは、ユーザーを驚かせたり、驚かせたりするもので"
"あってはなりません。"

#: src/additional_resources/design-principles.md:66
#, fuzzy
msgid "## Linguistic-Modular-Units"
msgstr "## 言語モジュール単位"

#: src/additional_resources/design-principles.md:68
#, fuzzy
msgid ""
"“Modules must correspond to syntactic units in the language used.” - "
"Bertrand\n"
"Meyer: Object-Oriented Software Construction"
msgstr ""
"\"モジュールは使用言語の構文単位に対応しなければならない\" - バートランド\n"
"マイヤーオブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:71
#, fuzzy
msgid "## Self-Documentation"
msgstr "#自己文書化"

#: src/additional_resources/design-principles.md:73
#, fuzzy
msgid ""
"“The designer of a module should strive to make all information about the\n"
"module part of the module itself.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"「モジュールの設計者は、モジュールに関するすべての情報をモジュール自体の一部"
"とするよう努めるべきです。\n"
"モジュールの設計者は、モジュールに関するすべての情報をモジュール自体の一部と"
"するよう努めるべきです。\" - バートランド・マイヤーオブジェクト指向ソフトウェ"
"ア\n"
"構築"

#: src/additional_resources/design-principles.md:77
#, fuzzy
msgid "## Uniform-Access"
msgstr "## ♪ユニフォーム・アクセス"

#: src/additional_resources/design-principles.md:79
#, fuzzy
msgid ""
"“All services offered by a module should be available through a uniform\n"
"notation, which does not betray whether they are implemented through storage "
"or\n"
"through computation.” - Bertrand Meyer: Object-Oriented Software Construction"
msgstr ""
"「モジュールによって提供されるすべてのサービスは、統一された表記法によって利"
"用可能であるべきです。\n"
"モジュールによって提供されるすべてのサービスは、統一された記法によって利用可"
"能であるべきです。\n"
"計算によって実装されているかどうかを裏切ることはありません。\" - バートラン"
"ド・メイヤーオブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:83
#, fuzzy
msgid "## Single-Choice"
msgstr "## シングルチョイス"

#: src/additional_resources/design-principles.md:85
#, fuzzy
msgid ""
"“Whenever a software system must support a set of alternatives, one and "
"only\n"
"one module in the system should know their exhaustive list.” - Bertrand "
"Meyer:\n"
"Object-Oriented Software Construction"
msgstr ""
"\"ソフトウェアシステムが一連の選択肢をサポートしなければならないときはいつで"
"も、システム内の1つのモジュールだけが、その選択肢の網羅的なリストを知っていな"
"ければなりません。\n"
"つのモジュールだけが、その選択肢の網羅的なリストを知っていなければなりませ"
"ん。\" - バートランド・マイヤー\n"
"オブジェクト指向ソフトウェア構築"

#: src/additional_resources/design-principles.md:89
#, fuzzy
msgid "## Persistence-Closure"
msgstr "#永続性-閉鎖"

#: src/additional_resources/design-principles.md:91
#, fuzzy
msgid ""
"“Whenever a storage mechanism stores an object, it must store with it the\n"
"dependents of that object. Whenever a retrieval mechanism retrieves a\n"
"previously stored object, it must also retrieve any dependent of that "
"object\n"
"that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented "
"Software\n"
"Construction"
msgstr ""
"\"ストレージメカニズムがオブジェクトを格納するときは、必ずそのオブジェクトの"
"従属オブジェクトも一緒に格納しなければなりません。\n"
"を格納しなければなりません。検索機構が以前に格納されたオブジェクトを検索する"
"ときは常に\n"
"検索機構が以前に格納されたオブジェクトを検索するときは常に、そのオブジェクト"
"の依存関係も検索しなければなりません。\n"
"を取り出す必要があります。\" - バートランド・マイヤーオブジェクト指向ソフト"
"ウェア\n"
"構築"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "// Some type, not necessarily in the same module or even crate.\n"
#~ "struct Foo {\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // These functions are not present on Bar.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// The newtype.\n"
#~ "pub struct Bar(Foo);\n"
#~ "\n"
#~ "impl Bar {\n"
#~ "    // Constructor.\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> Self {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...);\n"
#~ "\n"
#~ "    // Foo and Bar are type incompatible, the following do not type "
#~ "check.\n"
#~ "    // let f: Foo = b;\n"
#~ "    // let b: Bar = Foo { ... };\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト,無視\n"
#~ "// 同じモジュールやクレート内にあるとは限りません。\n"
#~ "struct Foo {.\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "impl Foo {\n"
#~ "    // これらの関数はBarにはありません。\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "// ニュータイプ。\n"
#~ "pub struct Bar(Foo)；\n"
#~ "\n"
#~ "impl Bar { // コンストラクタ。\n"
#~ "    // コンストラクタ。\n"
#~ "    pub fn new(\n"
#~ "        //..\n"
#~ "    ) -> 自己 {\n"
#~ "\n"
#~ "        //..\n"
#~ "\n"
#~ "    }\n"
#~ "\n"
#~ "    //..\n"
#~ "}\n"
#~ "\n"
#~ "fn main() {\n"
#~ "    let b = Bar::new(...)；\n"
#~ "\n"
#~ "    // Foo と Bar は型互換性がありません。\n"
#~ "    // let f: Foo = b；\n"
#~ "    // let b: Bar = Foo { ...};\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "# Compose structs together for better borrowing"
#~ msgstr "# 構造体をまとめると借りやすくなります"

#, fuzzy
#~ msgid "TODO - this is not a very snappy name"
#~ msgstr "TODO - この名前はあまりスマートではありません。"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "struct A {\n"
#~ "    f1: u32,\n"
#~ "    f2: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    // The later usage of x causes a to be borrowed for the rest of the "
#~ "function.\n"
#~ "    let x = foo(a);\n"
#~ "    // Borrow checker error:\n"
#~ "    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more "
#~ "than once\n"
#~ "                       //          at a time\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "錆\n"
#~ "構造体 A {\n"
#~ "    f1: u32、\n"
#~ "    f2: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "fn foo(a: &mut A) -> &u32 { &a.f2 }.\n"
#~ "fn bar(a: &mut A) -> u32 { a.f1 + a.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { // 後で x を使用すると、以下のようになります。\n"
#~ "    // xの後の使用により、aは関数の残りの部分で借用されます。\n"
#~ "    let x = foo(a)；\n"
#~ "    // 借用チェッカーのエラー：\n"
#~ "    // let y = bar(a); // ~ ERROR: `*a` を mutable として複数回借りること"
#~ "はできません。\n"
#~ "                       // 一度に\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust\n"
#~ "// A is now composed of two structs - B and C.\n"
#~ "struct A {\n"
#~ "    b: B,\n"
#~ "    c: C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32,\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32,\n"
#~ "    f3: u32,\n"
#~ "}\n"
#~ "\n"
#~ "// These functions take a B or C, rather than A.\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }\n"
#~ "\n"
#~ "fn baz(a: &mut A) {\n"
#~ "    let x = foo(&mut a.b);\n"
#~ "    // Now it's OK!\n"
#~ "    let y = bar(&mut a.c);\n"
#~ "    println!(\"{}\", x);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "ラスト\n"
#~ "// AはBとCの2つの構造体で構成されます。\n"
#~ "struct A {\n"
#~ "    b: B、\n"
#~ "    c:C,\n"
#~ "}\n"
#~ "struct B {\n"
#~ "    f2: u32、\n"
#~ "}\n"
#~ "struct C {\n"
#~ "    f1: u32、\n"
#~ "    f3: u32、\n"
#~ "}\n"
#~ "\n"
#~ "// これらの関数は、AではなくBまたはCを取ります。\n"
#~ "fn foo(b: &mut B) -> &u32 { &b.f2 }.\n"
#~ "fn bar(c: &mut C) -> u32 { c.f1 + c.f3 }.\n"
#~ "\n"
#~ "fn baz(a: &mut A) { { fn x = foo(&mut B) -> u32\n"
#~ "    let x = foo(&mut a.b)；\n"
#~ "    // これでOK！\n"
#~ "    let y = bar(&mut a.c)；\n"
#~ "    println!(\"{}\", x)；\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid "TODO Why and where you should use the pattern"
#~ msgstr "TODO パターンを使うべき理由と場所"

#, fuzzy
#~ msgid "Often produces a better design."
#~ msgstr "多くの場合、より良いデザインが生まれます。"

#, fuzzy
#~ msgid "Leads to more verbose code."
#~ msgstr "より冗長なコードになります。"
